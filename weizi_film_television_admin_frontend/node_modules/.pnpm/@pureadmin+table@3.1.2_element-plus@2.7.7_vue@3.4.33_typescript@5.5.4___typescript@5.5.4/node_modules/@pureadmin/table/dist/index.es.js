import * as X from "vue";
import { warn as Ce, defineComponent as ge, createVNode as m, Fragment as de, inject as je, toRefs as Te, ref as Be, getCurrentInstance as Pe, unref as t, computed as w, onMounted as Fe, nextTick as H, onBeforeUnmount as ze, withDirectives as Ne, mergeProps as E, resolveDirective as Re, isVNode as Ee } from "vue";
import { ElLoadingDirective as Ae, ElConfigProvider as $e, ElTable as ke, ElPagination as De, ElTableColumn as Le } from "element-plus";
/**
* @vue/shared v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const He = Object.prototype.hasOwnProperty, Y = (e, n) => He.call(e, n), Z = (e) => e !== null && typeof e == "object", ee = "__epPropKey", Me = ((e, n) => {
  if (!Z(e) || Z(o = e) && o[ee])
    return e;
  var o;
  const { values: p, required: u, default: c, type: l, validator: O } = e, h = p || O ? (v) => {
    let d = !1, y = [];
    if (p && (y = Array.from(p), Y(e, "default") && y.push(c), d || (d = y.includes(v))), O && (d || (d = O(v))), !d && y.length > 0) {
      const i = [...new Set(y)].map((A) => JSON.stringify(A)).join(", ");
      Ce(`Invalid prop: validation failed${n ? ` for prop "${n}"` : ""}. Expected one of [${i}], got value ${JSON.stringify(v)}.`);
    }
    return d;
  } : void 0, B = { type: l, required: !!u, validator: h, [ee]: !0 };
  return Y(e, "default") && (B.default = c), B;
})({ type: String, values: ["", "default", "small", "large"], required: !1 });
var We = { data: { type: Array, default: () => [] }, size: Me, width: [String, Number], height: [String, Number], maxHeight: [String, Number], fit: { type: Boolean, default: !0 }, stripe: Boolean, border: Boolean, rowKey: [String, Function], showHeader: { type: Boolean, default: !0 }, showSummary: Boolean, sumText: String, summaryMethod: Function, rowClassName: [String, Function], rowStyle: [Object, Function], cellClassName: [String, Function], cellStyle: [Object, Function], headerRowClassName: [String, Function], headerRowStyle: [Object, Function], headerCellClassName: [String, Function], headerCellStyle: [Object, Function], highlightCurrentRow: Boolean, currentRowKey: [String, Number], emptyText: String, expandRowKeys: Array, defaultExpandAll: Boolean, defaultSort: Object, tooltipEffect: String, tooltipOptions: Object, spanMethod: Function, selectOnIndeterminate: { type: Boolean, default: !0 }, indent: { type: Number, default: 16 }, treeProps: { type: Object, default: () => ({ hasChildren: "hasChildren", children: "children" }) }, lazy: Boolean, load: Function, style: { type: Object, default: () => ({}) }, className: { type: String, default: "" }, tableLayout: { type: String, default: "fixed" }, scrollbarAlwaysOn: Boolean, flexible: Boolean, showOverflowTooltip: [Boolean, Object] };
const Ie = { tableKey: { type: [String, Number], default: "0" }, columns: { type: Array, default: [] }, loading: { type: Boolean, default: !1 }, loadingConfig: { type: Object, default: () => {
} }, alignWhole: { type: String, default: "left" }, headerAlign: { type: String, default: "" }, showOverflowTooltip: { type: Boolean, default: !1 }, rowHoverBgColor: { type: String, default: "" }, pagination: { type: Object, default: { total: 0, pageSize: 5, align: "right", background: !1, pageSizes: [5, 10, 15, 20], layout: "total, sizes, prev, pager, next, jumper" } }, paginationSmall: { type: Boolean, default: !1 }, adaptive: { type: Boolean, default: !1 }, adaptiveConfig: { type: Object, default: { offsetBottom: 96, fixHeader: !0, timeout: 60, zIndex: 3 } }, locale: { type: [String, Object], default: "" }, ...We }, te = ge({ name: "Renderer", props: { render: { type: Function }, params: { type: Object } }, setup: (e) => () => m(de, null, [e.render(e.params)]) }), ae = { name: "en", el: { select: { loading: "Loading", noMatch: "No matching data", noData: "No data", placeholder: "Select" }, pagination: { goto: "Go to", pagesize: "/page", total: "Total {total}", pageClassifier: "", page: "Page", prev: "Go to previous page", next: "Go to next page", currentPage: "page {pager}", prevPages: "Previous {pager} pages", nextPages: "Next {pager} pages", deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details" }, table: { emptyText: "No Data", confirmFilter: "Confirm", resetFilter: "Reset", clearFilter: "All", sumText: "Sum" } } }, ne = { name: "zh-cn", el: { select: { loading: "加载中", noMatch: "无匹配数据", noData: "无数据", placeholder: "请选择" }, pagination: { goto: "前往", pagesize: "条/页", total: "共 {total} 条", pageClassifier: "页", page: "页", prev: "上一页", next: "下一页", currentPage: "第 {pager} 页", prevPages: "向前 {pager} 页", nextPages: "向后 {pager} 页", deprecationWarning: "你使用了一些已被废弃的用法，请参考 el-pagination 的官方文档" }, table: { emptyText: "暂无数据", confirmFilter: "筛选", resetFilter: "重置", clearFilter: "全部", sumText: "合计" } } }, re = { name: "zh-tw", el: { select: { loading: "載入中", noMatch: "無相符資料", noData: "無資料", placeholder: "請選擇" }, pagination: { goto: "前往", pagesize: "項/頁", total: "共 {total} 項", pageClassifier: "頁", page: "頁", prev: "上一頁", next: "下一頁", currentPage: "第 {pager} 頁", prevPages: "向前 {pager} 頁", nextPages: "向后 {pager} 頁", deprecationWarning: "偵測到已過時的使用方式，請參閱 el-pagination 說明文件以了解更多資訊" }, table: { emptyText: "暫無資料", confirmFilter: "篩選", resetFilter: "重置", clearFilter: "全部", sumText: "合計" } } };
var fe = Object.defineProperty, Ke = Object.getOwnPropertyDescriptor, qe = Object.getOwnPropertyNames, Ve = Object.prototype.hasOwnProperty, oe = (e, n, o, p) => {
  if (n && typeof n == "object" || typeof n == "function")
    for (let u of qe(n))
      !Ve.call(e, u) && u !== o && fe(e, u, { get: () => n[u], enumerable: !(p = Ke(n, u)) || p.enumerable });
  return e;
}, Ge = Object.prototype.toString;
function me(e, n) {
  return Ge.call(e) === `[object ${n}]`;
}
function le(e) {
  return me(e, "String");
}
function ie(e) {
  return typeof e == "function";
}
var se, pe, ue = (e) => e.replace(/\B([A-Z])/g, "-$1").toLowerCase(), S = {};
((e, n) => {
  for (var o in n)
    fe(e, o, { get: n[o], enumerable: !0 });
})(S, { Vue: () => X }), oe(S, se = X, "default"), pe && oe(pe, se, "default");
var Je = (e) => {
  let n, o = (e == null ? void 0 : e.className) ?? "dark", p = (0, S.shallowRef)(!1), u = () => {
    let c = e != null && e.selector ? e.selector === "html" ? document.documentElement : document.body : document.documentElement;
    p.value = c.classList.contains(o);
  };
  return function(c) {
    (0, S.getCurrentInstance)() && (0, S.onUnmounted)(c);
  }(() => {
    n && (n.takeRecords(), n.disconnect());
  }), (0, S.onBeforeMount)(() => {
    let c = e != null && e.selector ? e.selector === "html" ? document.documentElement : document.body : document.documentElement;
    u(), n = new MutationObserver(u), n.observe(c, { attributes: !0, attributeFilter: ["class"] });
  }), { isDark: p, toggleDark: () => {
    (e != null && e.selector ? e.selector === "html" ? document.documentElement : document.body : document.documentElement).classList.toggle(o);
  } };
};
function ce(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Ee(e);
}
const M = ge({ name: "PureTable", props: Ie, directives: { Loading: Ae }, emits: ["page-size-change", "page-current-change"], setup(e, { slots: n, attrs: o, emit: p, expose: u }) {
  const { locale: c, i18n: l, ssr: O } = je("locale", { locale: null, i18n: null, ssr: !1 }), { locale: h, columns: B, loading: v, tableKey: d, adaptive: y, pagination: i, alignWhole: A, headerAlign: ye, loadingConfig: P, adaptiveConfig: C, rowHoverBgColor: W, showOverflowTooltip: be } = Te(e), I = Be(!1), { isDark: he } = Je(), $ = Pe();
  let ve = t(i) && t(i).currentPage && t(i).pageSize, K = w(() => {
    var r, f, s, b;
    if (!t(l))
      return;
    const a = ((s = (f = l == null ? void 0 : l.global) == null ? void 0 : f.getLocaleMessage(t((r = l == null ? void 0 : l.global) == null ? void 0 : r.locale))) == null ? void 0 : s.el) || ((b = l == null ? void 0 : l.getLocaleMessage(t(l == null ? void 0 : l.locale))) == null ? void 0 : b.el);
    return a ? { el: a } : null;
  }), q = w(() => le(c) ? [ae, ne, re].filter((a) => a.name === ue(c))[0] : c), k = w(() => {
    if (t(h))
      return le(t(h)) ? [ae, ne, re].filter((a) => a.name === ue(t(h)))[0] : t(h);
  }), xe = w(() => {
    if (!t(P))
      return;
    let { text: a, spinner: r, svg: f, viewBox: s } = t(P);
    return { "element-loading-text": a, "element-loading-spinner": r, "element-loading-svg": f, "element-loading-svg-view-box": s };
  });
  const we = w(() => {
    var a, r;
    if (t(v))
      return { "element-loading-background": (a = t(P)) != null && a.background ? (r = t(P)) == null ? void 0 : r.background : he.value ? "rgba(0, 0, 0, 0.45)" : "rgba(255, 255, 255, 0.45)" };
  }), Se = w(() => Object.assign({ width: "100%", margin: "16px 0", display: "flex", flexWrap: "wrap", justifyContent: t(i).align === "left" ? "flex-start" : t(i).align === "center" ? "center" : "flex-end" }, t(i).style ?? {})), V = (a, r) => {
    const { cellRenderer: f, slot: s, headerRenderer: b, headerSlot: j, hide: x, children: z, prop: N, ...Oe } = a;
    if (ie(x) && x(o))
      return x(o);
    if (function(g) {
      return me(g, "Boolean");
    }(x) && x)
      return x;
    const L = { default: (g) => {
      var T;
      return f ? m(te, { render: f, params: Object.assign(g, { index: g.$index, props: e, attrs: o }) }, null) : s ? (T = n == null ? void 0 : n[s]) == null ? void 0 : T.call(n, Object.assign(g, { index: g.$index, props: e, attrs: o })) : void 0;
    } };
    let R = b ? { header: (g) => m(te, { render: b, params: Object.assign(g, { index: g.$index, props: e, attrs: o }) }, null), ...L } : n != null && n[j] ? { header: (g) => {
      var T;
      return (T = n == null ? void 0 : n[j]) == null ? void 0 : T.call(n, Object.assign(g, { index: g.$index, props: e, attrs: o }));
    }, ...L } : L;
    return (z == null ? void 0 : z.length) > 0 && (R = z.map(V)), m(Le, E({ key: r }, Oe, { prop: ie(N) && N(r) ? N(r) : N, align: a != null && a.align ? a.align : t(A), headerAlign: a != null && a.headerAlign ? a.headerAlign : t(ye), showOverflowTooltip: a != null && a.showOverflowTooltip ? a.showOverflowTooltip : t(be) }), ce(R) ? R : { default: () => [R] });
  }, G = () => {
    var a;
    return (a = $ == null ? void 0 : $.proxy) == null ? void 0 : a.$refs[`TableRef${t(d)}`];
  }, F = () => G().$refs, D = async () => {
    await H();
    const a = F().tableWrapper, r = t(C).offsetBottom ?? 96;
    a.style.height = window.innerHeight - a.getBoundingClientRect().top - r + "px";
  }, J = ((a, r = 200, f = !1) => {
    let s, b, j = r;
    return function() {
      s && clearTimeout(s), f ? (s || a.call(b, ...arguments), s = setTimeout(() => s = null, j)) : s = setTimeout(() => a.call(b, ...arguments), j);
    };
  })(D, t(C).timeout ?? 60), U = async (a = 3) => {
    await H();
    const r = F().tableHeaderRef.$el.style;
    r.position = "sticky", r.top = 0, r.zIndex = a;
  };
  Fe(() => {
    I.value = !0, H(() => {
      if (t(W) && F().tableWrapper.style.setProperty("--el-table-row-hover-bg-color", t(W), "important"), t(y)) {
        if (D(), window.addEventListener("resize", J), Reflect.has(t(C), "fixHeader") && !t(C).fixHeader)
          return;
        U(t(C).zIndex ?? 3);
      }
    });
  }), ze(() => {
    t(y) && window.removeEventListener("resize", J);
  }), u({ getTableRef: G, getTableDoms: F, setAdaptive: D, setHeaderSticky: U });
  let _ = () => m(de, null, [m(ke, E(e, o, { ref: `TableRef${t(d)}` }), { default: () => t(B).map(V), append: () => n.append && n.append(), empty: () => n.empty && n.empty() }), ve ? m(De, E(o, { class: "pure-pagination", style: t(Se) }, t(i), { small: e != null && e.paginationSmall ? e == null ? void 0 : e.paginationSmall : !!t(i).small && t(i).small, layout: t(i).layout ?? "total, sizes, prev, pager, next, jumper", pageSizes: t(i).pageSizes ?? [5, 10, 15, 20], onSizeChange: (a) => ((r) => {
    t(i).pageSize = r, p("page-size-change", r);
  })(a), onCurrentChange: (a) => ((r) => {
    t(i).currentPage = r, p("page-current-change", r);
  })(a) }), null) : null]), Q = () => {
    let a;
    return Ne(m("div", E({ class: "pure-table", style: "width:100%" }, t(we), t(xe)), [t(K) || t(q) || t(k) ? m($e, { locale: t(k) ? t(k) : t(K) || t(q) }, ce(a = _()) ? a : { default: () => [a] }) : _()]), [[Re("loading"), t(v)]]);
  };
  return () => O ? I.value && Q() : Q();
} }), Qe = Object.assign(M, { install: (e, n) => {
  e.component(M.name, M), e.provide("locale", n ?? { locale: null, i18n: null, ssr: !1 });
} });
export {
  Qe as PureTable,
  Qe as default
};
