/*! plus-pro-components v0.0.2 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue'), require('element-plus')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue', 'element-plus'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.PlusProComponents = {}, global.Vue, global.ElementPlus));
})(this, (function (exports, vue, elementPlus) { 'use strict';

  const makeInstaller = (components = []) => {
    const install = (app) => {
      components.forEach((component) => app.component(component.name, component));
    };
    return {
      install
    };
  };

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Built-in value references. */
  var Symbol$1 = root.Symbol;

  /** Used for built-in method references. */
  var objectProto$c = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$c.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty$9.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$b = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$b.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString$1(value) {
    return nativeObjectToString.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString$1(value);
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /** `Object#toString` result references. */
  var symbolTag$2 = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike(value) && baseGetTag(value) == symbolTag$2);
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray$1 = Array.isArray;

  /** Used as references for various `Number` constants. */
  var INFINITY$1 = 1 / 0;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
      symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray$1(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap(value, baseToString) + '';
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$1(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag$2 = '[object Function]',
      genTag$1 = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$1(value) {
    if (!isObject$1(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root['__core-js_shared__'];

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
      objectProto$a = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString.call(hasOwnProperty$8).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject$1(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue$1(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue$1(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /* Built-in method references that are verified to be native. */
  var WeakMap = getNative(root, 'WeakMap');

  /** Built-in value references. */
  var objectCreate = Object.create;

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function object() {}
    return function(proto) {
      if (!isObject$1(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }());

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  var defineProperty = (function() {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }());

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
      defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /** Used for built-in method references. */
  var objectProto$9 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$7.call(object, key) && eq(objValue, value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction$1(value);
  }

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$8;

    return value === proto;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /** `Object#toString` result references. */
  var argsTag$2 = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$2;
  }

  /** Used for built-in method references. */
  var objectProto$7 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty$6.call(value, 'callee') &&
      !propertyIsEnumerable$1.call(value, 'callee');
  };

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  /** Detect free variable `exports`. */
  var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

  /** Built-in value references. */
  var Buffer$1 = moduleExports$2 ? root.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      boolTag$2 = '[object Boolean]',
      dateTag$2 = '[object Date]',
      errorTag$1 = '[object Error]',
      funcTag$1 = '[object Function]',
      mapTag$4 = '[object Map]',
      numberTag$2 = '[object Number]',
      objectTag$2 = '[object Object]',
      regexpTag$2 = '[object RegExp]',
      setTag$4 = '[object Set]',
      stringTag$2 = '[object String]',
      weakMapTag$2 = '[object WeakMap]';

  var arrayBufferTag$2 = '[object ArrayBuffer]',
      dataViewTag$3 = '[object DataView]',
      float32Tag$2 = '[object Float32Array]',
      float64Tag$2 = '[object Float64Array]',
      int8Tag$2 = '[object Int8Array]',
      int16Tag$2 = '[object Int16Array]',
      int32Tag$2 = '[object Int32Array]',
      uint8Tag$2 = '[object Uint8Array]',
      uint8ClampedTag$2 = '[object Uint8ClampedArray]',
      uint16Tag$2 = '[object Uint16Array]',
      uint32Tag$2 = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
  typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
  typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
  typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
  typedArrayTags[uint32Tag$2] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
  typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] =
  typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] =
  typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] =
  typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] =
  typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] =
  typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] =
  typedArrayTags[weakMapTag$2] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike(value) &&
      isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /** Detect free variable `exports`. */
  var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports$1 && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray$1(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$5.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys = overArg(Object.keys, Object);

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$4.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeysIn(object) {
    if (!isObject$1(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$3.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey(value, object) {
    if (isArray$1(value)) {
      return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
      (object != null && value in Object(object));
  }

  /* Built-in method references that are verified to be native. */
  var nativeCreate = getNative(Object, 'create');

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED$1 ? undefined : result;
    }
    return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$1.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /* Built-in method references that are verified to be native. */
  var Map = getNative(root, 'Map');

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash,
      'map': new (Map || ListCache),
      'string': new Hash
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = MapCache;

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  /** Used to match property names within property paths. */
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
    });
    return result;
  });

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath(value, object) {
    if (isArray$1(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0;

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet(object, path) {
    path = castPath(path, object);

    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return (index && index == length) ? object : undefined;
  }

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /** Built-in value references. */
  var getPrototype = overArg(Object.getPrototypeOf, Object);

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  /**
   * The base implementation of `_.assign` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }

  /**
   * The base implementation of `_.assignIn` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer = moduleExports ? root.Buffer : undefined,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

    buffer.copy(result);
    return result;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };

  /**
   * Copies own symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own and inherited enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
    var result = [];
    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }
    return result;
  };

  /**
   * Copies own and inherited symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  /**
   * Creates an array of own and inherited enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }

  /* Built-in method references that are verified to be native. */
  var DataView = getNative(root, 'DataView');

  /* Built-in method references that are verified to be native. */
  var Promise$1 = getNative(root, 'Promise');

  /* Built-in method references that are verified to be native. */
  var Set = getNative(root, 'Set');

  /** `Object#toString` result references. */
  var mapTag$3 = '[object Map]',
      objectTag$1 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$3 = '[object Set]',
      weakMapTag$1 = '[object WeakMap]';

  var dataViewTag$2 = '[object DataView]';

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise$1),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
      (Map && getTag(new Map) != mapTag$3) ||
      (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
      (Set && getTag(new Set) != setTag$3) ||
      (WeakMap && getTag(new WeakMap) != weakMapTag$1)) {
    getTag = function(value) {
      var result = baseGetTag(value),
          Ctor = result == objectTag$1 ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag$2;
          case mapCtorString: return mapTag$3;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag$3;
          case weakMapCtorString: return weakMapTag$1;
        }
      }
      return result;
    };
  }

  var getTag$1 = getTag;

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */
  function initCloneArray(array) {
    var length = array.length,
        result = new array.constructor(length);

    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }

  /** Built-in value references. */
  var Uint8Array = root.Uint8Array;

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /** `Object#toString` result references. */
  var boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      mapTag$2 = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag$1 = '[object RegExp]',
      setTag$2 = '[object Set]',
      stringTag$1 = '[object String]',
      symbolTag$1 = '[object Symbol]';

  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$1 = '[object DataView]',
      float32Tag$1 = '[object Float32Array]',
      float64Tag$1 = '[object Float64Array]',
      int8Tag$1 = '[object Int8Array]',
      int16Tag$1 = '[object Int16Array]',
      int32Tag$1 = '[object Int32Array]',
      uint8Tag$1 = '[object Uint8Array]',
      uint8ClampedTag$1 = '[object Uint8ClampedArray]',
      uint16Tag$1 = '[object Uint16Array]',
      uint32Tag$1 = '[object Uint32Array]';

  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag$1:
        return cloneArrayBuffer(object);

      case boolTag$1:
      case dateTag$1:
        return new Ctor(+object);

      case dataViewTag$1:
        return cloneDataView(object, isDeep);

      case float32Tag$1: case float64Tag$1:
      case int8Tag$1: case int16Tag$1: case int32Tag$1:
      case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
        return cloneTypedArray(object, isDeep);

      case mapTag$2:
        return new Ctor;

      case numberTag$1:
      case stringTag$1:
        return new Ctor(object);

      case regexpTag$1:
        return cloneRegExp(object);

      case setTag$2:
        return new Ctor;

      case symbolTag$1:
        return cloneSymbol(object);
    }
  }

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return (typeof object.constructor == 'function' && !isPrototype(object))
      ? baseCreate(getPrototype(object))
      : {};
  }

  /** `Object#toString` result references. */
  var mapTag$1 = '[object Map]';

  /**
   * The base implementation of `_.isMap` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   */
  function baseIsMap(value) {
    return isObjectLike(value) && getTag$1(value) == mapTag$1;
  }

  /* Node.js helper references. */
  var nodeIsMap = nodeUtil && nodeUtil.isMap;

  /**
   * Checks if `value` is classified as a `Map` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   * @example
   *
   * _.isMap(new Map);
   * // => true
   *
   * _.isMap(new WeakMap);
   * // => false
   */
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

  /** `Object#toString` result references. */
  var setTag$1 = '[object Set]';

  /**
   * The base implementation of `_.isSet` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   */
  function baseIsSet(value) {
    return isObjectLike(value) && getTag$1(value) == setTag$1;
  }

  /* Node.js helper references. */
  var nodeIsSet = nodeUtil && nodeUtil.isSet;

  /**
   * Checks if `value` is classified as a `Set` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   * @example
   *
   * _.isSet(new Set);
   * // => true
   *
   * _.isSet(new WeakSet);
   * // => false
   */
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG$1 = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG$1 = 4;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Deep clone
   *  2 - Flatten inherited properties
   *  4 - Clone symbols
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result,
        isDeep = bitmask & CLONE_DEEP_FLAG$1,
        isFlat = bitmask & CLONE_FLAT_FLAG,
        isFull = bitmask & CLONE_SYMBOLS_FLAG$1;

    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject$1(value)) {
      return value;
    }
    var isArr = isArray$1(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag$1(value),
          isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
        result = (isFlat || isFunc) ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat
            ? copySymbolsIn(value, baseAssignIn(result, value))
            : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);

    if (isSet(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap(value)) {
      value.forEach(function(subValue, key) {
        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
    }

    var keysFunc = isFull
      ? (isFlat ? getAllKeysIn : getAllKeys)
      : (isFlat ? keysIn : keys);

    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function(subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }
      // Recursively populate clone (susceptible to call stack limits).
      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_SYMBOLS_FLAG = 4;

  /**
   * This method is like `_.clone` except that it recursively clones `value`.
   *
   * @static
   * @memberOf _
   * @since 1.0.0
   * @category Lang
   * @param {*} value The value to recursively clone.
   * @returns {*} Returns the deep cloned value.
   * @see _.clone
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var deep = _.cloneDeep(objects);
   * console.log(deep[0] === objects[0]);
   * // => false
   */
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
  }

  /**
   * The base implementation of `_.set`.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @param {Function} [customizer] The function to customize path creation.
   * @returns {Object} Returns `object`.
   */
  function baseSet(object, path, value, customizer) {
    if (!isObject$1(object)) {
      return object;
    }
    path = castPath(path, object);

    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        nested = object;

    while (nested != null && ++index < length) {
      var key = toKey(path[index]),
          newValue = value;

      if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
        return object;
      }

      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;
        if (newValue === undefined) {
          newValue = isObject$1(objValue)
            ? objValue
            : (isIndex(path[index + 1]) ? [] : {});
        }
      }
      assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object;
  }

  /**
   * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
   * it's created. Arrays are created for missing index properties while objects
   * are created for all other missing properties. Use `_.setWith` to customize
   * `path` creation.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.set(object, 'a[0].b.c', 4);
   * console.log(object.a[0].b.c);
   * // => 4
   *
   * _.set(object, ['x', '0', 'y', 'z'], 5);
   * console.log(object.x[0].y.z);
   * // => 5
   */
  function set(object, path, value) {
    return object == null ? object : baseSet(object, path, value);
  }

  const objectToString = Object.prototype.toString;
  const toTypeString = (value) => objectToString.call(value);
  const toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  const isArray = Array.isArray;
  const isDate = (val) => toTypeString(val) === "[object Date]";
  const isFunction = (val) => typeof val === "function";
  const isString = (val) => typeof val === "string";
  const isObject = (val) => val !== null && typeof val === "object";
  const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
  };
  const isPlainObject = (val) => toTypeString(val) === "[object Object]";
  function isUrl(url) {
    const regex = new RegExp(
      "^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$",
      "i"
    );
    return regex.test(url);
  }

  function formatDate(date, format = "YYYY-MM-DD HH:mm:ss") {
    return elementPlus.dayjs(date || /* @__PURE__ */ new Date()).format(format);
  }
  function formatMoney(val, format = "\uFFE5", decimal = 2) {
    return `${format}${Number(val).toFixed(decimal)}`;
  }

  const getTableKey = (item, hasEditable = false) => hasEditable ? item.label + item.prop + item.editable : item.label + item.prop;
  const getTooltip = (tooltip) => {
    if (isString(tooltip)) {
      return { content: tooltip };
    }
    if (isPlainObject(tooltip)) {
      return tooltip;
    }
  };
  const throwError$1 = (data, type) => {
    if (!isPlainObject(data)) {
      throw new Error(`${type} expected Object but got ${toRawType(data)}`);
    }
  };
  const getCustomProps = async (props, value, row, index, type) => {
    try {
      let data = {};
      const params = { row, index };
      if (!props) {
        data = {};
      } else if (vue.isRef(props)) {
        data = props.value;
      } else if (isPlainObject(props)) {
        data = { ...props };
      } else if (isFunction(props)) {
        data = await props(value, params);
      } else if (isPromise(props)) {
        data = await props;
      } else {
        data = props;
      }
      throwError$1(data, type);
      return data;
    } catch (error) {
      return Promise.reject(error);
    }
  };
  const getSlotName = (type, prop) => {
    return prop ? `plus-${type}-${prop}` : `plus-${type}`;
  };
  const getFieldSlotName = (prop) => {
    return `${getSlotName("field", prop)}`;
  };
  const getLabelSlotName = (prop) => {
    return `${getSlotName("label", prop)}`;
  };
  const getExtraSlotName = (prop) => {
    return `${getSlotName("extra", prop)}`;
  };
  const getTableHeaderSlotName = (prop) => {
    return `${getSlotName("header", prop)}`;
  };
  const getTableCellSlotName = (prop) => {
    return `${getSlotName("cell", prop)}`;
  };
  const getDescSlotName = (prop) => {
    return `${getSlotName("desc", prop)}`;
  };
  const getDescLabelSlotName = (prop) => {
    return `${getSlotName("desc-label", prop)}`;
  };
  const filterSlots = (slots, name) => {
    const data = {};
    Object.keys(slots || {}).forEach((key) => {
      if (key.startsWith(name)) {
        data[key] = slots[key];
      }
    });
    return data;
  };
  const getValue = (target, key) => {
    return get(target, key);
  };
  const setValue = (target, key, value) => {
    return set(target, key, value);
  };

  const throwError = (data) => {
    if (!isArray(data)) {
      console.error("Uncaught TypeError: ", `options expected Array but got ${toRawType(data)}`);
    }
  };
  const useGetOptions = (props) => {
    const options = vue.ref([]);
    if (!props.options) {
      options.value = [];
    } else if (vue.isRef(props.options)) {
      vue.watch(
        props.options,
        (val) => {
          options.value = val;
        },
        {
          immediate: true
        }
      );
    } else if (isArray(props.options)) {
      options.value = [...props.options];
    } else if (isFunction(props.options)) {
      const getValue = props.options;
      const result = getValue(props);
      if (isPromise(result)) {
        result.then((res) => {
          options.value = res;
          throwError(options.value);
        }).catch((err) => {
          throw err;
        });
      } else {
        options.value = result;
      }
    } else if (isPromise(props.options)) {
      const getValue = props.options;
      getValue.then((res) => {
        options.value = res;
        throwError(options.value);
      }).catch((err) => {
        throw err;
      });
    } else {
      throwError(props.options);
    }
    return options;
  };

  var English = {
    name: "en",
    plus: {
      dialog: {
        confirmText: "Yes",
        cancelText: "No",
        title: "Dialog"
      },
      datepicker: {
        startPlaceholder: "Please select start time",
        endPlaceholder: "Please select end time"
      },
      dialogForm: {
        title: "Dialog form"
      },
      drawerForm: {
        title: "Drawer form"
      },
      form: {
        submitText: "Submit",
        resetText: "Reset",
        errorTip: "Please complete the form and submit again!"
      },
      field: {
        pleaseEnter: "Please enter",
        pleaseSelect: "Please select"
      },
      popover: {
        confirmText: "Yes",
        cancelText: "No"
      },
      search: {
        searchText: "Search",
        resetText: "Reset",
        expand: "Expand",
        retract: "Retract"
      },
      table: {
        title: "Table",
        density: "Density",
        refresh: "Refresh",
        columnSettings: "Column settings",
        selectAll: "Select all",
        default: "Default",
        loose: "Loose",
        compact: "Compact",
        action: "Action",
        more: "More",
        confirmToPerformThisOperation: "Confirm to perform this operation?",
        prompt: "Prompt",
        sort: "Sort"
      },
      stepsForm: {
        nextText: "Next step",
        preText: "Previous step",
        submitText: "Submit"
      },
      inputTag: {
        placeholder: "Please enter keywords and press enter or space key"
      },
      header: {
        logout: "logout"
      }
    }
  };

  const buildTranslator = (locale) => (path, option) => translate(path, option, vue.unref(locale));
  const translate = (path, option, locale) => get(locale, path, path).replace(
    /\{(\w+)\}/g,
    (_, key) => {
      var _a;
      return `${(_a = option == null ? void 0 : option[key]) != null ? _a : `{${key}}`}`;
    }
  );
  const buildLocaleContext = (locale) => {
    const lang = vue.computed(() => vue.unref(locale).name);
    const localeRef = vue.isRef(locale) ? locale : vue.ref(locale);
    return {
      lang,
      locale: localeRef,
      t: buildTranslator(locale)
    };
  };
  const useLocale = (localeOverrides) => {
    const locale = localeOverrides || vue.inject(elementPlus.localeContextKey, vue.ref());
    return buildLocaleContext(vue.computed(() => locale.value || English));
  };

  const DefaultPageSizeList = [10, 20, 30, 40, 50, 100, 200, 300, 400, 500];
  const DefaultPageInfo = {
    page: 1,
    pageSize: 10
  };

  const TableFormRefInjectionKey = Symbol("tableFormRefInjectionKey");

  function useTable(_pageInfo) {
    const defaultPageInfo = vue.unref(_pageInfo) || DefaultPageInfo;
    const tableData = vue.ref([]);
    const pageInfo = vue.ref({ ...defaultPageInfo });
    const total = vue.ref(0);
    const loadingStatus = vue.ref(false);
    const buttons = vue.shallowRef([]);
    return {
      tableData,
      pageInfo,
      total,
      loadingStatus,
      buttons
    };
  }

  const _hoisted_1$h = { class: "plus-dialog-body" };
  var _sfc_main$t = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusDialog"
    },
    __name: "index",
    props: {
      modelValue: { type: Boolean, required: false, default: false },
      confirmText: { type: String, required: false, default: "" },
      cancelText: { type: String, required: false, default: "" },
      confirmLoading: { type: Boolean, required: false, default: false },
      hasFooter: { type: Boolean, required: false, default: true },
      footerAlign: { type: String, required: false, default: "right" },
      top: { type: String, required: false, default: "15vh" },
      width: { type: String, required: false, default: "460px" },
      title: { type: String, required: false, default: "" }
    },
    emits: ["update:modelValue", "cancel", "confirm"],
    setup(__props, { emit }) {
      const props = __props;
      const style = vue.computed(() => ({
        justifyContent: props.footerAlign === "left" ? "flex-start" : props.footerAlign === "center" ? "center" : "flex-end"
      }));
      const subVisible = vue.ref(false);
      const { t } = useLocale();
      vue.watchEffect(() => {
        subVisible.value = props.modelValue;
      });
      const handleConfirm = () => {
        emit("confirm");
      };
      const handleCancel = () => {
        emit("update:modelValue", false);
        emit("cancel");
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElDialog), vue.mergeProps({
          modelValue: subVisible.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => subVisible.value = $event),
          top: _ctx.top,
          width: _ctx.width,
          title: _ctx.title || vue.unref(t)("plus.dialog.title"),
          "close-on-click-modal": false,
          "close-on-press-escape": false,
          "append-to-body": false,
          "before-close": handleCancel,
          class: "plus-dialog"
        }, _ctx.$attrs), vue.createSlots({
          default: vue.withCtx(() => [
            vue.createElementVNode("div", _hoisted_1$h, [
              vue.renderSlot(_ctx.$slots, "default")
            ])
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          _ctx.$slots.header ? {
            name: "header",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "header")
            ]),
            key: "0"
          } : void 0,
          _ctx.hasFooter ? {
            name: "footer",
            fn: vue.withCtx(() => [
              vue.createElementVNode(
                "div",
                {
                  class: "plus-dialog-footer",
                  style: vue.normalizeStyle(style.value)
                },
                [
                  vue.renderSlot(_ctx.$slots, "footer", {}, () => [
                    vue.createVNode(vue.unref(elementPlus.ElButton), { onClick: handleCancel }, {
                      default: vue.withCtx(() => [
                        vue.createTextVNode(
                          vue.toDisplayString(_ctx.cancelText || vue.unref(t)("plus.dialog.cancelText")),
                          1
                          /* TEXT */
                        )
                      ]),
                      _: 1
                      /* STABLE */
                    }),
                    vue.createVNode(vue.unref(elementPlus.ElButton), {
                      type: "primary",
                      loading: _ctx.confirmLoading,
                      onClick: handleConfirm
                    }, {
                      default: vue.withCtx(() => [
                        vue.createTextVNode(
                          vue.toDisplayString(_ctx.confirmText || vue.unref(t)("plus.dialog.confirmText")),
                          1
                          /* TEXT */
                        )
                      ]),
                      _: 1
                      /* STABLE */
                    }, 8, ["loading"])
                  ])
                ],
                4
                /* STYLE */
              )
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["modelValue", "top", "width", "title"]);
      };
    }
  });

  var _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };

  var Dialog = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\dialog\\src\\index.vue"]]);

  const PlusDialog = Dialog;

  const _hoisted_1$g = { class: "plus-pagination" };
  const _hoisted_2$6 = /* @__PURE__ */ vue.createElementVNode(
    "span",
    null,
    null,
    -1
    /* HOISTED */
  );
  const _hoisted_3$3 = /* @__PURE__ */ vue.createElementVNode(
    "span",
    null,
    null,
    -1
    /* HOISTED */
  );
  var _sfc_main$s = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusPagination"
    },
    __name: "index",
    props: {
      modelValue: { type: null, required: true, default: () => ({ ...DefaultPageInfo }) },
      total: { type: Number, required: false, default: 0 },
      pageSizeList: { type: Array, required: false, default: () => [...DefaultPageSizeList] },
      align: { type: String, required: false, default: "right" }
    },
    emits: ["update:modelValue", "change", "size-change", "current-change"],
    setup(__props, { emit }) {
      const props = __props;
      const pageInfo = vue.ref({ ...DefaultPageInfo });
      vue.watchEffect(() => {
        pageInfo.value = { ...props.modelValue };
      });
      const handleEmit = () => {
        emit("update:modelValue", pageInfo.value);
        emit("change", pageInfo.value);
      };
      const handleSizeChange = (pageSize) => {
        pageInfo.value.pageSize = pageSize;
        pageInfo.value.page = 1;
        handleEmit();
        emit("size-change", pageSize);
      };
      const handleCurrentChange = (page) => {
        pageInfo.value.page = page;
        handleEmit();
        emit("current-change", page);
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$g, [
          _ctx.align === "right" ? vue.renderSlot(_ctx.$slots, "pagination-left", { key: 0 }, () => [
            _hoisted_2$6
          ]) : vue.createCommentVNode("v-if", true),
          vue.createVNode(vue.unref(elementPlus.ElPagination), vue.mergeProps({
            layout: "total, sizes, prev, pager, next, jumper",
            background: false,
            "current-page": pageInfo.value.page,
            "page-size": pageInfo.value.pageSize,
            total: _ctx.total,
            "page-sizes": _ctx.pageSizeList
          }, _ctx.$attrs, {
            onSizeChange: handleSizeChange,
            onCurrentChange: handleCurrentChange
          }), null, 16, ["current-page", "page-size", "total", "page-sizes"]),
          _ctx.align === "left" ? vue.renderSlot(_ctx.$slots, "pagination-right", { key: 1 }, () => [
            _hoisted_3$3
          ]) : vue.createCommentVNode("v-if", true)
        ]);
      };
    }
  });

  var Pagination = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\pagination\\src\\index.vue"]]);

  const PlusPagination = Pagination;

  /*! Element Plus Icons Vue v2.3.1 */

  var arrow_down_bold_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "ArrowDownBold",
    __name: "arrow-down-bold",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M104.704 338.752a64 64 0 0 1 90.496 0l316.8 316.8 316.8-316.8a64 64 0 0 1 90.496 90.496L557.248 791.296a64 64 0 0 1-90.496 0L104.704 429.248a64 64 0 0 1 0-90.496z"
        })
      ]));
    }
  });

  // src/components/arrow-down-bold.vue
  var arrow_down_bold_default = arrow_down_bold_vue_vue_type_script_setup_true_lang_default;
  var arrow_down_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "ArrowDown",
    __name: "arrow-down",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
        })
      ]));
    }
  });

  // src/components/arrow-down.vue
  var arrow_down_default = arrow_down_vue_vue_type_script_setup_true_lang_default;
  var arrow_up_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "ArrowUp",
    __name: "arrow-up",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
        })
      ]));
    }
  });

  // src/components/arrow-up.vue
  var arrow_up_default = arrow_up_vue_vue_type_script_setup_true_lang_default;
  var document_copy_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "DocumentCopy",
    __name: "document-copy",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M128 320v576h576V320zm-32-64h640a32 32 0 0 1 32 32v640a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V288a32 32 0 0 1 32-32M960 96v704a32 32 0 0 1-32 32h-96v-64h64V128H384v64h-64V96a32 32 0 0 1 32-32h576a32 32 0 0 1 32 32M256 672h320v64H256zm0-192h320v64H256z"
        })
      ]));
    }
  });

  // src/components/document-copy.vue
  var document_copy_default = document_copy_vue_vue_type_script_setup_true_lang_default;
  var expand_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "Expand",
    __name: "expand",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M128 192h768v128H128zm0 256h512v128H128zm0 256h768v128H128zm576-352 192 160-192 128z"
        })
      ]));
    }
  });

  // src/components/expand.vue
  var expand_default = expand_vue_vue_type_script_setup_true_lang_default;
  var fold_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "Fold",
    __name: "fold",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M896 192H128v128h768zm0 256H384v128h512zm0 256H128v128h768zM320 384 128 512l192 128z"
        })
      ]));
    }
  });

  // src/components/fold.vue
  var fold_default = fold_vue_vue_type_script_setup_true_lang_default;
  var question_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "QuestionFilled",
    __name: "question-filled",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
        })
      ]));
    }
  });

  // src/components/question-filled.vue
  var question_filled_default = question_filled_vue_vue_type_script_setup_true_lang_default;
  var refresh_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "RefreshRight",
    __name: "refresh-right",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
        })
      ]));
    }
  });

  // src/components/refresh-right.vue
  var refresh_right_default = refresh_right_vue_vue_type_script_setup_true_lang_default;
  var search_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "Search",
    __name: "search",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704"
        })
      ]));
    }
  });

  // src/components/search.vue
  var search_default = search_vue_vue_type_script_setup_true_lang_default;
  var select_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "Select",
    __name: "select",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M77.248 415.04a64 64 0 0 1 90.496 0l226.304 226.304L846.528 188.8a64 64 0 1 1 90.56 90.496l-543.04 543.04-316.8-316.8a64 64 0 0 1 0-90.496z"
        })
      ]));
    }
  });

  // src/components/select.vue
  var select_default = select_vue_vue_type_script_setup_true_lang_default;
  var setting_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "Setting",
    __name: "setting",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M600.704 64a32 32 0 0 1 30.464 22.208l35.2 109.376c14.784 7.232 28.928 15.36 42.432 24.512l112.384-24.192a32 32 0 0 1 34.432 15.36L944.32 364.8a32 32 0 0 1-4.032 37.504l-77.12 85.12a357.12 357.12 0 0 1 0 49.024l77.12 85.248a32 32 0 0 1 4.032 37.504l-88.704 153.6a32 32 0 0 1-34.432 15.296L708.8 803.904c-13.44 9.088-27.648 17.28-42.368 24.512l-35.264 109.376A32 32 0 0 1 600.704 960H423.296a32 32 0 0 1-30.464-22.208L357.696 828.48a351.616 351.616 0 0 1-42.56-24.64l-112.32 24.256a32 32 0 0 1-34.432-15.36L79.68 659.2a32 32 0 0 1 4.032-37.504l77.12-85.248a357.12 357.12 0 0 1 0-48.896l-77.12-85.248A32 32 0 0 1 79.68 364.8l88.704-153.6a32 32 0 0 1 34.432-15.296l112.32 24.256c13.568-9.152 27.776-17.408 42.56-24.64l35.2-109.312A32 32 0 0 1 423.232 64H600.64zm-23.424 64H446.72l-36.352 113.088-24.512 11.968a294.113 294.113 0 0 0-34.816 20.096l-22.656 15.36-116.224-25.088-65.28 113.152 79.68 88.192-1.92 27.136a293.12 293.12 0 0 0 0 40.192l1.92 27.136-79.808 88.192 65.344 113.152 116.224-25.024 22.656 15.296a294.113 294.113 0 0 0 34.816 20.096l24.512 11.968L446.72 896h130.688l36.48-113.152 24.448-11.904a288.282 288.282 0 0 0 34.752-20.096l22.592-15.296 116.288 25.024 65.28-113.152-79.744-88.192 1.92-27.136a293.12 293.12 0 0 0 0-40.256l-1.92-27.136 79.808-88.128-65.344-113.152-116.288 24.96-22.592-15.232a287.616 287.616 0 0 0-34.752-20.096l-24.448-11.904L577.344 128zM512 320a192 192 0 1 1 0 384 192 192 0 0 1 0-384m0 64a128 128 0 1 0 0 256 128 128 0 0 0 0-256"
        })
      ]));
    }
  });

  // src/components/setting.vue
  var setting_default = setting_vue_vue_type_script_setup_true_lang_default;
  var user_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "User",
    __name: "user",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M512 512a192 192 0 1 0 0-384 192 192 0 0 0 0 384m0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512m320 320v-96a96 96 0 0 0-96-96H288a96 96 0 0 0-96 96v96a32 32 0 1 1-64 0v-96a160 160 0 0 1 160-160h448a160 160 0 0 1 160 160v96a32 32 0 1 1-64 0"
        })
      ]));
    }
  });

  // src/components/user.vue
  var user_default = user_vue_vue_type_script_setup_true_lang_default;

  const _hoisted_1$f = { class: "plus-table-action-bar__dropdown__link" };
  var _sfc_main$r = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusTableActionBar"
    },
    __name: "table-action-bar",
    props: {
      label: { type: String, required: false, default: "" },
      fixed: { type: String, required: false, default: "right" },
      showNumber: { type: Number, required: false, default: 3 },
      type: { type: String, required: false, default: "link" },
      buttons: { type: Array, required: false, default: () => [] },
      width: { type: [String, Number], required: false, default: 200 },
      actionBarTableColumnProps: { type: Object, required: false, default: () => ({}) }
    },
    emits: ["clickAction", "clickActionConfirmCancel"],
    setup(__props, { emit }) {
      const props = __props;
      const { t } = useLocale();
      const getSubButtons = (row, index) => {
        const data = props.buttons.filter((item) => {
          if (isFunction(item.show)) {
            const tempFunction = item.show;
            const isShow = tempFunction(row, index, item);
            return vue.unref(isShow) !== false;
          }
          return vue.unref(item.show) !== false;
        });
        const preButtons = data.slice(0, props.showNumber);
        const nextButtons = data.slice(props.showNumber);
        const showMore = data.length > props.showNumber;
        return {
          showMore,
          preButtons,
          nextButtons
        };
      };
      const render = (row, buttonRow, index) => {
        if (props.type === "icon") {
          return vue.h(
            elementPlus.ElTooltip,
            { placement: "top", content: vue.unref(buttonRow.text), ...buttonRow.tooltipProps },
            () => vue.h(
              elementPlus.ElIcon,
              {
                size: 16,
                ...buttonRow.props,
                onClick: (event) => handleClickAction(row, buttonRow, index, event)
              },
              () => buttonRow.icon ? vue.h(buttonRow.icon) : ""
            )
          );
        } else {
          const Tag = props.type === "button" ? elementPlus.ElButton : elementPlus.ElLink;
          const defaultProps = props.type === "link" ? { href: "javaScript:;" } : {};
          return vue.h(
            Tag,
            {
              size: "small",
              ...defaultProps,
              ...buttonRow.props,
              onClick: (event) => handleClickAction(row, buttonRow, index, event)
            },
            () => vue.unref(buttonRow.text)
          );
        }
      };
      const handleClickAction = (row, buttonRow, index, e) => {
        var _a, _b;
        const data = { row, buttonRow, index, e };
        if (buttonRow.confirm) {
          const message = t("plus.table.confirmToPerformThisOperation");
          let title = t("plus.table.prompt");
          let options = void 0;
          let appContext = null;
          if (isPlainObject(buttonRow.confirm) && typeof buttonRow.confirm !== "boolean") {
            const tempTitle = isFunction(buttonRow.confirm.title) ? buttonRow.confirm.title(data) : buttonRow.confirm.title;
            if (tempTitle) {
              title = tempTitle;
            }
            const tempMessage = isFunction(buttonRow.confirm.message) ? buttonRow.confirm.message(data) : buttonRow.confirm.message;
            if (tempMessage) {
              title = tempMessage;
            }
            options = (_a = buttonRow.confirm) == null ? void 0 : _a.options;
            appContext = (_b = buttonRow.confirm) == null ? void 0 : _b.appContext;
          }
          elementPlus.ElMessageBox.confirm(message, title, options, appContext).then(() => {
            emit("clickAction", data);
          }).catch(() => {
            emit("clickActionConfirmCancel", data);
          });
        } else {
          emit("clickAction", data);
        }
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElTableColumn), vue.mergeProps({
          key: "actionBar",
          "class-name": "plus-table-action-bar",
          align: "center",
          label: _ctx.label || vue.unref(t)("plus.table.action"),
          fixed: _ctx.fixed || "right",
          width: _ctx.width || 200
        }, props.actionBarTableColumnProps), {
          default: vue.withCtx(({ row, $index }) => [
            vue.createCommentVNode(" \u663E\u793A\u51FA\u6765\u7684\u6309\u94AE "),
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(getSubButtons(row, $index).preButtons, (buttonRow) => {
                return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(() => render(row, buttonRow, $index)), {
                  key: buttonRow.text
                });
              }),
              128
              /* KEYED_FRAGMENT */
            )),
            vue.createCommentVNode(" \u9690\u85CF\u7684\u6309\u94AE "),
            getSubButtons(row, $index).showMore ? (vue.openBlock(), vue.createBlock(
              vue.unref(elementPlus.ElDropdown),
              {
                key: 0,
                trigger: "click",
                class: "plus-table-action-bar__dropdown"
              },
              {
                dropdown: vue.withCtx(() => [
                  vue.createVNode(
                    vue.unref(elementPlus.ElDropdownMenu),
                    null,
                    {
                      default: vue.withCtx(() => [
                        (vue.openBlock(true), vue.createElementBlock(
                          vue.Fragment,
                          null,
                          vue.renderList(getSubButtons(row, $index).nextButtons, (buttonRow) => {
                            return vue.openBlock(), vue.createBlock(
                              vue.unref(elementPlus.ElDropdownItem),
                              {
                                key: vue.unref(buttonRow.text)
                              },
                              {
                                default: vue.withCtx(() => [
                                  (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(() => render(row, buttonRow, $index))))
                                ]),
                                _: 2
                                /* DYNAMIC */
                              },
                              1024
                              /* DYNAMIC_SLOTS */
                            );
                          }),
                          128
                          /* KEYED_FRAGMENT */
                        ))
                      ]),
                      _: 2
                      /* DYNAMIC */
                    },
                    1024
                    /* DYNAMIC_SLOTS */
                  )
                ]),
                default: vue.withCtx(() => [
                  vue.createElementVNode("span", _hoisted_1$f, [
                    vue.createTextVNode(
                      vue.toDisplayString(vue.unref(t)("plus.table.more")) + " ",
                      1
                      /* TEXT */
                    ),
                    vue.createVNode(vue.unref(elementPlus.ElIcon), null, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(arrow_down_bold_default))
                      ]),
                      _: 1
                      /* STABLE */
                    })
                  ])
                ]),
                _: 2
                /* DYNAMIC */
              },
              1024
              /* DYNAMIC_SLOTS */
            )) : vue.createCommentVNode("v-if", true)
          ]),
          _: 1
          /* STABLE */
        }, 16, ["label", "fixed", "width"]);
      };
    }
  });

  var PlusTableActionBarComponent = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\table\\src\\table-action-bar.vue"]]);

  var _sfc_main$q = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusRadio"
    },
    __name: "index",
    props: {
      modelValue: { type: [String, Number, Boolean], required: false, default: "" },
      options: { type: Array, required: true, default: () => [] },
      isCancel: { type: Boolean, required: false, default: true }
    },
    emits: ["change", "update:modelValue"],
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      const radioInstance = vue.ref();
      const radioGroupInstance = vue.ref();
      const state = vue.reactive({ radio: "" });
      vue.watch(
        () => props.modelValue,
        (val) => {
          state.radio = val;
        },
        { immediate: true }
      );
      const attrs = vue.useAttrs();
      const radioClick = (e, val, fieldItemProps) => {
        if (Reflect.has(attrs, "disabled") || (fieldItemProps == null ? void 0 : fieldItemProps.disabled)) {
          return;
        }
        if (!props.isCancel) {
          return;
        } else {
          e.preventDefault();
        }
        state.radio === val ? state.radio = "" : state.radio = val;
        emit("update:modelValue", state.radio);
        emit("change", state.radio);
      };
      const change = (val) => {
        if (props.isCancel)
          return;
        emit("update:modelValue", val);
        emit("change", val);
      };
      __expose({
        radioInstance,
        radioGroupInstance
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElRadioGroup), vue.mergeProps({
          ref_key: "radioGroupInstance",
          ref: radioGroupInstance,
          modelValue: state.radio,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.radio = $event)
        }, _ctx.$attrs), {
          default: vue.withCtx(() => [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(_ctx.options, (item) => {
                return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElRadio), vue.mergeProps({
                  key: item.value,
                  ref_for: true,
                  ref_key: "radioInstance",
                  ref: radioInstance,
                  label: item.value
                }, item.fieldItemProps, {
                  onClick: ($event) => radioClick($event, item.value, item.fieldItemProps),
                  onChange: ($event) => change(item.value)
                }), {
                  default: vue.withCtx(() => [
                    vue.createTextVNode(
                      vue.toDisplayString(item.label),
                      1
                      /* TEXT */
                    )
                  ]),
                  _: 2
                  /* DYNAMIC */
                }, 1040, ["label", "onClick", "onChange"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        }, 16, ["modelValue"]);
      };
    }
  });

  var Radio = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\radio\\src\\index.vue"]]);

  const PlusRadio = Radio;

  const _hoisted_1$e = { class: "plus-date-picker__middle" };
  var _sfc_main$p = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusDatePicker"
    },
    __name: "index",
    props: {
      modelValue: { type: Array, required: false, default: () => [] },
      format: { type: String, required: false, default: "YYYY-MM-DD HH:mm:ss" },
      valueFormat: { type: String, required: false, default: "YYYY-MM-DD HH:mm:ss" },
      rangeSeparator: { type: String, required: false, default: "/" },
      type: { type: String, required: false, default: "datetime" },
      startProps: { type: null, required: false, default: () => ({}) },
      endProps: { type: null, required: false, default: () => ({}) },
      startDisabledDate: { type: Function, required: false, default: (startTime, endValue) => {
        if (!endValue)
          return false;
        return startTime.getTime() > new Date(endValue).getTime();
      } },
      endDisabledDate: { type: Function, required: false, default: (endTime, startValue) => {
        if (!startValue)
          return false;
        return endTime.getTime() < new Date(startValue).getTime();
      } }
    },
    emits: ["change", "focus", "update:modelValue"],
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      const { t } = useLocale();
      const startPickerInstance = vue.ref();
      const endPickerInstance = vue.ref();
      const state = vue.reactive({
        start: "",
        end: ""
      });
      const isFocus = vue.ref(false);
      const handleFocus = (event) => {
        isFocus.value = true;
        emit("focus", event);
      };
      const onClickOutside = () => {
        isFocus.value = false;
      };
      const subStartDisabledDate = (time) => {
        if (props.startDisabledDate && isFunction(props.startDisabledDate)) {
          return props.startDisabledDate(time, state.end);
        }
        return false;
      };
      const subEndDisabledDate = (time) => {
        if (props.endDisabledDate && isFunction(props.endDisabledDate)) {
          return props.endDisabledDate(time, state.start);
        }
        return false;
      };
      vue.watch(
        () => props.modelValue,
        (val) => {
          const [start, end] = val;
          state.start = start;
          state.end = end;
        },
        {
          immediate: true
        }
      );
      const handleChange = () => {
        const res = [state.start, state.end];
        emit("update:modelValue", res);
        emit("change", res);
      };
      __expose({
        startPickerInstance,
        endPickerInstance
      });
      return (_ctx, _cache) => {
        return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(["plus-date-picker", {
              "is-focus": isFocus.value
            }])
          },
          [
            vue.createVNode(vue.unref(elementPlus.ElDatePicker), vue.mergeProps({
              ref_key: "startPickerInstance",
              ref: startPickerInstance,
              modelValue: state.start,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.start = $event),
              type: "datetime",
              placeholder: vue.unref(t)("plus.datepicker.startPlaceholder"),
              format: _ctx.format,
              "value-format": _ctx.valueFormat,
              "disabled-date": subStartDisabledDate,
              class: "plus-date-picker__start",
              clearable: ""
            }, _ctx.startProps, {
              onChange: handleChange,
              onFocus: handleFocus
            }), null, 16, ["modelValue", "placeholder", "format", "value-format"]),
            vue.createElementVNode(
              "span",
              _hoisted_1$e,
              vue.toDisplayString(_ctx.rangeSeparator),
              1
              /* TEXT */
            ),
            vue.createVNode(vue.unref(elementPlus.ElDatePicker), vue.mergeProps({
              ref_key: "endPickerInstance",
              ref: endPickerInstance,
              modelValue: state.end,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => state.end = $event),
              type: "datetime",
              format: _ctx.format,
              "value-format": _ctx.valueFormat,
              placeholder: vue.unref(t)("plus.datepicker.endPlaceholder"),
              "disabled-date": subEndDisabledDate,
              class: "plus-date-picker__end",
              clearable: ""
            }, _ctx.endProps, {
              onChange: handleChange,
              onFocus: handleFocus
            }), null, 16, ["modelValue", "format", "value-format", "placeholder"])
          ],
          2
          /* CLASS */
        )), [
          [vue.unref(elementPlus.ClickOutside), onClickOutside]
        ]);
      };
    }
  });

  var DatePicker = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\date-picker\\src\\index.vue"]]);

  const PlusDatePicker = DatePicker;

  var _sfc_main$o = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusInputTag"
    },
    __name: "index",
    props: {
      modelValue: { type: Array, required: false, default: () => [] },
      trigger: { type: [Array, String], required: false, default: () => ["blur", "enter", "space"] },
      inputProps: { type: Object, required: false, default: () => ({}) },
      tagProps: { type: Object, required: false, default: () => ({}) },
      limit: { type: Number, required: false, default: Infinity }
    },
    emits: ["update:modelValue", "change"],
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      const inputInstance = vue.ref();
      const tagInstance = vue.ref();
      const plusInputTagInstance = vue.ref();
      const state = vue.reactive({
        tags: [],
        inputValue: "",
        isFocus: false
      });
      const { t } = useLocale();
      vue.watch(
        () => props.modelValue,
        (val) => {
          state.tags = val.slice(0, props.limit);
        },
        { immediate: true }
      );
      const onClickOutside = () => {
        state.isFocus = false;
      };
      const handleClick = () => {
        var _a;
        state.isFocus = true;
        (_a = inputInstance.value) == null ? void 0 : _a.focus();
      };
      const handleClose = (tag) => {
        state.tags = state.tags.filter((item) => item !== tag);
      };
      const handleValue = () => {
        if (state.inputValue.trim() && !state.tags.includes(state.inputValue.trim()) && state.tags.length < props.limit) {
          state.tags.push(state.inputValue.trim());
        }
        state.inputValue = "";
        emit("update:modelValue", state.tags);
        emit("change", state.tags);
      };
      const handle = (type) => {
        const triggerList = isArray(props.trigger) ? props.trigger : isString(props.trigger) ? [props.trigger] : ["blur", "enter", "space"];
        if (triggerList.includes(type)) {
          handleValue();
        }
      };
      __expose({ inputInstance, tagInstance });
      return (_ctx, _cache) => {
        return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
          "div",
          {
            ref_key: "plusInputTagInstance",
            ref: plusInputTagInstance,
            class: vue.normalizeClass(["plus-input-tag", {
              "is-focus": state.isFocus
            }]),
            onClick: handleClick
          },
          [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(state.tags, (tag) => {
                return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElTag), vue.mergeProps({
                  ref_for: true,
                  ref_key: "tagInstance",
                  ref: tagInstance,
                  key: tag,
                  class: "plus-input-tag__tag"
                }, _ctx.tagProps, {
                  closable: "",
                  onClose: ($event) => handleClose(tag)
                }), {
                  default: vue.withCtx(() => [
                    vue.createTextVNode(
                      vue.toDisplayString(tag),
                      1
                      /* TEXT */
                    )
                  ]),
                  _: 2
                  /* DYNAMIC */
                }, 1040, ["onClose"]);
              }),
              128
              /* KEYED_FRAGMENT */
            )),
            vue.createVNode(vue.unref(elementPlus.ElInput), vue.mergeProps({
              ref_key: "inputInstance",
              ref: inputInstance,
              modelValue: state.inputValue,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.inputValue = $event),
              class: "plus-input-tag__input",
              placeholder: vue.unref(t)("plus.inputTag.placeholder"),
              disabled: state.tags.length >= _ctx.limit
            }, _ctx.inputProps, {
              clearable: "",
              onBlur: _cache[1] || (_cache[1] = ($event) => handle("blur")),
              onKeyup: [
                _cache[2] || (_cache[2] = vue.withKeys(vue.withModifiers(($event) => handle("enter"), ["exact"]), ["enter"])),
                _cache[3] || (_cache[3] = vue.withKeys(vue.withModifiers(($event) => handle("space"), ["exact"]), ["space"]))
              ]
            }), null, 16, ["modelValue", "placeholder", "disabled"])
          ],
          2
          /* CLASS */
        )), [
          [vue.unref(elementPlus.ClickOutside), onClickOutside]
        ]);
      };
    }
  });

  var InputTag = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\input-tag\\src\\index.vue"]]);

  const PlusInputTag = InputTag;

  var _sfc_main$n = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusRender"
    },
    __name: "index",
    props: {
      renderType: { type: String, required: false, default: void 0 },
      callbackValue: { type: null, required: false, default: "" },
      customFieldProps: { type: null, required: false, default: () => ({}) },
      render: { type: Function, required: false, skipCheck: true },
      params: { type: Object, required: false, default: () => ({}) },
      handleChange: { type: Function, required: false }
    },
    setup(__props) {
      const props = __props;
      const state = vue.ref();
      vue.watch(
        () => props.callbackValue,
        (val) => {
          state.value = val;
        },
        {
          flush: "post",
          immediate: true
        }
      );
      const renderComponent = () => {
        if (!props.render)
          return;
        const value = state.value;
        const params = { ...props.params };
        const dynamicComponent = props.renderType === "form" ? props.render(
          value,
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          props.handleChange,
          params
        ) : props.render(value, params);
        if (vue.isVNode(dynamicComponent)) {
          const payload = props.renderType === "form" ? {
            ...props.customFieldProps,
            ...dynamicComponent.props,
            modelValue: state.value
          } : {
            ...props.customFieldProps,
            ...dynamicComponent.props
          };
          return {
            ...dynamicComponent,
            props: payload
          };
        } else if (isString(dynamicComponent)) {
          return dynamicComponent;
        }
      };
      return (_ctx, _cache) => {
        return _ctx.renderType === "form" ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(renderComponent), vue.mergeProps({
          key: 0,
          modelValue: state.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.value = $event)
        }, _ctx.customFieldProps), null, 16, ["modelValue"])) : (vue.openBlock(), vue.createBlock(
          vue.resolveDynamicComponent(renderComponent),
          vue.normalizeProps(vue.mergeProps({ key: 1 }, _ctx.customFieldProps)),
          null,
          16
          /* FULL_PROPS */
        ));
      };
    }
  });

  var Render = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\render\\src\\index.vue"]]);

  const PlusRender = Render;

  const _hoisted_1$d = { class: "plus-form-item__label" };
  var _sfc_main$m = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusFormItem"
    },
    __name: "index",
    props: {
      modelValue: { type: null, required: false, default: "" },
      hasLabel: { type: null, required: false, default: true },
      label: { type: null, required: true },
      prop: { type: null, required: true },
      fieldProps: { type: null, required: false, default: () => ({}) },
      valueType: { type: null, required: false },
      options: { type: null, required: false, default: () => [] },
      formItemProps: { type: null, required: false, default: () => ({}) },
      renderField: { type: null, required: false },
      renderLabel: { type: null, required: false },
      tooltip: { type: null, required: false, default: "" },
      fieldSlots: { type: null, required: false, default: () => ({}) },
      index: { type: Number, required: false, default: 0 }
    },
    emits: ["update:modelValue", "change"],
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      const ElFormItem = elementPlus.ElFormItem;
      const ElTooltip = elementPlus.ElTooltip;
      const ElIcon = elementPlus.ElIcon;
      const ElAutocomplete = elementPlus.ElAutocomplete;
      const ElCascader = elementPlus.ElCascader;
      const ElCheckbox = elementPlus.ElCheckbox;
      const ElCheckboxGroup = elementPlus.ElCheckboxGroup;
      const ElColorPicker = elementPlus.ElColorPicker;
      const ElDatePicker = elementPlus.ElDatePicker;
      const ElInputNumber = elementPlus.ElInputNumber;
      const ElRadioGroup = elementPlus.ElRadioGroup;
      const ElRadio = elementPlus.ElRadio;
      const ElRate = elementPlus.ElRate;
      const ElSelect = elementPlus.ElSelect;
      const ElOption = elementPlus.ElOption;
      const ElSlider = elementPlus.ElSlider;
      const ElSwitch = elementPlus.ElSwitch;
      const ElTimePicker = elementPlus.ElTimePicker;
      const ElTimeSelect = elementPlus.ElTimeSelect;
      const ElInput = elementPlus.ElInput;
      const { t } = useLocale();
      const options = useGetOptions(props);
      const formItemInstance = vue.ref();
      const fieldInstance = vue.ref();
      const customFormItemProps = vue.ref({});
      const customFieldProps = vue.ref({});
      const state = vue.ref();
      const range = ["datetimerange", "daterange", "monthrange"];
      const numberList = ["rate", "input-number", "slider"];
      const arrayList = ["checkbox", "plus-date-picker", "plus-input-tag"];
      const customFieldPropsIsReady = vue.ref(false);
      const isArrayValue = vue.computed(() => {
        var _a, _b, _c, _d;
        if (arrayList.includes(props.valueType)) {
          return true;
        }
        if (props.valueType === "select" && ((_a = customFieldProps.value) == null ? void 0 : _a.multiple) === true) {
          return true;
        }
        if (props.valueType === "date-picker" && range.includes((_b = customFieldProps.value) == null ? void 0 : _b.type)) {
          return true;
        }
        if (props.valueType === "time-picker" && ((_c = customFieldProps.value) == null ? void 0 : _c.isRange) === true) {
          return true;
        }
        if (props.valueType === "cascader" && ((_d = customFieldProps.value) == null ? void 0 : _d.multiple)) {
          return true;
        }
        return false;
      });
      const isNumberValue = vue.computed(() => {
        if (numberList.includes(props.valueType)) {
          return true;
        }
        return false;
      });
      const setValue = (val) => {
        if (isArrayValue.value) {
          if (isArray(val)) {
            const [start, end] = val;
            if (isDate(start) || isDate(end)) {
              state.value = [String(start), String(end)];
            } else {
              state.value = val;
            }
          } else {
            state.value = [];
          }
        } else if (isNumberValue.value) {
          state.value = Number(val);
        } else if (props.valueType === "switch") {
          state.value = Boolean(val);
        } else if (isDate(val)) {
          state.value = String(val);
        } else {
          state.value = val;
        }
      };
      vue.watch(
        () => props.formItemProps,
        (val) => {
          getCustomProps(val, state.value, props, props.index, "formItemProps").then((data) => {
            customFormItemProps.value = data;
          }).catch((err) => {
            throw err;
          });
        },
        {
          immediate: true,
          deep: true
        }
      );
      vue.watch(
        () => props.fieldProps,
        (val) => {
          getCustomProps(val, state.value, props, props.index, "fieldProps").then((data) => {
            customFieldProps.value = data;
            customFieldPropsIsReady.value = true;
          }).catch((err) => {
            throw err;
          });
        },
        {
          immediate: true,
          deep: true
        }
      );
      vue.watch(
        () => props.modelValue,
        (val) => {
          setValue(val);
        },
        {
          flush: "post",
          immediate: true
        }
      );
      const handleChange = (val) => {
        emit("update:modelValue", val);
        emit("change", val);
      };
      const handleSelect = ({ value }) => {
        handleChange(value);
      };
      __expose({
        formItemInstance,
        fieldInstance
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(ElFormItem), vue.mergeProps({
          ref_key: "formItemInstance",
          ref: formItemInstance,
          label: _ctx.hasLabel ? _ctx.label : "",
          prop: _ctx.prop,
          class: "plus-form-item"
        }, customFormItemProps.value), vue.createSlots({
          default: vue.withCtx(() => [
            _ctx.renderField && vue.unref(isFunction)(_ctx.renderField) ? (vue.openBlock(), vue.createBlock(vue.unref(PlusRender), {
              key: 0,
              render: _ctx.renderField,
              params: props,
              "callback-value": state.value,
              "custom-field-props": customFieldProps.value,
              "render-type": "form",
              "handle-change": handleChange
            }, null, 8, ["render", "callback-value", "custom-field-props"])) : _ctx.$slots[vue.unref(getFieldSlotName)(_ctx.prop)] ? vue.renderSlot(_ctx.$slots, vue.unref(getFieldSlotName)(_ctx.prop), {
              key: 1,
              prop: _ctx.prop,
              label: _ctx.label,
              fieldProps: customFieldProps.value,
              valueType: _ctx.valueType,
              column: props
            }) : _ctx.valueType === "autocomplete" ? (vue.openBlock(), vue.createBlock(vue.unref(ElAutocomplete), vue.mergeProps({
              key: 2,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.value = $event),
              placeholder: vue.unref(t)("plus.field.pleaseEnter") + _ctx.label,
              class: "plus-form-item-field",
              clearable: ""
            }, customFieldProps.value, {
              onChange: handleChange,
              onSelect: handleSelect
            }), vue.createSlots({
              _: 2
              /* DYNAMIC */
            }, [
              vue.renderList(_ctx.fieldSlots, (fieldSlot, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    (vue.openBlock(), vue.createBlock(
                      vue.resolveDynamicComponent(fieldSlot),
                      vue.normalizeProps(vue.guardReactiveProps(data)),
                      null,
                      16
                      /* FULL_PROPS */
                    ))
                  ])
                };
              })
            ]), 1040, ["modelValue", "placeholder"])) : _ctx.valueType === "cascader" ? (vue.openBlock(), vue.createBlock(vue.unref(ElCascader), vue.mergeProps({
              key: 3,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => state.value = $event),
              placeholder: vue.unref(t)("plus.field.pleaseSelect") + _ctx.label,
              class: "plus-form-item-field",
              options: vue.unref(options),
              clearable: ""
            }, customFieldProps.value, { onChange: handleChange }), vue.createSlots({
              _: 2
              /* DYNAMIC */
            }, [
              vue.renderList(_ctx.fieldSlots, (fieldSlot, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    (vue.openBlock(), vue.createBlock(
                      vue.resolveDynamicComponent(fieldSlot),
                      vue.normalizeProps(vue.guardReactiveProps(data)),
                      null,
                      16
                      /* FULL_PROPS */
                    ))
                  ])
                };
              })
            ]), 1040, ["modelValue", "placeholder", "options"])) : _ctx.valueType === "checkbox" ? (vue.openBlock(), vue.createBlock(vue.unref(ElCheckboxGroup), vue.mergeProps({
              key: 4,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => state.value = $event),
              placeholder: vue.unref(t)("plus.field.pleaseSelect") + _ctx.label,
              class: "plus-form-item-field"
            }, customFieldProps.value, { onChange: handleChange }), vue.createSlots({
              default: vue.withCtx(() => [
                (vue.openBlock(true), vue.createElementBlock(
                  vue.Fragment,
                  null,
                  vue.renderList(vue.unref(options), (item) => {
                    return vue.openBlock(), vue.createBlock(vue.unref(ElCheckbox), vue.mergeProps({
                      key: item.label,
                      label: item.value
                    }, item.fieldItemProps), {
                      default: vue.withCtx(() => [
                        vue.createTextVNode(
                          vue.toDisplayString(item.label),
                          1
                          /* TEXT */
                        )
                      ]),
                      _: 2
                      /* DYNAMIC */
                    }, 1040, ["label"]);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ]),
              _: 2
              /* DYNAMIC */
            }, [
              vue.renderList(_ctx.fieldSlots, (fieldSlot, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    (vue.openBlock(), vue.createBlock(
                      vue.resolveDynamicComponent(fieldSlot),
                      vue.normalizeProps(vue.guardReactiveProps(data)),
                      null,
                      16
                      /* FULL_PROPS */
                    ))
                  ])
                };
              })
            ]), 1040, ["modelValue", "placeholder"])) : _ctx.valueType === "color-picker" ? (vue.openBlock(), vue.createBlock(vue.unref(ElColorPicker), vue.mergeProps({
              key: 5,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => state.value = $event),
              placeholder: vue.unref(t)("plus.field.pleaseSelect") + _ctx.label,
              class: "plus-form-item-field"
            }, customFieldProps.value, { onChange: handleChange }), null, 16, ["modelValue", "placeholder"])) : _ctx.valueType === "date-picker" ? (vue.openBlock(), vue.createBlock(vue.unref(ElDatePicker), vue.mergeProps({
              key: 6,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => state.value = $event),
              placeholder: vue.unref(t)("plus.field.pleaseSelect") + _ctx.label,
              "start-placeholder": vue.unref(t)("plus.datepicker.startPlaceholder"),
              "end-placeholder": vue.unref(t)("plus.datepicker.endPlaceholder"),
              class: "plus-form-item-field",
              format: "YYYY-MM-DD HH:mm:ss",
              type: "datetime",
              "value-format": "YYYY-MM-DD HH:mm:ss",
              clearable: ""
            }, customFieldProps.value, { onChange: handleChange }), vue.createSlots({
              _: 2
              /* DYNAMIC */
            }, [
              vue.renderList(_ctx.fieldSlots, (fieldSlot, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    (vue.openBlock(), vue.createBlock(
                      vue.resolveDynamicComponent(fieldSlot),
                      vue.normalizeProps(vue.guardReactiveProps(data)),
                      null,
                      16
                      /* FULL_PROPS */
                    ))
                  ])
                };
              })
            ]), 1040, ["modelValue", "placeholder", "start-placeholder", "end-placeholder"])) : _ctx.valueType === "plus-date-picker" ? (vue.openBlock(), vue.createBlock(vue.unref(PlusDatePicker), vue.mergeProps({
              key: 7,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => state.value = $event),
              class: "plus-form-item-field"
            }, customFieldProps.value, { onChange: handleChange }), null, 16, ["modelValue"])) : _ctx.valueType === "input-number" ? (vue.openBlock(), vue.createBlock(vue.unref(ElInputNumber), vue.mergeProps({
              key: 8,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => state.value = $event),
              class: "plus-form-item-field",
              placeholder: vue.unref(t)("plus.field.pleaseEnter") + _ctx.label,
              autocomplete: "off"
            }, customFieldProps.value, { onChange: handleChange }), null, 16, ["modelValue", "placeholder"])) : _ctx.valueType === "plus-input-tag" ? (vue.openBlock(), vue.createBlock(vue.unref(PlusInputTag), vue.mergeProps({
              key: 9,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => state.value = $event),
              class: "plus-form-item-field"
            }, customFieldProps.value, { onChange: handleChange }), null, 16, ["modelValue"])) : _ctx.valueType === "radio" ? (vue.openBlock(), vue.createBlock(vue.unref(ElRadioGroup), vue.mergeProps({
              key: 10,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => state.value = $event),
              placeholder: vue.unref(t)("plus.field.pleaseSelect") + _ctx.label,
              class: "plus-form-item-field",
              clearable: ""
            }, customFieldProps.value, { onChange: handleChange }), vue.createSlots({
              default: vue.withCtx(() => [
                (vue.openBlock(true), vue.createElementBlock(
                  vue.Fragment,
                  null,
                  vue.renderList(vue.unref(options), (item) => {
                    return vue.openBlock(), vue.createBlock(vue.unref(ElRadio), vue.mergeProps({
                      key: item.label,
                      label: item.value
                    }, item.fieldItemProps), {
                      default: vue.withCtx(() => [
                        vue.createTextVNode(
                          vue.toDisplayString(item.label),
                          1
                          /* TEXT */
                        )
                      ]),
                      _: 2
                      /* DYNAMIC */
                    }, 1040, ["label"]);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ]),
              _: 2
              /* DYNAMIC */
            }, [
              vue.renderList(_ctx.fieldSlots, (fieldSlot, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    (vue.openBlock(), vue.createBlock(
                      vue.resolveDynamicComponent(fieldSlot),
                      vue.normalizeProps(vue.guardReactiveProps(data)),
                      null,
                      16
                      /* FULL_PROPS */
                    ))
                  ])
                };
              })
            ]), 1040, ["modelValue", "placeholder"])) : _ctx.valueType === "plus-radio" ? (vue.openBlock(), vue.createBlock(vue.unref(PlusRadio), vue.mergeProps({
              key: 11,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => state.value = $event),
              class: "plus-form-item-field",
              options: vue.unref(options),
              "is-cancel": ""
            }, customFieldProps.value, { onChange: handleChange }), null, 16, ["modelValue", "options"])) : _ctx.valueType === "rate" ? (vue.openBlock(), vue.createBlock(vue.unref(ElRate), vue.mergeProps({
              key: 12,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => state.value = $event),
              class: "plus-form-item-field"
            }, customFieldProps.value, { onChange: handleChange }), null, 16, ["modelValue"])) : _ctx.valueType === "select" && customFieldPropsIsReady.value ? (vue.openBlock(), vue.createBlock(vue.unref(ElSelect), vue.mergeProps({
              key: 13,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => state.value = $event),
              placeholder: vue.unref(t)("plus.field.pleaseSelect") + _ctx.label,
              class: "plus-form-item-field",
              clearable: ""
            }, customFieldProps.value, { onChange: handleChange }), vue.createSlots({
              default: vue.withCtx(() => [
                (vue.openBlock(true), vue.createElementBlock(
                  vue.Fragment,
                  null,
                  vue.renderList(vue.unref(options), (item) => {
                    return vue.openBlock(), vue.createBlock(vue.unref(ElOption), vue.mergeProps({
                      key: item.label,
                      label: item.label,
                      value: item.value
                    }, item.fieldItemProps), null, 16, ["label", "value"]);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ]),
              _: 2
              /* DYNAMIC */
            }, [
              vue.renderList(_ctx.fieldSlots, (fieldSlot, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    (vue.openBlock(), vue.createBlock(
                      vue.resolveDynamicComponent(fieldSlot),
                      vue.normalizeProps(vue.guardReactiveProps(data)),
                      null,
                      16
                      /* FULL_PROPS */
                    ))
                  ])
                };
              })
            ]), 1040, ["modelValue", "placeholder"])) : _ctx.valueType === "slider" ? (vue.openBlock(), vue.createBlock(vue.unref(ElSlider), vue.mergeProps({
              key: 14,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => state.value = $event),
              class: "plus-form-item-field"
            }, customFieldProps.value, { onChange: handleChange }), null, 16, ["modelValue"])) : _ctx.valueType === "switch" ? (vue.openBlock(), vue.createBlock(vue.unref(ElSwitch), vue.mergeProps({
              key: 15,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => state.value = $event),
              class: "plus-form-item-field"
            }, customFieldProps.value, { onChange: handleChange }), vue.createSlots({
              _: 2
              /* DYNAMIC */
            }, [
              vue.renderList(_ctx.fieldSlots, (fieldSlot, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    (vue.openBlock(), vue.createBlock(
                      vue.resolveDynamicComponent(fieldSlot),
                      vue.normalizeProps(vue.guardReactiveProps(data)),
                      null,
                      16
                      /* FULL_PROPS */
                    ))
                  ])
                };
              })
            ]), 1040, ["modelValue"])) : _ctx.valueType === "time-picker" ? (vue.openBlock(), vue.createBlock(vue.unref(ElTimePicker), vue.mergeProps({
              key: 16,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => state.value = $event),
              placeholder: vue.unref(t)("plus.field.pleaseSelect") + _ctx.label,
              class: "plus-form-item-field",
              clearable: "",
              "value-format": "YYYY-MM-DD HH:mm:ss"
            }, customFieldProps.value, { onChange: handleChange }), null, 16, ["modelValue", "placeholder"])) : _ctx.valueType === "time-select" ? (vue.openBlock(), vue.createBlock(vue.unref(ElTimeSelect), vue.mergeProps({
              key: 17,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => state.value = $event),
              class: "plus-form-item-field",
              placeholder: vue.unref(t)("plus.field.pleaseSelect") + _ctx.label,
              clearable: ""
            }, customFieldProps.value, { onChange: handleChange }), null, 16, ["modelValue", "placeholder"])) : _ctx.valueType === "textarea" ? (vue.openBlock(), vue.createBlock(vue.unref(ElInput), vue.mergeProps({
              key: 18,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => state.value = $event),
              type: "textarea",
              class: "plus-form-item-field",
              placeholder: vue.unref(t)("plus.field.pleaseEnter") + _ctx.label,
              autocomplete: "off"
            }, customFieldProps.value, { onChange: handleChange }), null, 16, ["modelValue", "placeholder"])) : _ctx.valueType === "text" ? (vue.openBlock(), vue.createElementBlock(
              "span",
              vue.mergeProps({
                key: 19,
                ref_key: "fieldInstance",
                ref: fieldInstance,
                class: "plus-form-item-field"
              }, customFieldProps.value),
              vue.toDisplayString(state.value),
              17
              /* TEXT, FULL_PROPS */
            )) : (vue.openBlock(), vue.createBlock(vue.unref(ElInput), vue.mergeProps({
              key: 20,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => state.value = $event),
              class: "plus-form-item-field",
              placeholder: vue.unref(t)("plus.field.pleaseEnter") + _ctx.label,
              autocomplete: "off",
              clearable: ""
            }, customFieldProps.value, { onChange: handleChange }), vue.createSlots({
              _: 2
              /* DYNAMIC */
            }, [
              vue.renderList(_ctx.fieldSlots, (fieldSlot, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    (vue.openBlock(), vue.createBlock(
                      vue.resolveDynamicComponent(fieldSlot),
                      vue.normalizeProps(vue.guardReactiveProps(data)),
                      null,
                      16
                      /* FULL_PROPS */
                    ))
                  ])
                };
              })
            ]), 1040, ["modelValue", "placeholder"]))
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          _ctx.hasLabel ? {
            name: "label",
            fn: vue.withCtx(({ label: currentLabel }) => [
              vue.createElementVNode("span", _hoisted_1$d, [
                _ctx.renderLabel && vue.unref(isFunction)(_ctx.renderLabel) ? (vue.openBlock(), vue.createBlock(vue.unref(PlusRender), {
                  key: 0,
                  render: _ctx.renderLabel,
                  params: props,
                  "callback-value": currentLabel,
                  "custom-field-props": customFieldProps.value
                }, null, 8, ["render", "callback-value", "custom-field-props"])) : vue.renderSlot(_ctx.$slots, vue.unref(getLabelSlotName)(_ctx.prop), {
                  key: 1,
                  prop: _ctx.prop,
                  label: _ctx.label,
                  fieldProps: customFieldProps.value,
                  valueType: _ctx.valueType,
                  column: props
                }, () => [
                  vue.createTextVNode(
                    vue.toDisplayString(currentLabel),
                    1
                    /* TEXT */
                  )
                ]),
                _ctx.tooltip ? (vue.openBlock(), vue.createBlock(
                  vue.unref(ElTooltip),
                  vue.mergeProps({
                    key: 2,
                    placement: "top"
                  }, vue.unref(getTooltip)(_ctx.tooltip)),
                  {
                    default: vue.withCtx(() => [
                      vue.createVNode(vue.unref(ElIcon), {
                        class: "plus-table-column__label__icon",
                        size: 16
                      }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(vue.unref(question_filled_default))
                        ]),
                        _: 1
                        /* STABLE */
                      })
                    ]),
                    _: 1
                    /* STABLE */
                  },
                  16
                  /* FULL_PROPS */
                )) : vue.createCommentVNode("v-if", true)
              ])
            ]),
            key: "0"
          } : void 0
        ]), 1040, ["label", "prop"]);
      };
    }
  });

  var FormItem = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\form-item\\src\\index.vue"]]);

  const PlusFormItem = FormItem;

  const _hoisted_1$c = {
    key: 0,
    class: "plus-form-item-extra"
  };
  var _sfc_main$l = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusFormContent"
    },
    __name: "form-content",
    props: {
      modelValue: { type: null, required: false, default: () => ({}) },
      hasLabel: { type: Boolean, required: false, default: true },
      columns: { type: Array, required: false, default: () => [] },
      rowProps: { type: Object, required: false, default: () => ({}) },
      colProps: { type: Object, required: false, default: () => ({}) }
    },
    emits: ["update:modelValue", "change"],
    setup(__props, { emit }) {
      const props = __props;
      const state = vue.reactive({ values: {} });
      const getHasLabel = (hasLabel) => {
        const has = vue.unref(hasLabel);
        if (typeof has === "boolean") {
          return has;
        }
        return props.hasLabel;
      };
      vue.watch(
        () => props.modelValue,
        (val) => {
          state.values = val;
        },
        {
          immediate: true
        }
      );
      const handleChange = (value, column) => {
        emit("change", state.values, column);
        emit("update:modelValue", state.values);
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(
          vue.unref(elementPlus.ElRow),
          vue.normalizeProps(vue.guardReactiveProps(_ctx.rowProps)),
          {
            default: vue.withCtx(() => [
              (vue.openBlock(true), vue.createElementBlock(
                vue.Fragment,
                null,
                vue.renderList(_ctx.columns, (item) => {
                  return vue.openBlock(), vue.createBlock(
                    vue.unref(elementPlus.ElCol),
                    vue.mergeProps({
                      key: item.prop
                    }, item.colProps || _ctx.colProps),
                    {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(PlusFormItem), vue.mergeProps({
                          modelValue: state.values[item.prop],
                          "onUpdate:modelValue": ($event) => state.values[item.prop] = $event
                        }, item, {
                          "has-label": getHasLabel(item.hasLabel),
                          "label-width": getHasLabel(item.hasLabel) ? item.labelWidth : "0px",
                          onChange: (value) => handleChange(value, item)
                        }), vue.createSlots({
                          _: 2
                          /* DYNAMIC */
                        }, [
                          _ctx.$slots[vue.unref(getLabelSlotName)(item.prop)] ? {
                            name: vue.unref(getLabelSlotName)(item.prop),
                            fn: vue.withCtx((data) => [
                              vue.renderSlot(_ctx.$slots, vue.unref(getLabelSlotName)(item.prop), vue.normalizeProps(vue.guardReactiveProps(data)))
                            ]),
                            key: "0"
                          } : void 0,
                          _ctx.$slots[vue.unref(getFieldSlotName)(item.prop)] ? {
                            name: vue.unref(getFieldSlotName)(item.prop),
                            fn: vue.withCtx((data) => [
                              vue.renderSlot(_ctx.$slots, vue.unref(getFieldSlotName)(item.prop), vue.normalizeProps(vue.guardReactiveProps(data)))
                            ]),
                            key: "1"
                          } : void 0
                        ]), 1040, ["modelValue", "onUpdate:modelValue", "has-label", "label-width", "onChange"]),
                        vue.createCommentVNode(" el-form-item \u4E0B\u4E00\u884C\u989D\u5916\u7684\u5185\u5BB9 "),
                        item.renderExtra || _ctx.$slots[vue.unref(getExtraSlotName)(item.prop)] ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$c, [
                          item.renderExtra && vue.unref(isFunction)(item.renderExtra) ? (vue.openBlock(), vue.createBlock(
                            vue.resolveDynamicComponent(item.renderExtra),
                            vue.normalizeProps(vue.mergeProps({ key: 0 }, item)),
                            null,
                            16
                            /* FULL_PROPS */
                          )) : _ctx.$slots[vue.unref(getExtraSlotName)(item.prop)] ? vue.renderSlot(_ctx.$slots, vue.unref(getExtraSlotName)(item.prop), vue.normalizeProps(vue.mergeProps({ key: 1 }, item))) : vue.createCommentVNode("v-if", true)
                        ])) : vue.createCommentVNode("v-if", true)
                      ]),
                      _: 2
                      /* DYNAMIC */
                    },
                    1040
                    /* FULL_PROPS, DYNAMIC_SLOTS */
                  );
                }),
                128
                /* KEYED_FRAGMENT */
              )),
              vue.createCommentVNode(" \u641C\u7D22\u7684footer\u63D2\u69FD  "),
              _ctx.$slots["search-footer"] ? (vue.openBlock(), vue.createBlock(
                vue.unref(elementPlus.ElCol),
                vue.normalizeProps(vue.mergeProps({ key: 0 }, _ctx.colProps)),
                {
                  default: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "search-footer")
                  ]),
                  _: 3
                  /* FORWARDED */
                },
                16
                /* FULL_PROPS */
              )) : vue.createCommentVNode("v-if", true)
            ]),
            _: 3
            /* FORWARDED */
          },
          16
          /* FULL_PROPS */
        );
      };
    }
  });

  var PlusFormContent = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\form\\src\\form-content.vue"]]);

  const _hoisted_1$b = { class: "plus-form__group__item__icon" };
  var _sfc_main$k = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusForm"
    },
    __name: "index",
    props: {
      modelValue: { type: null, required: false, default: () => ({}) },
      defaultValues: { type: null, required: false, default: () => ({}) },
      columns: { type: Array, required: false, default: () => [] },
      labelWidth: { type: String, required: false, default: "80px" },
      labelPosition: { type: String, required: false, default: "left" },
      rowProps: { type: Object, required: false, default: () => ({}) },
      colProps: { type: Object, required: false, default: () => ({}) },
      labelSuffix: { type: String, required: false, default: ":" },
      hasErrorTip: { type: Boolean, required: false, default: true },
      hasFooter: { type: Boolean, required: false, default: true },
      hasReset: { type: Boolean, required: false, default: true },
      hasLabel: { type: Boolean, required: false, default: true },
      submitText: { type: String, required: false, default: "" },
      resetText: { type: String, required: false, default: "" },
      submitLoading: { type: Boolean, required: false, default: false },
      footerAlign: { type: String, required: false, default: "left" },
      rules: { type: null, required: false, default: () => ({}) },
      group: { type: [Boolean, Array], required: false, default: false }
    },
    emits: ["update:modelValue", "submit", "change", "reset", "submitError"],
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      const { t } = useLocale();
      const formInstance = vue.ref();
      const state = vue.reactive({
        values: { ...props.modelValue },
        subColumns: []
      });
      const filterHide = (columns) => {
        return columns.filter((item) => vue.unref(item.hideInForm) !== true);
      };
      const model = vue.computed(() => state.values);
      const style = vue.computed(() => ({
        justifyContent: props.footerAlign === "left" ? "flex-start" : props.footerAlign === "center" ? "center" : "flex-end"
      }));
      state.subColumns = vue.computed(() => filterHide(props.columns));
      const slots = vue.useSlots();
      const labelSlots = filterSlots(slots, getLabelSlotName());
      const fieldSlots = filterSlots(slots, getFieldSlotName());
      const extraSlots = filterSlots(slots, getExtraSlotName());
      vue.watch(
        () => props.modelValue,
        (val) => {
          state.values = val;
        },
        {
          immediate: true
        }
      );
      const handleChange = (_, column) => {
        emit("change", state.values, column);
        emit("update:modelValue", state.values);
      };
      const clearValidate = () => {
        var _a;
        (_a = formInstance.value) == null ? void 0 : _a.clearValidate();
      };
      const handleSubmit = async () => {
        var _a, _b, _c;
        try {
          const valid = await ((_a = formInstance.value) == null ? void 0 : _a.validate());
          if (valid) {
            emit("submit", state.values);
            return true;
          }
        } catch (errors) {
          if (props.hasErrorTip) {
            elementPlus.ElMessage.closeAll();
            const values = Object.values(errors);
            elementPlus.ElMessage.warning(((_c = (_b = values[0]) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) || t("plus.form.errorTip"));
          }
          emit("submitError", errors);
        }
        return false;
      };
      const handleReset = () => {
        clearValidate();
        state.values = { ...props.defaultValues };
        emit("update:modelValue", state.values);
        emit("reset", state.values);
      };
      __expose({
        formInstance,
        handleSubmit,
        handleReset
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElForm), vue.mergeProps({
          ref_key: "formInstance",
          ref: formInstance,
          rules: _ctx.rules,
          "label-width": _ctx.hasLabel ? _ctx.labelWidth : 0,
          class: ["plus-form", _ctx.hasLabel ? "" : "no-has-label"],
          "label-position": _ctx.labelPosition,
          "validate-on-rule-change": false,
          "label-suffix": _ctx.hasLabel ? _ctx.labelSuffix : ""
        }, _ctx.$attrs, { model: model.value }), {
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "default", {}, () => [
              vue.createCommentVNode(" \u5206\u7EC4\u8868\u5355 "),
              _ctx.group ? (vue.openBlock(true), vue.createElementBlock(
                vue.Fragment,
                { key: 0 },
                vue.renderList(_ctx.group, (groupItem) => {
                  return vue.openBlock(), vue.createBlock(
                    vue.unref(elementPlus.ElCard),
                    {
                      key: groupItem.title,
                      class: "plus-form__group__item"
                    },
                    {
                      header: vue.withCtx(() => [
                        vue.renderSlot(_ctx.$slots, "group-header", {
                          title: groupItem.title,
                          columns: groupItem.columns,
                          icon: groupItem.icon
                        }, () => [
                          vue.createElementVNode("div", _hoisted_1$b, [
                            groupItem.icon ? (vue.openBlock(), vue.createBlock(
                              vue.unref(elementPlus.ElIcon),
                              { key: 0 },
                              {
                                default: vue.withCtx(() => [
                                  (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(groupItem.icon)))
                                ]),
                                _: 2
                                /* DYNAMIC */
                              },
                              1024
                              /* DYNAMIC_SLOTS */
                            )) : vue.createCommentVNode("v-if", true),
                            vue.createTextVNode(
                              " " + vue.toDisplayString(groupItem.title),
                              1
                              /* TEXT */
                            )
                          ])
                        ])
                      ]),
                      default: vue.withCtx(() => [
                        vue.createVNode(PlusFormContent, {
                          modelValue: state.values,
                          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.values = $event),
                          "row-props": _ctx.rowProps,
                          "col-props": _ctx.colProps,
                          columns: filterHide(groupItem.columns),
                          onChange: handleChange
                        }, vue.createSlots({
                          _: 2
                          /* DYNAMIC */
                        }, [
                          vue.renderList(vue.unref(labelSlots), (_, key) => {
                            return {
                              name: key,
                              fn: vue.withCtx((data) => [
                                vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                              ])
                            };
                          }),
                          vue.renderList(vue.unref(fieldSlots), (_, key) => {
                            return {
                              name: key,
                              fn: vue.withCtx((data) => [
                                vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                              ])
                            };
                          }),
                          vue.renderList(vue.unref(extraSlots), (_, key) => {
                            return {
                              name: key,
                              fn: vue.withCtx((data) => [
                                vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                              ])
                            };
                          })
                        ]), 1032, ["modelValue", "row-props", "col-props", "columns"])
                      ]),
                      _: 2
                      /* DYNAMIC */
                    },
                    1024
                    /* DYNAMIC_SLOTS */
                  );
                }),
                128
                /* KEYED_FRAGMENT */
              )) : (vue.openBlock(), vue.createElementBlock(
                vue.Fragment,
                { key: 1 },
                [
                  vue.createCommentVNode(" \u666E\u901A\u8868\u5355 "),
                  vue.createVNode(PlusFormContent, {
                    modelValue: state.values,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => state.values = $event),
                    "row-props": _ctx.rowProps,
                    "col-props": _ctx.colProps,
                    columns: state.subColumns,
                    "has-label": _ctx.hasLabel,
                    onChange: handleChange
                  }, vue.createSlots({
                    _: 2
                    /* DYNAMIC */
                  }, [
                    vue.renderList(vue.unref(labelSlots), (_, key) => {
                      return {
                        name: key,
                        fn: vue.withCtx((data) => [
                          vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                        ])
                      };
                    }),
                    vue.renderList(vue.unref(fieldSlots), (_, key) => {
                      return {
                        name: key,
                        fn: vue.withCtx((data) => [
                          vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                        ])
                      };
                    }),
                    vue.renderList(vue.unref(extraSlots), (_, key) => {
                      return {
                        name: key,
                        fn: vue.withCtx((data) => [
                          vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                        ])
                      };
                    }),
                    _ctx.$slots["search-footer"] ? {
                      name: "search-footer",
                      fn: vue.withCtx(() => [
                        vue.renderSlot(_ctx.$slots, "search-footer")
                      ]),
                      key: "0"
                    } : void 0
                  ]), 1032, ["modelValue", "row-props", "col-props", "columns", "has-label"])
                ],
                64
                /* STABLE_FRAGMENT */
              ))
            ]),
            _ctx.hasFooter ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: "plus-form__footer",
                style: vue.normalizeStyle(style.value)
              },
              [
                vue.renderSlot(_ctx.$slots, "footer", vue.normalizeProps(vue.guardReactiveProps({ handleReset, handleSubmit })), () => [
                  _ctx.hasReset ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElButton), {
                    key: 0,
                    onClick: handleReset
                  }, {
                    default: vue.withCtx(() => [
                      vue.createCommentVNode(" \u91CD\u7F6E "),
                      vue.createTextVNode(
                        " " + vue.toDisplayString(_ctx.resetText || vue.unref(t)("plus.form.resetText")),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 1
                    /* STABLE */
                  })) : vue.createCommentVNode("v-if", true),
                  vue.createVNode(vue.unref(elementPlus.ElButton), {
                    type: "primary",
                    loading: _ctx.submitLoading,
                    onClick: handleSubmit
                  }, {
                    default: vue.withCtx(() => [
                      vue.createCommentVNode(" \u63D0\u4EA4 "),
                      vue.createTextVNode(
                        " " + vue.toDisplayString(_ctx.submitText || vue.unref(t)("plus.form.submitText")),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 1
                    /* STABLE */
                  }, 8, ["loading"])
                ])
              ],
              4
              /* STYLE */
            )) : vue.createCommentVNode("v-if", true)
          ]),
          _: 3
          /* FORWARDED */
        }, 16, ["rules", "label-width", "class", "label-position", "label-suffix", "model"]);
      };
    }
  });

  var Form = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\form\\src\\index.vue"]]);

  const PlusForm = Form;

  const _hoisted_1$a = ["innerHTML"];
  const _hoisted_2$5 = { class: "plus-display-item" };
  var _sfc_main$j = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusDisplayItem"
    },
    __name: "index",
    props: {
      column: { type: null, required: true, default: () => ({ prop: "", label: "" }) },
      row: { type: null, required: true, default: () => ({}) },
      index: { type: Number, required: false, default: 0 }
    },
    emits: ["change"],
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      const isCellEdit = vue.ref(false);
      const isForm = vue.computed(() => props.column.editable === true || isCellEdit.value === true);
      const customFieldProps = vue.ref({});
      const formInstance = vue.ref();
      const options = useGetOptions(props.column);
      const columns = vue.ref([]);
      const subRow = vue.ref(props.row);
      const displayValue = vue.computed({
        get() {
          return getValue(subRow.value, props.column.prop);
        },
        set(value) {
          setValue(subRow.value, props.column.prop, value);
        }
      });
      const modelValues = vue.computed({
        get() {
          return { [props.column.prop]: displayValue.value };
        },
        set(values) {
          displayValue.value = values[props.column.prop];
        }
      });
      const params = vue.computed(() => ({
        row: subRow.value,
        column: props.column,
        index: props.index
      }));
      const imageUrl = vue.computed(() => {
        const option = displayValue.value;
        if (option && typeof option === "string") {
          return { options: [option], url: option };
        }
        if (isArray(option)) {
          return { options: option, url: option[0] };
        }
        return { options: [], url: "" };
      });
      const getStatus = vue.computed(() => {
        var _a, _b, _c, _d;
        let option = (_a = options.value) == null ? void 0 : _a.find((i) => i.value === displayValue.value);
        if (((_b = props.column) == null ? void 0 : _b.customGetStatus) && isFunction((_c = props.column) == null ? void 0 : _c.customGetStatus)) {
          option = (_d = props.column) == null ? void 0 : _d.customGetStatus({
            options: options.value,
            value: displayValue.value,
            row: subRow.value
          });
        }
        if (!option) {
          return { label: "", value: "" };
        }
        return option;
      });
      vue.watch(
        () => props.column,
        (val) => {
          if (val) {
            columns.value = [val];
          }
        },
        {
          immediate: true,
          deep: true
        }
      );
      vue.watch(
        () => props.column.fieldProps,
        (val) => {
          getCustomProps(val, displayValue.value, subRow.value, props.index, "fieldProps").then((data) => {
            customFieldProps.value = data;
          }).catch((err) => {
            throw err;
          });
        },
        {
          immediate: true,
          deep: true
        }
      );
      vue.watch(
        () => props.row,
        (val) => {
          subRow.value = { ...val };
        },
        {
          deep: true
        }
      );
      const copy = (data) => {
        const url = data;
        const textarea = document.createElement("textarea");
        textarea.readOnly = true;
        textarea.style.position = "absolute";
        textarea.style.left = "-9999px";
        textarea.value = url;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("Copy");
        textarea.remove();
      };
      const handelClickCopy = (item, row) => {
        copy(row[item.prop]);
        row.isCopy = true;
        setTimeout(() => {
          row.isCopy = false;
        }, 3e3);
      };
      const handleChange = (values) => {
        emit("change", { value: values[props.column.prop], prop: props.column.prop, row: subRow });
      };
      const startCellEdit = () => {
        isCellEdit.value = true;
      };
      const stopCellEdit = () => {
        isCellEdit.value = false;
      };
      const getDisplayItemInstance = () => {
        return {
          index: props.index,
          prop: props.column.prop,
          formInstance: vue.computed(() => {
            var _a;
            return (_a = formInstance.value) == null ? void 0 : _a.formInstance;
          })
        };
      };
      __expose({
        startCellEdit,
        stopCellEdit,
        getDisplayItemInstance
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          null,
          [
            vue.createCommentVNode(" \u8868\u5355\u7B2C\u4E00\u4F18\u5148\u7EA7 "),
            isForm.value ? (vue.openBlock(), vue.createBlock(vue.unref(PlusForm), vue.mergeProps({
              key: 0,
              ref_key: "formInstance",
              ref: formInstance,
              modelValue: modelValues.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => modelValues.value = $event),
              model: modelValues.value,
              columns: columns.value,
              "has-footer": false,
              "has-label": false
            }, _ctx.column.formProps, {
              class: "plus-display-item__form",
              onChange: handleChange
            }), vue.createSlots({
              _: 2
              /* DYNAMIC */
            }, [
              _ctx.$slots[vue.unref(getFieldSlotName)(_ctx.column.prop)] ? {
                name: vue.unref(getFieldSlotName)(_ctx.column.prop),
                fn: vue.withCtx((data) => [
                  vue.renderSlot(_ctx.$slots, vue.unref(getFieldSlotName)(_ctx.column.prop), vue.mergeProps(data, { row: subRow.value }))
                ]),
                key: "0"
              } : void 0,
              _ctx.$slots[vue.unref(getExtraSlotName)(_ctx.column.prop)] ? {
                name: vue.unref(getExtraSlotName)(_ctx.column.prop),
                fn: vue.withCtx((data) => [
                  vue.renderSlot(_ctx.$slots, vue.unref(getExtraSlotName)(_ctx.column.prop), vue.mergeProps(data, { row: subRow.value }))
                ]),
                key: "1"
              } : void 0
            ]), 1040, ["modelValue", "model", "columns"])) : _ctx.column.render && vue.unref(isFunction)(_ctx.column.render) ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 1 },
              [
                vue.createCommentVNode(" \u81EA\u5B9A\u4E49\u663E\u793A "),
                vue.createVNode(vue.unref(PlusRender), {
                  render: _ctx.column.render,
                  params: params.value,
                  "callback-value": displayValue.value,
                  "custom-field-props": customFieldProps.value
                }, null, 8, ["render", "params", "callback-value", "custom-field-props"])
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : _ctx.$slots[vue.unref(getTableCellSlotName)(_ctx.column.prop)] ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 2 },
              [
                vue.createCommentVNode(" \u63D2\u69FD "),
                vue.renderSlot(_ctx.$slots, vue.unref(getTableCellSlotName)(_ctx.column.prop), {
                  prop: _ctx.column.prop,
                  valueType: _ctx.column.valueType,
                  row: subRow.value,
                  value: displayValue.value,
                  fieldProps: customFieldProps.value,
                  column: _ctx.column
                })
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : _ctx.column.renderHTML && vue.unref(isFunction)(_ctx.column.renderHTML) ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 3 },
              [
                vue.createCommentVNode("\u663E\u793AHTML "),
                vue.createElementVNode("span", {
                  class: "plus-display-item",
                  innerHTML: _ctx.column.renderHTML(displayValue.value, { row: subRow.value, column: _ctx.column, index: _ctx.index })
                }, null, 8, _hoisted_1$a)
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : _ctx.column.valueType === "img" ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 4 },
              [
                vue.createCommentVNode("\u663E\u793A\u56FE\u7247 "),
                vue.createVNode(vue.unref(elementPlus.ElImage), vue.mergeProps({
                  class: "plus-display-item plus-display-item__image",
                  fit: "cover",
                  "preview-teleported": "",
                  src: imageUrl.value.url,
                  "preview-src-list": _ctx.column.preview !== false ? imageUrl.value.options : []
                }, customFieldProps.value), vue.createSlots({
                  _: 2
                  /* DYNAMIC */
                }, [
                  vue.renderList(_ctx.column.fieldSlots, (fieldSlot, key) => {
                    return {
                      name: key,
                      fn: vue.withCtx((data) => [
                        (vue.openBlock(), vue.createBlock(
                          vue.resolveDynamicComponent(fieldSlot),
                          vue.normalizeProps(vue.guardReactiveProps(data)),
                          null,
                          16
                          /* FULL_PROPS */
                        ))
                      ])
                    };
                  })
                ]), 1040, ["src", "preview-src-list"])
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : _ctx.column.valueType === "link" ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 5 },
              [
                vue.createCommentVNode("\u663E\u793A\u94FE\u63A5 "),
                vue.createVNode(
                  vue.unref(elementPlus.ElLink),
                  vue.mergeProps({
                    type: "primary",
                    class: "plus-display-item plus-display-item__link"
                  }, customFieldProps.value),
                  vue.createSlots({
                    default: vue.withCtx(() => [
                      vue.createTextVNode(
                        " " + vue.toDisplayString(_ctx.column.linkText || displayValue.value),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 2
                    /* DYNAMIC */
                  }, [
                    vue.renderList(_ctx.column.fieldSlots, (fieldSlot, key) => {
                      return {
                        name: key,
                        fn: vue.withCtx((data) => [
                          (vue.openBlock(), vue.createBlock(
                            vue.resolveDynamicComponent(fieldSlot),
                            vue.normalizeProps(vue.guardReactiveProps(data)),
                            null,
                            16
                            /* FULL_PROPS */
                          ))
                        ])
                      };
                    })
                  ]),
                  1040
                  /* FULL_PROPS, DYNAMIC_SLOTS */
                )
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : _ctx.column.valueType === "date-picker" && displayValue.value ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 6 },
              [
                vue.createCommentVNode(" \u683C\u5F0F\u5316\u65F6\u95F4 "),
                vue.createElementVNode(
                  "span",
                  vue.mergeProps({ class: "plus-display-item" }, customFieldProps.value),
                  vue.toDisplayString(vue.unref(formatDate)(displayValue.value)),
                  17
                  /* TEXT, FULL_PROPS */
                )
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : _ctx.column.valueType === "money" ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 7 },
              [
                vue.createCommentVNode(" \u683C\u5F0F\u5316\u91D1\u94B1 "),
                vue.createElementVNode(
                  "span",
                  vue.mergeProps({ class: "plus-display-item" }, customFieldProps.value),
                  vue.toDisplayString(vue.unref(formatMoney)(displayValue.value)),
                  17
                  /* TEXT, FULL_PROPS */
                )
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : _ctx.column.valueType === "select" || _ctx.column.valueType === "radio" || _ctx.column.valueType === "checkbox" ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 8 },
              [
                vue.createCommentVNode(" \u72B6\u6001\u663E\u793A "),
                vue.createElementVNode(
                  "span",
                  vue.mergeProps({ class: "plus-display-item plus-display-item__badge" }, customFieldProps.value),
                  [
                    getStatus.value.color || getStatus.value.type ? (vue.openBlock(), vue.createElementBlock(
                      "span",
                      {
                        key: 0,
                        class: vue.normalizeClass([
                          "plus-display-item__badge__dot",
                          getStatus.value.type && !getStatus.value.color ? "plus-display-item__badge__dot--" + getStatus.value.type : ""
                        ]),
                        style: vue.normalizeStyle({ backgroundColor: getStatus.value.color })
                      },
                      null,
                      6
                      /* CLASS, STYLE */
                    )) : vue.createCommentVNode("v-if", true),
                    vue.createTextVNode(
                      " " + vue.toDisplayString(getStatus.value.label),
                      1
                      /* TEXT */
                    )
                  ],
                  16
                  /* FULL_PROPS */
                )
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : _ctx.column.valueType === "tag" ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 9 },
              [
                vue.createCommentVNode(" \u6807\u7B7E "),
                vue.createVNode(
                  vue.unref(elementPlus.ElTag),
                  vue.mergeProps({ class: "plus-display-item" }, customFieldProps.value),
                  vue.createSlots({
                    default: vue.withCtx(() => [
                      vue.createTextVNode(
                        " " + vue.toDisplayString(displayValue.value),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 2
                    /* DYNAMIC */
                  }, [
                    vue.renderList(_ctx.column.fieldSlots, (fieldSlot, key) => {
                      return {
                        name: key,
                        fn: vue.withCtx((data) => [
                          (vue.openBlock(), vue.createBlock(
                            vue.resolveDynamicComponent(fieldSlot),
                            vue.normalizeProps(vue.guardReactiveProps(data)),
                            null,
                            16
                            /* FULL_PROPS */
                          ))
                        ])
                      };
                    })
                  ]),
                  1040
                  /* FULL_PROPS, DYNAMIC_SLOTS */
                )
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : _ctx.column.valueType === "progress" ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 10 },
              [
                vue.createCommentVNode(" \u8FDB\u5EA6\u6761 "),
                vue.createVNode(vue.unref(elementPlus.ElProgress), vue.mergeProps({
                  class: "plus-display-item",
                  percentage: displayValue.value
                }, customFieldProps.value), vue.createSlots({
                  _: 2
                  /* DYNAMIC */
                }, [
                  vue.renderList(_ctx.column.fieldSlots, (fieldSlot, key) => {
                    return {
                      name: key,
                      fn: vue.withCtx((data) => [
                        (vue.openBlock(), vue.createBlock(
                          vue.resolveDynamicComponent(fieldSlot),
                          vue.normalizeProps(vue.guardReactiveProps(data)),
                          null,
                          16
                          /* FULL_PROPS */
                        ))
                      ])
                    };
                  })
                ]), 1040, ["percentage"])
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : _ctx.column.valueType === "copy" ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 11 },
              [
                vue.createCommentVNode(" \u590D\u5236 "),
                vue.createElementVNode("span", _hoisted_2$5, [
                  vue.createTextVNode(
                    vue.toDisplayString(displayValue.value) + " ",
                    1
                    /* TEXT */
                  ),
                  vue.createVNode(
                    vue.unref(elementPlus.ElIcon),
                    vue.mergeProps({
                      size: "16",
                      class: "plus-display-item__icon__copy"
                    }, customFieldProps.value, {
                      onClick: _cache[1] || (_cache[1] = ($event) => handelClickCopy(_ctx.column, subRow.value))
                    }),
                    {
                      default: vue.withCtx(() => [
                        !subRow.value.isCopy ? (vue.openBlock(), vue.createBlock(vue.unref(document_copy_default), { key: 0 })) : (vue.openBlock(), vue.createBlock(vue.unref(select_default), { key: 1 }))
                      ]),
                      _: 1
                      /* STABLE */
                    },
                    16
                    /* FULL_PROPS */
                  )
                ])
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : _ctx.column.valueType === "code" ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 12 },
              [
                vue.createCommentVNode(" \u4EE3\u7801\u5757 "),
                vue.createElementVNode(
                  "pre",
                  vue.mergeProps({ class: "plus-display-item plus-display-item__pre" }, customFieldProps.value),
                  "      " + vue.toDisplayString(displayValue.value) + "\n  ",
                  17
                  /* TEXT, FULL_PROPS */
                )
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 13 },
              [
                vue.createCommentVNode(" \u6CA1\u6709format "),
                vue.createElementVNode(
                  "span",
                  vue.mergeProps({ class: "plus-display-item" }, customFieldProps.value),
                  vue.toDisplayString(displayValue.value),
                  17
                  /* TEXT, FULL_PROPS */
                )
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            ))
          ],
          2112
          /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
        );
      };
    }
  });

  var DisplayItem = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\display-item\\src\\index.vue"]]);

  const PlusDisplayItem = DisplayItem;

  const _hoisted_1$9 = { class: "plus-table-column__header" };
  var _sfc_main$i = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusTableTableColumn"
    },
    __name: "table-column",
    props: {
      columns: { type: Array, required: false, default: () => [] }
    },
    emits: ["formChange"],
    setup(__props, { expose: __expose, emit }) {
      const plusDisplayItemInstance = vue.shallowRef();
      const formRef = vue.inject(TableFormRefInjectionKey);
      vue.watch(plusDisplayItemInstance, (event) => {
        const data = {};
        const list = (event == null ? void 0 : event.map((item) => ({ ...item, ...item == null ? void 0 : item.getDisplayItemInstance() }))) || [];
        list.forEach((item) => {
          if (!data[item.index]) {
            data[item.index] = [];
          }
          data[item.index].push(item);
        });
        formRef.value = data;
      });
      const getKey = (item) => getTableKey(item, true);
      const handleChange = (data, index, column, item) => {
        emit("formChange", { ...data, index, column: { ...column, ...item } });
      };
      __expose({
        plusDisplayItemInstance
      });
      return (_ctx, _cache) => {
        return vue.openBlock(true), vue.createElementBlock(
          vue.Fragment,
          null,
          vue.renderList(_ctx.columns, (item) => {
            return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElTableColumn), vue.mergeProps({
              key: getKey(item),
              "class-name": "plus-table-column"
            }, item.tableColumnProps, {
              prop: item.prop,
              width: item.width,
              "min-width": item.minWidth
            }), {
              header: vue.withCtx(() => [
                vue.createElementVNode("span", _hoisted_1$9, [
                  item.renderHeader && vue.unref(isFunction)(item.renderHeader) ? (vue.openBlock(), vue.createBlock(vue.unref(PlusRender), {
                    key: 0,
                    render: item.renderHeader,
                    params: item,
                    "callback-value": item.label
                  }, null, 8, ["render", "params", "callback-value"])) : (vue.openBlock(), vue.createElementBlock(
                    vue.Fragment,
                    { key: 1 },
                    [
                      vue.createCommentVNode("\u8868\u683C\u5355\u5143\u683CHeader\u7684\u63D2\u69FD "),
                      vue.renderSlot(_ctx.$slots, vue.unref(getTableHeaderSlotName)(item.prop), {
                        prop: item.prop,
                        label: item.label,
                        fieldProps: item.fieldProps,
                        valueType: item.valueType,
                        column: item
                      }, () => [
                        vue.createTextVNode(
                          vue.toDisplayString(item.label),
                          1
                          /* TEXT */
                        )
                      ])
                    ],
                    2112
                    /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                  )),
                  item.tooltip ? (vue.openBlock(), vue.createBlock(
                    vue.unref(elementPlus.ElTooltip),
                    vue.mergeProps({
                      key: 2,
                      placement: "top"
                    }, vue.unref(getTooltip)(item.tooltip)),
                    {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(elementPlus.ElIcon), {
                          class: "plus-table-column__header__icon",
                          size: 16
                        }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(question_filled_default))
                          ]),
                          _: 1
                          /* STABLE */
                        })
                      ]),
                      _: 2
                      /* DYNAMIC */
                    },
                    1040
                    /* FULL_PROPS, DYNAMIC_SLOTS */
                  )) : vue.createCommentVNode("v-if", true)
                ])
              ]),
              default: vue.withCtx(({ row, column, $index }) => [
                vue.createVNode(vue.unref(PlusDisplayItem), {
                  ref_for: true,
                  ref_key: "plusDisplayItemInstance",
                  ref: plusDisplayItemInstance,
                  column: item,
                  row,
                  index: $index,
                  onChange: (data) => handleChange(data, $index, column, item)
                }, vue.createSlots({
                  _: 2
                  /* DYNAMIC */
                }, [
                  _ctx.$slots[vue.unref(getFieldSlotName)(item.prop)] ? {
                    name: vue.unref(getFieldSlotName)(item.prop),
                    fn: vue.withCtx((data) => [
                      vue.renderSlot(_ctx.$slots, vue.unref(getFieldSlotName)(item.prop), vue.normalizeProps(vue.guardReactiveProps(data)))
                    ]),
                    key: "0"
                  } : void 0,
                  _ctx.$slots[vue.unref(getExtraSlotName)(item.prop)] ? {
                    name: vue.unref(getExtraSlotName)(item.prop),
                    fn: vue.withCtx((data) => [
                      vue.renderSlot(_ctx.$slots, vue.unref(getExtraSlotName)(item.prop), vue.normalizeProps(vue.guardReactiveProps(data)))
                    ]),
                    key: "1"
                  } : void 0,
                  _ctx.$slots[vue.unref(getTableCellSlotName)(item.prop)] ? {
                    name: vue.unref(getTableCellSlotName)(item.prop),
                    fn: vue.withCtx((data) => [
                      vue.renderSlot(_ctx.$slots, vue.unref(getTableCellSlotName)(item.prop), vue.normalizeProps(vue.guardReactiveProps(data)))
                    ]),
                    key: "2"
                  } : void 0
                ]), 1032, ["column", "row", "index", "onChange"])
              ]),
              _: 2
              /* DYNAMIC */
            }, 1040, ["prop", "width", "min-width"]);
          }),
          128
          /* KEYED_FRAGMENT */
        );
      };
    }
  });

  var PlusTableColumnComponent = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\table\\src\\table-column.vue"]]);

  var _sfc_main$h = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusTableTableColumnIndex"
    },
    __name: "table-column-index",
    props: {
      pageInfo: { type: null, required: false, default: () => ({ ...DefaultPageInfo }) },
      indexTableColumnProps: { type: null, required: false, default: () => ({}) },
      max: { type: Number, required: false, default: 999 },
      indexContentStyle: { type: [Object, Function], required: false, default: () => ({}) }
    },
    setup(__props) {
      const props = __props;
      const getTableIndex = (index) => {
        var _a, _b;
        const i = ((((_a = props.pageInfo) == null ? void 0 : _a.page) || DefaultPageInfo.page) - 1) * (((_b = props.pageInfo) == null ? void 0 : _b.pageSize) || DefaultPageInfo.page) + index + 1;
        return +i;
      };
      const indexContentStyle = (row, index) => {
        if (isFunction(props.indexContentStyle)) {
          return props.indexContentStyle(row, index);
        } else if (isPlainObject(props.indexContentStyle)) {
          return props.indexContentStyle;
        } else {
          return {};
        }
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(
          vue.unref(elementPlus.ElTableColumn),
          vue.mergeProps({
            key: "index",
            label: "#",
            fixed: "left",
            type: "index",
            "class-name": "plus-table-column-index",
            width: "60",
            align: "center",
            index: getTableIndex
          }, _ctx.indexTableColumnProps),
          {
            default: vue.withCtx(({ row, $index }) => [
              getTableIndex($index) > 999 ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElTooltip), {
                key: 0,
                content: String(getTableIndex($index)),
                placement: "top-start"
              }, {
                default: vue.withCtx(() => [
                  vue.createElementVNode(
                    "div",
                    {
                      class: "plus-table-column-index__content",
                      style: vue.normalizeStyle(indexContentStyle(row, $index))
                    },
                    vue.toDisplayString(getTableIndex($index)),
                    5
                    /* TEXT, STYLE */
                  )
                ]),
                _: 2
                /* DYNAMIC */
              }, 1032, ["content"])) : (vue.openBlock(), vue.createElementBlock(
                "div",
                {
                  key: 1,
                  class: "plus-table-column-index__content",
                  style: vue.normalizeStyle(indexContentStyle(row, $index))
                },
                vue.toDisplayString(getTableIndex($index)),
                5
                /* TEXT, STYLE */
              ))
            ]),
            _: 1
            /* STABLE */
          },
          16
          /* FULL_PROPS */
        );
      };
    }
  });

  var PlusTableTableColumnIndex = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\table\\src\\table-column-index.vue"]]);

  /**!
   * Sortable 1.15.0
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   */
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  var version = "1.15.0";

  function userAgent(pattern) {
    if (typeof window !== 'undefined' && window.navigator) {
      return !! /*@__PURE__*/navigator.userAgent.match(pattern);
    }
  }

  var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
  var Edge = userAgent(/Edge/i);
  var FireFox = userAgent(/firefox/i);
  var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
  var IOS = userAgent(/iP(ad|od|hone)/i);
  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

  var captureMode = {
    capture: false,
    passive: false
  };

  function on(el, event, fn) {
    el.addEventListener(event, fn, !IE11OrLess && captureMode);
  }

  function off(el, event, fn) {
    el.removeEventListener(event, fn, !IE11OrLess && captureMode);
  }

  function matches(
  /**HTMLElement*/
  el,
  /**String*/
  selector) {
    if (!selector) return;
    selector[0] === '>' && (selector = selector.substring(1));

    if (el) {
      try {
        if (el.matches) {
          return el.matches(selector);
        } else if (el.msMatchesSelector) {
          return el.msMatchesSelector(selector);
        } else if (el.webkitMatchesSelector) {
          return el.webkitMatchesSelector(selector);
        }
      } catch (_) {
        return false;
      }
    }

    return false;
  }

  function getParentOrHost(el) {
    return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
  }

  function closest(
  /**HTMLElement*/
  el,
  /**String*/
  selector,
  /**HTMLElement*/
  ctx, includeCTX) {
    if (el) {
      ctx = ctx || document;

      do {
        if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
          return el;
        }

        if (el === ctx) break;
        /* jshint boss:true */
      } while (el = getParentOrHost(el));
    }

    return null;
  }

  var R_SPACE = /\s+/g;

  function toggleClass(el, name, state) {
    if (el && name) {
      if (el.classList) {
        el.classList[state ? 'add' : 'remove'](name);
      } else {
        var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
        el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
      }
    }
  }

  function css(el, prop, val) {
    var style = el && el.style;

    if (style) {
      if (val === void 0) {
        if (document.defaultView && document.defaultView.getComputedStyle) {
          val = document.defaultView.getComputedStyle(el, '');
        } else if (el.currentStyle) {
          val = el.currentStyle;
        }

        return prop === void 0 ? val : val[prop];
      } else {
        if (!(prop in style) && prop.indexOf('webkit') === -1) {
          prop = '-webkit-' + prop;
        }

        style[prop] = val + (typeof val === 'string' ? '' : 'px');
      }
    }
  }

  function matrix(el, selfOnly) {
    var appliedTransforms = '';

    if (typeof el === 'string') {
      appliedTransforms = el;
    } else {
      do {
        var transform = css(el, 'transform');

        if (transform && transform !== 'none') {
          appliedTransforms = transform + ' ' + appliedTransforms;
        }
        /* jshint boss:true */

      } while (!selfOnly && (el = el.parentNode));
    }

    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
    /*jshint -W056 */

    return matrixFn && new matrixFn(appliedTransforms);
  }

  function find(ctx, tagName, iterator) {
    if (ctx) {
      var list = ctx.getElementsByTagName(tagName),
          i = 0,
          n = list.length;

      if (iterator) {
        for (; i < n; i++) {
          iterator(list[i], i);
        }
      }

      return list;
    }

    return [];
  }

  function getWindowScrollingElement() {
    var scrollingElement = document.scrollingElement;

    if (scrollingElement) {
      return scrollingElement;
    } else {
      return document.documentElement;
    }
  }
  /**
   * Returns the "bounding client rect" of given element
   * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
   * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
   * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
   * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
   * @param  {[HTMLElement]} container              The parent the element will be placed in
   * @return {Object}                               The boundingClientRect of el, with specified adjustments
   */


  function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
    if (!el.getBoundingClientRect && el !== window) return;
    var elRect, top, left, bottom, right, height, width;

    if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
      elRect = el.getBoundingClientRect();
      top = elRect.top;
      left = elRect.left;
      bottom = elRect.bottom;
      right = elRect.right;
      height = elRect.height;
      width = elRect.width;
    } else {
      top = 0;
      left = 0;
      bottom = window.innerHeight;
      right = window.innerWidth;
      height = window.innerHeight;
      width = window.innerWidth;
    }

    if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
      // Adjust for translate()
      container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
      // Not needed on <= IE11

      if (!IE11OrLess) {
        do {
          if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
            var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

            top -= containerRect.top + parseInt(css(container, 'border-top-width'));
            left -= containerRect.left + parseInt(css(container, 'border-left-width'));
            bottom = top + elRect.height;
            right = left + elRect.width;
            break;
          }
          /* jshint boss:true */

        } while (container = container.parentNode);
      }
    }

    if (undoScale && el !== window) {
      // Adjust for scale()
      var elMatrix = matrix(container || el),
          scaleX = elMatrix && elMatrix.a,
          scaleY = elMatrix && elMatrix.d;

      if (elMatrix) {
        top /= scaleY;
        left /= scaleX;
        width /= scaleX;
        height /= scaleY;
        bottom = top + height;
        right = left + width;
      }
    }

    return {
      top: top,
      left: left,
      bottom: bottom,
      right: right,
      width: width,
      height: height
    };
  }
  /**
   * Checks if a side of an element is scrolled past a side of its parents
   * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
   * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
   * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
   * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
   */


  function isScrolledPast(el, elSide, parentSide) {
    var parent = getParentAutoScrollElement(el, true),
        elSideVal = getRect(el)[elSide];
    /* jshint boss:true */

    while (parent) {
      var parentSideVal = getRect(parent)[parentSide],
          visible = void 0;

      if (parentSide === 'top' || parentSide === 'left') {
        visible = elSideVal >= parentSideVal;
      } else {
        visible = elSideVal <= parentSideVal;
      }

      if (!visible) return parent;
      if (parent === getWindowScrollingElement()) break;
      parent = getParentAutoScrollElement(parent, false);
    }

    return false;
  }
  /**
   * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
   * and non-draggable elements
   * @param  {HTMLElement} el       The parent element
   * @param  {Number} childNum      The index of the child
   * @param  {Object} options       Parent Sortable's options
   * @return {HTMLElement}          The child at index childNum, or null if not found
   */


  function getChild(el, childNum, options, includeDragEl) {
    var currentChild = 0,
        i = 0,
        children = el.children;

    while (i < children.length) {
      if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
        if (currentChild === childNum) {
          return children[i];
        }

        currentChild++;
      }

      i++;
    }

    return null;
  }
  /**
   * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
   * @param  {HTMLElement} el       Parent element
   * @param  {selector} selector    Any other elements that should be ignored
   * @return {HTMLElement}          The last child, ignoring ghostEl
   */


  function lastChild(el, selector) {
    var last = el.lastElementChild;

    while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
      last = last.previousElementSibling;
    }

    return last || null;
  }
  /**
   * Returns the index of an element within its parent for a selected set of
   * elements
   * @param  {HTMLElement} el
   * @param  {selector} selector
   * @return {number}
   */


  function index(el, selector) {
    var index = 0;

    if (!el || !el.parentNode) {
      return -1;
    }
    /* jshint boss:true */


    while (el = el.previousElementSibling) {
      if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
        index++;
      }
    }

    return index;
  }
  /**
   * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
   * The value is returned in real pixels.
   * @param  {HTMLElement} el
   * @return {Array}             Offsets in the format of [left, top]
   */


  function getRelativeScrollOffset(el) {
    var offsetLeft = 0,
        offsetTop = 0,
        winScroller = getWindowScrollingElement();

    if (el) {
      do {
        var elMatrix = matrix(el),
            scaleX = elMatrix.a,
            scaleY = elMatrix.d;
        offsetLeft += el.scrollLeft * scaleX;
        offsetTop += el.scrollTop * scaleY;
      } while (el !== winScroller && (el = el.parentNode));
    }

    return [offsetLeft, offsetTop];
  }
  /**
   * Returns the index of the object within the given array
   * @param  {Array} arr   Array that may or may not hold the object
   * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
   * @return {Number}      The index of the object in the array, or -1
   */


  function indexOfObject(arr, obj) {
    for (var i in arr) {
      if (!arr.hasOwnProperty(i)) continue;

      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
      }
    }

    return -1;
  }

  function getParentAutoScrollElement(el, includeSelf) {
    // skip to window
    if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
    var elem = el;
    var gotSelf = false;

    do {
      // we don't need to get elem css if it isn't even overflowing in the first place (performance)
      if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
        var elemCSS = css(elem);

        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
          if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
          if (gotSelf || includeSelf) return elem;
          gotSelf = true;
        }
      }
      /* jshint boss:true */

    } while (elem = elem.parentNode);

    return getWindowScrollingElement();
  }

  function extend(dst, src) {
    if (dst && src) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          dst[key] = src[key];
        }
      }
    }

    return dst;
  }

  function isRectEqual(rect1, rect2) {
    return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
  }

  var _throttleTimeout;

  function throttle(callback, ms) {
    return function () {
      if (!_throttleTimeout) {
        var args = arguments,
            _this = this;

        if (args.length === 1) {
          callback.call(_this, args[0]);
        } else {
          callback.apply(_this, args);
        }

        _throttleTimeout = setTimeout(function () {
          _throttleTimeout = void 0;
        }, ms);
      }
    };
  }

  function cancelThrottle() {
    clearTimeout(_throttleTimeout);
    _throttleTimeout = void 0;
  }

  function scrollBy(el, x, y) {
    el.scrollLeft += x;
    el.scrollTop += y;
  }

  function clone(el) {
    var Polymer = window.Polymer;
    var $ = window.jQuery || window.Zepto;

    if (Polymer && Polymer.dom) {
      return Polymer.dom(el).cloneNode(true);
    } else if ($) {
      return $(el).clone(true)[0];
    } else {
      return el.cloneNode(true);
    }
  }

  var expando = 'Sortable' + new Date().getTime();

  function AnimationStateManager() {
    var animationStates = [],
        animationCallbackId;
    return {
      captureAnimationState: function captureAnimationState() {
        animationStates = [];
        if (!this.options.animation) return;
        var children = [].slice.call(this.el.children);
        children.forEach(function (child) {
          if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
          animationStates.push({
            target: child,
            rect: getRect(child)
          });

          var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


          if (child.thisAnimationDuration) {
            var childMatrix = matrix(child, true);

            if (childMatrix) {
              fromRect.top -= childMatrix.f;
              fromRect.left -= childMatrix.e;
            }
          }

          child.fromRect = fromRect;
        });
      },
      addAnimationState: function addAnimationState(state) {
        animationStates.push(state);
      },
      removeAnimationState: function removeAnimationState(target) {
        animationStates.splice(indexOfObject(animationStates, {
          target: target
        }), 1);
      },
      animateAll: function animateAll(callback) {
        var _this = this;

        if (!this.options.animation) {
          clearTimeout(animationCallbackId);
          if (typeof callback === 'function') callback();
          return;
        }

        var animating = false,
            animationTime = 0;
        animationStates.forEach(function (state) {
          var time = 0,
              target = state.target,
              fromRect = target.fromRect,
              toRect = getRect(target),
              prevFromRect = target.prevFromRect,
              prevToRect = target.prevToRect,
              animatingRect = state.rect,
              targetMatrix = matrix(target, true);

          if (targetMatrix) {
            // Compensate for current animation
            toRect.top -= targetMatrix.f;
            toRect.left -= targetMatrix.e;
          }

          target.toRect = toRect;

          if (target.thisAnimationDuration) {
            // Could also check if animatingRect is between fromRect and toRect
            if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
            (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
              // If returning to same place as started from animation and on same axis
              time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
            }
          } // if fromRect != toRect: animate


          if (!isRectEqual(toRect, fromRect)) {
            target.prevFromRect = fromRect;
            target.prevToRect = toRect;

            if (!time) {
              time = _this.options.animation;
            }

            _this.animate(target, animatingRect, toRect, time);
          }

          if (time) {
            animating = true;
            animationTime = Math.max(animationTime, time);
            clearTimeout(target.animationResetTimer);
            target.animationResetTimer = setTimeout(function () {
              target.animationTime = 0;
              target.prevFromRect = null;
              target.fromRect = null;
              target.prevToRect = null;
              target.thisAnimationDuration = null;
            }, time);
            target.thisAnimationDuration = time;
          }
        });
        clearTimeout(animationCallbackId);

        if (!animating) {
          if (typeof callback === 'function') callback();
        } else {
          animationCallbackId = setTimeout(function () {
            if (typeof callback === 'function') callback();
          }, animationTime);
        }

        animationStates = [];
      },
      animate: function animate(target, currentRect, toRect, duration) {
        if (duration) {
          css(target, 'transition', '');
          css(target, 'transform', '');
          var elMatrix = matrix(this.el),
              scaleX = elMatrix && elMatrix.a,
              scaleY = elMatrix && elMatrix.d,
              translateX = (currentRect.left - toRect.left) / (scaleX || 1),
              translateY = (currentRect.top - toRect.top) / (scaleY || 1);
          target.animatingX = !!translateX;
          target.animatingY = !!translateY;
          css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
          this.forRepaintDummy = repaint(target); // repaint

          css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
          css(target, 'transform', 'translate3d(0,0,0)');
          typeof target.animated === 'number' && clearTimeout(target.animated);
          target.animated = setTimeout(function () {
            css(target, 'transition', '');
            css(target, 'transform', '');
            target.animated = false;
            target.animatingX = false;
            target.animatingY = false;
          }, duration);
        }
      }
    };
  }

  function repaint(target) {
    return target.offsetWidth;
  }

  function calculateRealTime(animatingRect, fromRect, toRect, options) {
    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
  }

  var plugins$1 = [];
  var defaults = {
    initializeByDefault: true
  };
  var PluginManager = {
    mount: function mount(plugin) {
      // Set default static properties
      for (var option in defaults) {
        if (defaults.hasOwnProperty(option) && !(option in plugin)) {
          plugin[option] = defaults[option];
        }
      }

      plugins$1.forEach(function (p) {
        if (p.pluginName === plugin.pluginName) {
          throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
        }
      });
      plugins$1.push(plugin);
    },
    pluginEvent: function pluginEvent(eventName, sortable, evt) {
      var _this = this;

      this.eventCanceled = false;

      evt.cancel = function () {
        _this.eventCanceled = true;
      };

      var eventNameGlobal = eventName + 'Global';
      plugins$1.forEach(function (plugin) {
        if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

        if (sortable[plugin.pluginName][eventNameGlobal]) {
          sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
            sortable: sortable
          }, evt));
        } // Only fire plugin event if plugin is enabled in this sortable,
        // and plugin has event defined


        if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
          sortable[plugin.pluginName][eventName](_objectSpread2({
            sortable: sortable
          }, evt));
        }
      });
    },
    initializePlugins: function initializePlugins(sortable, el, defaults, options) {
      plugins$1.forEach(function (plugin) {
        var pluginName = plugin.pluginName;
        if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
        var initialized = new plugin(sortable, el, sortable.options);
        initialized.sortable = sortable;
        initialized.options = sortable.options;
        sortable[pluginName] = initialized; // Add default options from plugin

        _extends(defaults, initialized.defaults);
      });

      for (var option in sortable.options) {
        if (!sortable.options.hasOwnProperty(option)) continue;
        var modified = this.modifyOption(sortable, option, sortable.options[option]);

        if (typeof modified !== 'undefined') {
          sortable.options[option] = modified;
        }
      }
    },
    getEventProperties: function getEventProperties(name, sortable) {
      var eventProperties = {};
      plugins$1.forEach(function (plugin) {
        if (typeof plugin.eventProperties !== 'function') return;

        _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
      });
      return eventProperties;
    },
    modifyOption: function modifyOption(sortable, name, value) {
      var modifiedValue;
      plugins$1.forEach(function (plugin) {
        // Plugin must exist on the Sortable
        if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

        if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
          modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
        }
      });
      return modifiedValue;
    }
  };

  function dispatchEvent(_ref) {
    var sortable = _ref.sortable,
        rootEl = _ref.rootEl,
        name = _ref.name,
        targetEl = _ref.targetEl,
        cloneEl = _ref.cloneEl,
        toEl = _ref.toEl,
        fromEl = _ref.fromEl,
        oldIndex = _ref.oldIndex,
        newIndex = _ref.newIndex,
        oldDraggableIndex = _ref.oldDraggableIndex,
        newDraggableIndex = _ref.newDraggableIndex,
        originalEvent = _ref.originalEvent,
        putSortable = _ref.putSortable,
        extraEventProperties = _ref.extraEventProperties;
    sortable = sortable || rootEl && rootEl[expando];
    if (!sortable) return;
    var evt,
        options = sortable.options,
        onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent(name, {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent('Event');
      evt.initEvent(name, true, true);
    }

    evt.to = toEl || rootEl;
    evt.from = fromEl || rootEl;
    evt.item = targetEl || rootEl;
    evt.clone = cloneEl;
    evt.oldIndex = oldIndex;
    evt.newIndex = newIndex;
    evt.oldDraggableIndex = oldDraggableIndex;
    evt.newDraggableIndex = newDraggableIndex;
    evt.originalEvent = originalEvent;
    evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

    var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));

    for (var option in allEventProperties) {
      evt[option] = allEventProperties[option];
    }

    if (rootEl) {
      rootEl.dispatchEvent(evt);
    }

    if (options[onName]) {
      options[onName].call(sortable, evt);
    }
  }

  var _excluded = ["evt"];

  var pluginEvent = function pluginEvent(eventName, sortable) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        originalEvent = _ref.evt,
        data = _objectWithoutProperties(_ref, _excluded);

    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
      dragEl: dragEl,
      parentEl: parentEl,
      ghostEl: ghostEl,
      rootEl: rootEl,
      nextEl: nextEl,
      lastDownEl: lastDownEl,
      cloneEl: cloneEl,
      cloneHidden: cloneHidden,
      dragStarted: moved,
      putSortable: putSortable,
      activeSortable: Sortable.active,
      originalEvent: originalEvent,
      oldIndex: oldIndex,
      oldDraggableIndex: oldDraggableIndex,
      newIndex: newIndex,
      newDraggableIndex: newDraggableIndex,
      hideGhostForTarget: _hideGhostForTarget,
      unhideGhostForTarget: _unhideGhostForTarget,
      cloneNowHidden: function cloneNowHidden() {
        cloneHidden = true;
      },
      cloneNowShown: function cloneNowShown() {
        cloneHidden = false;
      },
      dispatchSortableEvent: function dispatchSortableEvent(name) {
        _dispatchEvent({
          sortable: sortable,
          name: name,
          originalEvent: originalEvent
        });
      }
    }, data));
  };

  function _dispatchEvent(info) {
    dispatchEvent(_objectSpread2({
      putSortable: putSortable,
      cloneEl: cloneEl,
      targetEl: dragEl,
      rootEl: rootEl,
      oldIndex: oldIndex,
      oldDraggableIndex: oldDraggableIndex,
      newIndex: newIndex,
      newDraggableIndex: newDraggableIndex
    }, info));
  }

  var dragEl,
      parentEl,
      ghostEl,
      rootEl,
      nextEl,
      lastDownEl,
      cloneEl,
      cloneHidden,
      oldIndex,
      newIndex,
      oldDraggableIndex,
      newDraggableIndex,
      activeGroup,
      putSortable,
      awaitingDragStarted = false,
      ignoreNextClick = false,
      sortables = [],
      tapEvt,
      touchEvt,
      lastDx,
      lastDy,
      tapDistanceLeft,
      tapDistanceTop,
      moved,
      lastTarget,
      lastDirection,
      pastFirstInvertThresh = false,
      isCircumstantialInvert = false,
      targetMoveDistance,
      // For positioning ghost absolutely
  ghostRelativeParent,
      ghostRelativeParentInitialScroll = [],
      // (left, top)
  _silent = false,
      savedInputChecked = [];
  /** @const */

  var documentExists = typeof document !== 'undefined',
      PositionGhostAbsolutely = IOS,
      CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
      // This will not pass for IE9, because IE9 DnD only works on anchors
  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
      supportCssPointerEvents = function () {
    if (!documentExists) return; // false when <= IE11

    if (IE11OrLess) {
      return false;
    }

    var el = document.createElement('x');
    el.style.cssText = 'pointer-events:auto';
    return el.style.pointerEvents === 'auto';
  }(),
      _detectDirection = function _detectDirection(el, options) {
    var elCSS = css(el),
        elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
        child1 = getChild(el, 0, options),
        child2 = getChild(el, 1, options),
        firstChildCSS = child1 && css(child1),
        secondChildCSS = child2 && css(child2),
        firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
        secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

    if (elCSS.display === 'flex') {
      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
    }

    if (elCSS.display === 'grid') {
      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
    }

    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
      var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
    }

    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
  },
      _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
        dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
        dragElOppLength = vertical ? dragRect.width : dragRect.height,
        targetS1Opp = vertical ? targetRect.left : targetRect.top,
        targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
        targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  },

  /**
   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
   * @param  {Number} x      X position
   * @param  {Number} y      Y position
   * @return {HTMLElement}   Element of the first found nearest Sortable
   */
  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
    var ret;
    sortables.some(function (sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable)) return;
      var rect = getRect(sortable),
          insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
          insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  },
      _prepareGroup = function _prepareGroup(options) {
    function toFn(value, pull) {
      return function (to, from, dragEl, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

        if (value == null && (pull || sameGroup)) {
          // Default pull value
          // Default pull and put value if same group
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === 'clone') {
          return value;
        } else if (typeof value === 'function') {
          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }

    var group = {};
    var originalGroup = options.group;

    if (!originalGroup || _typeof(originalGroup) != 'object') {
      originalGroup = {
        name: originalGroup
      };
    }

    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  },
      _hideGhostForTarget = function _hideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', 'none');
    }
  },
      _unhideGhostForTarget = function _unhideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', '');
    }
  }; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


  if (documentExists && !ChromeForAndroid) {
    document.addEventListener('click', function (evt) {
      if (ignoreNextClick) {
        evt.preventDefault();
        evt.stopPropagation && evt.stopPropagation();
        evt.stopImmediatePropagation && evt.stopImmediatePropagation();
        ignoreNextClick = false;
        return false;
      }
    }, true);
  }

  var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
    if (dragEl) {
      evt = evt.touches ? evt.touches[0] : evt;

      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

      if (nearest) {
        // Create imitation event
        var event = {};

        for (var i in evt) {
          if (evt.hasOwnProperty(i)) {
            event[i] = evt[i];
          }
        }

        event.target = event.rootEl = nearest;
        event.preventDefault = void 0;
        event.stopPropagation = void 0;

        nearest[expando]._onDragOver(event);
      }
    }
  };

  var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
    if (dragEl) {
      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
    }
  };
  /**
   * @class  Sortable
   * @param  {HTMLElement}  el
   * @param  {Object}       [options]
   */


  function Sortable(el, options) {
    if (!(el && el.nodeType && el.nodeType === 1)) {
      throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
    }

    this.el = el; // root element

    this.options = options = _extends({}, options); // Export instance

    el[expando] = this;
    var defaults = {
      group: null,
      sort: true,
      disabled: false,
      store: null,
      handle: null,
      draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
      swapThreshold: 1,
      // percentage; 0 <= x <= 1
      invertSwap: false,
      // invert always
      invertedSwapThreshold: null,
      // will be set to same as swapThreshold if default
      removeCloneOnHide: true,
      direction: function direction() {
        return _detectDirection(el, this.options);
      },
      ghostClass: 'sortable-ghost',
      chosenClass: 'sortable-chosen',
      dragClass: 'sortable-drag',
      ignore: 'a, img',
      filter: null,
      preventOnFilter: true,
      animation: 0,
      easing: null,
      setData: function setData(dataTransfer, dragEl) {
        dataTransfer.setData('Text', dragEl.textContent);
      },
      dropBubble: false,
      dragoverBubble: false,
      dataIdAttr: 'data-id',
      delay: 0,
      delayOnTouchOnly: false,
      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
      forceFallback: false,
      fallbackClass: 'sortable-fallback',
      fallbackOnBody: false,
      fallbackTolerance: 0,
      fallbackOffset: {
        x: 0,
        y: 0
      },
      supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
      emptyInsertThreshold: 5
    };
    PluginManager.initializePlugins(this, el, defaults); // Set default options

    for (var name in defaults) {
      !(name in options) && (options[name] = defaults[name]);
    }

    _prepareGroup(options); // Bind all private methods


    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    } // Setup drag mode


    this.nativeDraggable = options.forceFallback ? false : supportDraggable;

    if (this.nativeDraggable) {
      // Touch start threshold cannot be greater than the native dragstart threshold
      this.options.touchStartThreshold = 1;
    } // Bind events


    if (options.supportPointer) {
      on(el, 'pointerdown', this._onTapStart);
    } else {
      on(el, 'mousedown', this._onTapStart);
      on(el, 'touchstart', this._onTapStart);
    }

    if (this.nativeDraggable) {
      on(el, 'dragover', this);
      on(el, 'dragenter', this);
    }

    sortables.push(this.el); // Restore sorting

    options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

    _extends(this, AnimationStateManager());
  }

  Sortable.prototype =
  /** @lends Sortable.prototype */
  {
    constructor: Sortable,
    _isOutsideThisEl: function _isOutsideThisEl(target) {
      if (!this.el.contains(target) && target !== this.el) {
        lastTarget = null;
      }
    },
    _getDirection: function _getDirection(evt, target) {
      return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
    },
    _onTapStart: function _onTapStart(
    /** Event|TouchEvent */
    evt) {
      if (!evt.cancelable) return;

      var _this = this,
          el = this.el,
          options = this.options,
          preventOnFilter = options.preventOnFilter,
          type = evt.type,
          touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
          target = (touch || evt).target,
          originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
          filter = options.filter;

      _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


      if (dragEl) {
        return;
      }

      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
        return; // only left button and enabled
      } // cancel dnd if original target is content editable


      if (originalTarget.isContentEditable) {
        return;
      } // Safari ignores further event handling after mousedown


      if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
        return;
      }

      target = closest(target, options.draggable, el, false);

      if (target && target.animated) {
        return;
      }

      if (lastDownEl === target) {
        // Ignoring duplicate `down`
        return;
      } // Get the index of the dragged element within its parent


      oldIndex = index(target);
      oldDraggableIndex = index(target, options.draggable); // Check filter

      if (typeof filter === 'function') {
        if (filter.call(this, evt, target, this)) {
          _dispatchEvent({
            sortable: _this,
            rootEl: originalTarget,
            name: 'filter',
            targetEl: target,
            toEl: el,
            fromEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return; // cancel dnd
        }
      } else if (filter) {
        filter = filter.split(',').some(function (criteria) {
          criteria = closest(originalTarget, criteria.trim(), el, false);

          if (criteria) {
            _dispatchEvent({
              sortable: _this,
              rootEl: criteria,
              name: 'filter',
              targetEl: target,
              fromEl: el,
              toEl: el
            });

            pluginEvent('filter', _this, {
              evt: evt
            });
            return true;
          }
        });

        if (filter) {
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return; // cancel dnd
        }
      }

      if (options.handle && !closest(originalTarget, options.handle, el, false)) {
        return;
      } // Prepare `dragstart`


      this._prepareDragStart(evt, touch, target);
    },
    _prepareDragStart: function _prepareDragStart(
    /** Event */
    evt,
    /** Touch */
    touch,
    /** HTMLElement */
    target) {
      var _this = this,
          el = _this.el,
          options = _this.options,
          ownerDocument = el.ownerDocument,
          dragStartFn;

      if (target && !dragEl && target.parentNode === el) {
        var dragRect = getRect(target);
        rootEl = el;
        dragEl = target;
        parentEl = dragEl.parentNode;
        nextEl = dragEl.nextSibling;
        lastDownEl = target;
        activeGroup = options.group;
        Sortable.dragged = dragEl;
        tapEvt = {
          target: dragEl,
          clientX: (touch || evt).clientX,
          clientY: (touch || evt).clientY
        };
        tapDistanceLeft = tapEvt.clientX - dragRect.left;
        tapDistanceTop = tapEvt.clientY - dragRect.top;
        this._lastX = (touch || evt).clientX;
        this._lastY = (touch || evt).clientY;
        dragEl.style['will-change'] = 'all';

        dragStartFn = function dragStartFn() {
          pluginEvent('delayEnded', _this, {
            evt: evt
          });

          if (Sortable.eventCanceled) {
            _this._onDrop();

            return;
          } // Delayed drag has been triggered
          // we can re-enable the events: touchmove/mousemove


          _this._disableDelayedDragEvents();

          if (!FireFox && _this.nativeDraggable) {
            dragEl.draggable = true;
          } // Bind the events: dragstart/dragend


          _this._triggerDragStart(evt, touch); // Drag start event


          _dispatchEvent({
            sortable: _this,
            name: 'choose',
            originalEvent: evt
          }); // Chosen item


          toggleClass(dragEl, options.chosenClass, true);
        }; // Disable "draggable"


        options.ignore.split(',').forEach(function (criteria) {
          find(dragEl, criteria.trim(), _disableDraggable);
        });
        on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
        on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
        on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
        on(ownerDocument, 'mouseup', _this._onDrop);
        on(ownerDocument, 'touchend', _this._onDrop);
        on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

        if (FireFox && this.nativeDraggable) {
          this.options.touchStartThreshold = 4;
          dragEl.draggable = true;
        }

        pluginEvent('delayStart', this, {
          evt: evt
        }); // Delay is impossible for native DnD in Edge or IE

        if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
          if (Sortable.eventCanceled) {
            this._onDrop();

            return;
          } // If the user moves the pointer or let go the click or touch
          // before the delay has been reached:
          // disable the delayed drag


          on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
          on(ownerDocument, 'touchend', _this._disableDelayedDrag);
          on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
          on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
          on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
          options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
        } else {
          dragStartFn();
        }
      }
    },
    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
    /** TouchEvent|PointerEvent **/
    e) {
      var touch = e.touches ? e.touches[0] : e;

      if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
        this._disableDelayedDrag();
      }
    },
    _disableDelayedDrag: function _disableDelayedDrag() {
      dragEl && _disableDraggable(dragEl);
      clearTimeout(this._dragStartTimer);

      this._disableDelayedDragEvents();
    },
    _disableDelayedDragEvents: function _disableDelayedDragEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, 'mouseup', this._disableDelayedDrag);
      off(ownerDocument, 'touchend', this._disableDelayedDrag);
      off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
      off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
      off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
      off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
    },
    _triggerDragStart: function _triggerDragStart(
    /** Event */
    evt,
    /** Touch */
    touch) {
      touch = touch || evt.pointerType == 'touch' && evt;

      if (!this.nativeDraggable || touch) {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._onTouchMove);
        } else if (touch) {
          on(document, 'touchmove', this._onTouchMove);
        } else {
          on(document, 'mousemove', this._onTouchMove);
        }
      } else {
        on(dragEl, 'dragend', this);
        on(rootEl, 'dragstart', this._onDragStart);
      }

      try {
        if (document.selection) {
          // Timeout neccessary for IE9
          _nextTick(function () {
            document.selection.empty();
          });
        } else {
          window.getSelection().removeAllRanges();
        }
      } catch (err) {}
    },
    _dragStarted: function _dragStarted(fallback, evt) {

      awaitingDragStarted = false;

      if (rootEl && dragEl) {
        pluginEvent('dragStarted', this, {
          evt: evt
        });

        if (this.nativeDraggable) {
          on(document, 'dragover', _checkOutsideTargetEl);
        }

        var options = this.options; // Apply effect

        !fallback && toggleClass(dragEl, options.dragClass, false);
        toggleClass(dragEl, options.ghostClass, true);
        Sortable.active = this;
        fallback && this._appendGhost(); // Drag start event

        _dispatchEvent({
          sortable: this,
          name: 'start',
          originalEvent: evt
        });
      } else {
        this._nulling();
      }
    },
    _emulateDragOver: function _emulateDragOver() {
      if (touchEvt) {
        this._lastX = touchEvt.clientX;
        this._lastY = touchEvt.clientY;

        _hideGhostForTarget();

        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        var parent = target;

        while (target && target.shadowRoot) {
          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          if (target === parent) break;
          parent = target;
        }

        dragEl.parentNode[expando]._isOutsideThisEl(target);

        if (parent) {
          do {
            if (parent[expando]) {
              var inserted = void 0;
              inserted = parent[expando]._onDragOver({
                clientX: touchEvt.clientX,
                clientY: touchEvt.clientY,
                target: target,
                rootEl: parent
              });

              if (inserted && !this.options.dragoverBubble) {
                break;
              }
            }

            target = parent; // store last element
          }
          /* jshint boss:true */
          while (parent = parent.parentNode);
        }

        _unhideGhostForTarget();
      }
    },
    _onTouchMove: function _onTouchMove(
    /**TouchEvent*/
    evt) {
      if (tapEvt) {
        var options = this.options,
            fallbackTolerance = options.fallbackTolerance,
            fallbackOffset = options.fallbackOffset,
            touch = evt.touches ? evt.touches[0] : evt,
            ghostMatrix = ghostEl && matrix(ghostEl, true),
            scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
            scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
            relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
            dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
            dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

        if (!Sortable.active && !awaitingDragStarted) {
          if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
            return;
          }

          this._onDragStart(evt, true);
        }

        if (ghostEl) {
          if (ghostMatrix) {
            ghostMatrix.e += dx - (lastDx || 0);
            ghostMatrix.f += dy - (lastDy || 0);
          } else {
            ghostMatrix = {
              a: 1,
              b: 0,
              c: 0,
              d: 1,
              e: dx,
              f: dy
            };
          }

          var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
          css(ghostEl, 'webkitTransform', cssMatrix);
          css(ghostEl, 'mozTransform', cssMatrix);
          css(ghostEl, 'msTransform', cssMatrix);
          css(ghostEl, 'transform', cssMatrix);
          lastDx = dx;
          lastDy = dy;
          touchEvt = touch;
        }

        evt.cancelable && evt.preventDefault();
      }
    },
    _appendGhost: function _appendGhost() {
      // Bug if using scale(): https://stackoverflow.com/questions/2637058
      // Not being adjusted for
      if (!ghostEl) {
        var container = this.options.fallbackOnBody ? document.body : rootEl,
            rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
            options = this.options; // Position absolutely

        if (PositionGhostAbsolutely) {
          // Get relatively positioned parent
          ghostRelativeParent = container;

          while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
            ghostRelativeParent = ghostRelativeParent.parentNode;
          }

          if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
            if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
            rect.top += ghostRelativeParent.scrollTop;
            rect.left += ghostRelativeParent.scrollLeft;
          } else {
            ghostRelativeParent = getWindowScrollingElement();
          }

          ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
        }

        ghostEl = dragEl.cloneNode(true);
        toggleClass(ghostEl, options.ghostClass, false);
        toggleClass(ghostEl, options.fallbackClass, true);
        toggleClass(ghostEl, options.dragClass, true);
        css(ghostEl, 'transition', '');
        css(ghostEl, 'transform', '');
        css(ghostEl, 'box-sizing', 'border-box');
        css(ghostEl, 'margin', 0);
        css(ghostEl, 'top', rect.top);
        css(ghostEl, 'left', rect.left);
        css(ghostEl, 'width', rect.width);
        css(ghostEl, 'height', rect.height);
        css(ghostEl, 'opacity', '0.8');
        css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
        css(ghostEl, 'zIndex', '100000');
        css(ghostEl, 'pointerEvents', 'none');
        Sortable.ghost = ghostEl;
        container.appendChild(ghostEl); // Set transform-origin

        css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
      }
    },
    _onDragStart: function _onDragStart(
    /**Event*/
    evt,
    /**boolean*/
    fallback) {
      var _this = this;

      var dataTransfer = evt.dataTransfer;
      var options = _this.options;
      pluginEvent('dragStart', this, {
        evt: evt
      });

      if (Sortable.eventCanceled) {
        this._onDrop();

        return;
      }

      pluginEvent('setupClone', this);

      if (!Sortable.eventCanceled) {
        cloneEl = clone(dragEl);
        cloneEl.removeAttribute("id");
        cloneEl.draggable = false;
        cloneEl.style['will-change'] = '';

        this._hideClone();

        toggleClass(cloneEl, this.options.chosenClass, false);
        Sortable.clone = cloneEl;
      } // #1143: IFrame support workaround


      _this.cloneId = _nextTick(function () {
        pluginEvent('clone', _this);
        if (Sortable.eventCanceled) return;

        if (!_this.options.removeCloneOnHide) {
          rootEl.insertBefore(cloneEl, dragEl);
        }

        _this._hideClone();

        _dispatchEvent({
          sortable: _this,
          name: 'clone'
        });
      });
      !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

      if (fallback) {
        ignoreNextClick = true;
        _this._loopId = setInterval(_this._emulateDragOver, 50);
      } else {
        // Undo what was set in _prepareDragStart before drag started
        off(document, 'mouseup', _this._onDrop);
        off(document, 'touchend', _this._onDrop);
        off(document, 'touchcancel', _this._onDrop);

        if (dataTransfer) {
          dataTransfer.effectAllowed = 'move';
          options.setData && options.setData.call(_this, dataTransfer, dragEl);
        }

        on(document, 'drop', _this); // #1276 fix:

        css(dragEl, 'transform', 'translateZ(0)');
      }

      awaitingDragStarted = true;
      _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
      on(document, 'selectstart', _this);
      moved = true;

      if (Safari) {
        css(document.body, 'user-select', 'none');
      }
    },
    // Returns true - if no further action is needed (either inserted or another condition)
    _onDragOver: function _onDragOver(
    /**Event*/
    evt) {
      var el = this.el,
          target = evt.target,
          dragRect,
          targetRect,
          revert,
          options = this.options,
          group = options.group,
          activeSortable = Sortable.active,
          isOwner = activeGroup === group,
          canSort = options.sort,
          fromSortable = putSortable || activeSortable,
          vertical,
          _this = this,
          completedFired = false;

      if (_silent) return;

      function dragOverEvent(name, extra) {
        pluginEvent(name, _this, _objectSpread2({
          evt: evt,
          isOwner: isOwner,
          axis: vertical ? 'vertical' : 'horizontal',
          revert: revert,
          dragRect: dragRect,
          targetRect: targetRect,
          canSort: canSort,
          fromSortable: fromSortable,
          target: target,
          completed: completed,
          onMove: function onMove(target, after) {
            return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
          },
          changed: changed
        }, extra));
      } // Capture animation state


      function capture() {
        dragOverEvent('dragOverAnimationCapture');

        _this.captureAnimationState();

        if (_this !== fromSortable) {
          fromSortable.captureAnimationState();
        }
      } // Return invocation when dragEl is inserted (or completed)


      function completed(insertion) {
        dragOverEvent('dragOverCompleted', {
          insertion: insertion
        });

        if (insertion) {
          // Clones must be hidden before folding animation to capture dragRectAbsolute properly
          if (isOwner) {
            activeSortable._hideClone();
          } else {
            activeSortable._showClone(_this);
          }

          if (_this !== fromSortable) {
            // Set ghost class to new sortable's ghost class
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
            toggleClass(dragEl, options.ghostClass, true);
          }

          if (putSortable !== _this && _this !== Sortable.active) {
            putSortable = _this;
          } else if (_this === Sortable.active && putSortable) {
            putSortable = null;
          } // Animation


          if (fromSortable === _this) {
            _this._ignoreWhileAnimating = target;
          }

          _this.animateAll(function () {
            dragOverEvent('dragOverAnimationComplete');
            _this._ignoreWhileAnimating = null;
          });

          if (_this !== fromSortable) {
            fromSortable.animateAll();
            fromSortable._ignoreWhileAnimating = null;
          }
        } // Null lastTarget if it is not inside a previously swapped element


        if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
          lastTarget = null;
        } // no bubbling and not fallback


        if (!options.dragoverBubble && !evt.rootEl && target !== document) {
          dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


          !insertion && nearestEmptyInsertDetectEvent(evt);
        }

        !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
        return completedFired = true;
      } // Call when dragEl has been inserted


      function changed() {
        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);

        _dispatchEvent({
          sortable: _this,
          name: 'change',
          toEl: el,
          newIndex: newIndex,
          newDraggableIndex: newDraggableIndex,
          originalEvent: evt
        });
      }

      if (evt.preventDefault !== void 0) {
        evt.cancelable && evt.preventDefault();
      }

      target = closest(target, options.draggable, el, true);
      dragOverEvent('dragOver');
      if (Sortable.eventCanceled) return completedFired;

      if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
        return completed(false);
      }

      ignoreNextClick = false;

      if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
      : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
        vertical = this._getDirection(evt, target) === 'vertical';
        dragRect = getRect(dragEl);
        dragOverEvent('dragOverValid');
        if (Sortable.eventCanceled) return completedFired;

        if (revert) {
          parentEl = rootEl; // actualization

          capture();

          this._hideClone();

          dragOverEvent('revert');

          if (!Sortable.eventCanceled) {
            if (nextEl) {
              rootEl.insertBefore(dragEl, nextEl);
            } else {
              rootEl.appendChild(dragEl);
            }
          }

          return completed(true);
        }

        var elLastChild = lastChild(el, options.draggable);

        if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
          // Insert to end of list
          // If already at end of list: Do not insert
          if (elLastChild === dragEl) {
            return completed(false);
          } // if there is a last element, it is the target


          if (elLastChild && el === evt.target) {
            target = elLastChild;
          }

          if (target) {
            targetRect = getRect(target);
          }

          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
            capture();

            if (elLastChild && elLastChild.nextSibling) {
              // the last draggable element is not the last node
              el.insertBefore(dragEl, elLastChild.nextSibling);
            } else {
              el.appendChild(dragEl);
            }

            parentEl = el; // actualization

            changed();
            return completed(true);
          }
        } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
          // Insert to start of list
          var firstChild = getChild(el, 0, options, true);

          if (firstChild === dragEl) {
            return completed(false);
          }

          target = firstChild;
          targetRect = getRect(target);

          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
            capture();
            el.insertBefore(dragEl, firstChild);
            parentEl = el; // actualization

            changed();
            return completed(true);
          }
        } else if (target.parentNode === el) {
          targetRect = getRect(target);
          var direction = 0,
              targetBeforeFirstSwap,
              differentLevel = dragEl.parentNode !== el,
              differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
              side1 = vertical ? 'top' : 'left',
              scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
              scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

          if (lastTarget !== target) {
            targetBeforeFirstSwap = targetRect[side1];
            pastFirstInvertThresh = false;
            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
          }

          direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
          var sibling;

          if (direction !== 0) {
            // Check if target is beside dragEl in respective direction (ignoring hidden elements)
            var dragIndex = index(dragEl);

            do {
              dragIndex -= direction;
              sibling = parentEl.children[dragIndex];
            } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
          } // If dragEl is already beside target: Do not insert


          if (direction === 0 || sibling === target) {
            return completed(false);
          }

          lastTarget = target;
          lastDirection = direction;
          var nextSibling = target.nextElementSibling,
              after = false;
          after = direction === 1;

          var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

          if (moveVector !== false) {
            if (moveVector === 1 || moveVector === -1) {
              after = moveVector === 1;
            }

            _silent = true;
            setTimeout(_unsilent, 30);
            capture();

            if (after && !nextSibling) {
              el.appendChild(dragEl);
            } else {
              target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
            } // Undo chrome's scroll adjustment (has no effect on other browsers)


            if (scrolledPastTop) {
              scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
            }

            parentEl = dragEl.parentNode; // actualization
            // must be done before animation

            if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
              targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
            }

            changed();
            return completed(true);
          }
        }

        if (el.contains(dragEl)) {
          return completed(false);
        }
      }

      return false;
    },
    _ignoreWhileAnimating: null,
    _offMoveEvents: function _offMoveEvents() {
      off(document, 'mousemove', this._onTouchMove);
      off(document, 'touchmove', this._onTouchMove);
      off(document, 'pointermove', this._onTouchMove);
      off(document, 'dragover', nearestEmptyInsertDetectEvent);
      off(document, 'mousemove', nearestEmptyInsertDetectEvent);
      off(document, 'touchmove', nearestEmptyInsertDetectEvent);
    },
    _offUpEvents: function _offUpEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, 'mouseup', this._onDrop);
      off(ownerDocument, 'touchend', this._onDrop);
      off(ownerDocument, 'pointerup', this._onDrop);
      off(ownerDocument, 'touchcancel', this._onDrop);
      off(document, 'selectstart', this);
    },
    _onDrop: function _onDrop(
    /**Event*/
    evt) {
      var el = this.el,
          options = this.options; // Get the index of the dragged element within its parent

      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      pluginEvent('drop', this, {
        evt: evt
      });
      parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);

      if (Sortable.eventCanceled) {
        this._nulling();

        return;
      }

      awaitingDragStarted = false;
      isCircumstantialInvert = false;
      pastFirstInvertThresh = false;
      clearInterval(this._loopId);
      clearTimeout(this._dragStartTimer);

      _cancelNextTick(this.cloneId);

      _cancelNextTick(this._dragStartId); // Unbind events


      if (this.nativeDraggable) {
        off(document, 'drop', this);
        off(el, 'dragstart', this._onDragStart);
      }

      this._offMoveEvents();

      this._offUpEvents();

      if (Safari) {
        css(document.body, 'user-select', '');
      }

      css(dragEl, 'transform', '');

      if (evt) {
        if (moved) {
          evt.cancelable && evt.preventDefault();
          !options.dropBubble && evt.stopPropagation();
        }

        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
          // Remove clone(s)
          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
        }

        if (dragEl) {
          if (this.nativeDraggable) {
            off(dragEl, 'dragend', this);
          }

          _disableDraggable(dragEl);

          dragEl.style['will-change'] = ''; // Remove classes
          // ghostClass is added in dragStarted

          if (moved && !awaitingDragStarted) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
          }

          toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

          _dispatchEvent({
            sortable: this,
            name: 'unchoose',
            toEl: parentEl,
            newIndex: null,
            newDraggableIndex: null,
            originalEvent: evt
          });

          if (rootEl !== parentEl) {
            if (newIndex >= 0) {
              // Add event
              _dispatchEvent({
                rootEl: parentEl,
                name: 'add',
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              }); // Remove event


              _dispatchEvent({
                sortable: this,
                name: 'remove',
                toEl: parentEl,
                originalEvent: evt
              }); // drag from one list and drop into another


              _dispatchEvent({
                rootEl: parentEl,
                name: 'sort',
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }

            putSortable && putSortable.save();
          } else {
            if (newIndex !== oldIndex) {
              if (newIndex >= 0) {
                // drag & drop within the same list
                _dispatchEvent({
                  sortable: this,
                  name: 'update',
                  toEl: parentEl,
                  originalEvent: evt
                });

                _dispatchEvent({
                  sortable: this,
                  name: 'sort',
                  toEl: parentEl,
                  originalEvent: evt
                });
              }
            }
          }

          if (Sortable.active) {
            /* jshint eqnull:true */
            if (newIndex == null || newIndex === -1) {
              newIndex = oldIndex;
              newDraggableIndex = oldDraggableIndex;
            }

            _dispatchEvent({
              sortable: this,
              name: 'end',
              toEl: parentEl,
              originalEvent: evt
            }); // Save sorting


            this.save();
          }
        }
      }

      this._nulling();
    },
    _nulling: function _nulling() {
      pluginEvent('nulling', this);
      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
      savedInputChecked.forEach(function (el) {
        el.checked = true;
      });
      savedInputChecked.length = lastDx = lastDy = 0;
    },
    handleEvent: function handleEvent(
    /**Event*/
    evt) {
      switch (evt.type) {
        case 'drop':
        case 'dragend':
          this._onDrop(evt);

          break;

        case 'dragenter':
        case 'dragover':
          if (dragEl) {
            this._onDragOver(evt);

            _globalDragOver(evt);
          }

          break;

        case 'selectstart':
          evt.preventDefault();
          break;
      }
    },

    /**
     * Serializes the item into an array of string.
     * @returns {String[]}
     */
    toArray: function toArray() {
      var order = [],
          el,
          children = this.el.children,
          i = 0,
          n = children.length,
          options = this.options;

      for (; i < n; i++) {
        el = children[i];

        if (closest(el, options.draggable, this.el, false)) {
          order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
        }
      }

      return order;
    },

    /**
     * Sorts the elements according to the array.
     * @param  {String[]}  order  order of the items
     */
    sort: function sort(order, useAnimation) {
      var items = {},
          rootEl = this.el;
      this.toArray().forEach(function (id, i) {
        var el = rootEl.children[i];

        if (closest(el, this.options.draggable, rootEl, false)) {
          items[id] = el;
        }
      }, this);
      useAnimation && this.captureAnimationState();
      order.forEach(function (id) {
        if (items[id]) {
          rootEl.removeChild(items[id]);
          rootEl.appendChild(items[id]);
        }
      });
      useAnimation && this.animateAll();
    },

    /**
     * Save the current sorting
     */
    save: function save() {
      var store = this.options.store;
      store && store.set && store.set(this);
    },

    /**
     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
     * @param   {HTMLElement}  el
     * @param   {String}       [selector]  default: `options.draggable`
     * @returns {HTMLElement|null}
     */
    closest: function closest$1(el, selector) {
      return closest(el, selector || this.options.draggable, this.el, false);
    },

    /**
     * Set/get option
     * @param   {string} name
     * @param   {*}      [value]
     * @returns {*}
     */
    option: function option(name, value) {
      var options = this.options;

      if (value === void 0) {
        return options[name];
      } else {
        var modifiedValue = PluginManager.modifyOption(this, name, value);

        if (typeof modifiedValue !== 'undefined') {
          options[name] = modifiedValue;
        } else {
          options[name] = value;
        }

        if (name === 'group') {
          _prepareGroup(options);
        }
      }
    },

    /**
     * Destroy
     */
    destroy: function destroy() {
      pluginEvent('destroy', this);
      var el = this.el;
      el[expando] = null;
      off(el, 'mousedown', this._onTapStart);
      off(el, 'touchstart', this._onTapStart);
      off(el, 'pointerdown', this._onTapStart);

      if (this.nativeDraggable) {
        off(el, 'dragover', this);
        off(el, 'dragenter', this);
      } // Remove draggable attributes


      Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
        el.removeAttribute('draggable');
      });

      this._onDrop();

      this._disableDelayedDragEvents();

      sortables.splice(sortables.indexOf(this.el), 1);
      this.el = el = null;
    },
    _hideClone: function _hideClone() {
      if (!cloneHidden) {
        pluginEvent('hideClone', this);
        if (Sortable.eventCanceled) return;
        css(cloneEl, 'display', 'none');

        if (this.options.removeCloneOnHide && cloneEl.parentNode) {
          cloneEl.parentNode.removeChild(cloneEl);
        }

        cloneHidden = true;
      }
    },
    _showClone: function _showClone(putSortable) {
      if (putSortable.lastPutMode !== 'clone') {
        this._hideClone();

        return;
      }

      if (cloneHidden) {
        pluginEvent('showClone', this);
        if (Sortable.eventCanceled) return; // show clone at dragEl or original position

        if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
          rootEl.insertBefore(cloneEl, dragEl);
        } else if (nextEl) {
          rootEl.insertBefore(cloneEl, nextEl);
        } else {
          rootEl.appendChild(cloneEl);
        }

        if (this.options.group.revertClone) {
          this.animate(dragEl, cloneEl);
        }

        css(cloneEl, 'display', '');
        cloneHidden = false;
      }
    }
  };

  function _globalDragOver(
  /**Event*/
  evt) {
    if (evt.dataTransfer) {
      evt.dataTransfer.dropEffect = 'move';
    }

    evt.cancelable && evt.preventDefault();
  }

  function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
    var evt,
        sortable = fromEl[expando],
        onMoveFn = sortable.options.onMove,
        retVal; // Support for new CustomEvent feature

    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent('move', {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent('Event');
      evt.initEvent('move', true, true);
    }

    evt.to = toEl;
    evt.from = fromEl;
    evt.dragged = dragEl;
    evt.draggedRect = dragRect;
    evt.related = targetEl || toEl;
    evt.relatedRect = targetRect || getRect(toEl);
    evt.willInsertAfter = willInsertAfter;
    evt.originalEvent = originalEvent;
    fromEl.dispatchEvent(evt);

    if (onMoveFn) {
      retVal = onMoveFn.call(sortable, evt, originalEvent);
    }

    return retVal;
  }

  function _disableDraggable(el) {
    el.draggable = false;
  }

  function _unsilent() {
    _silent = false;
  }

  function _ghostIsFirst(evt, vertical, sortable) {
    var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
    var spacer = 10;
    return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
  }

  function _ghostIsLast(evt, vertical, sortable) {
    var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
    var spacer = 10;
    return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
  }

  function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
    var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
        targetLength = vertical ? targetRect.height : targetRect.width,
        targetS1 = vertical ? targetRect.top : targetRect.left,
        targetS2 = vertical ? targetRect.bottom : targetRect.right,
        invert = false;

    if (!invertSwap) {
      // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
        // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
        // check if past first invert threshold on side opposite of lastDirection
        if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
          // past first invert threshold, do not restrict inverted threshold to dragEl shadow
          pastFirstInvertThresh = true;
        }

        if (!pastFirstInvertThresh) {
          // dragEl shadow (target move distance shadow)
          if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
          : mouseOnAxis > targetS2 - targetMoveDistance) {
            return -lastDirection;
          }
        } else {
          invert = true;
        }
      } else {
        // Regular
        if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
          return _getInsertDirection(target);
        }
      }
    }

    invert = invert || invertSwap;

    if (invert) {
      // Invert of regular
      if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
      }
    }

    return 0;
  }
  /**
   * Gets the direction dragEl must be swapped relative to target in order to make it
   * seem that dragEl has been "inserted" into that element's position
   * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
   * @return {Number}                   Direction dragEl must be swapped
   */


  function _getInsertDirection(target) {
    if (index(dragEl) < index(target)) {
      return 1;
    } else {
      return -1;
    }
  }
  /**
   * Generate id
   * @param   {HTMLElement} el
   * @returns {String}
   * @private
   */


  function _generateId(el) {
    var str = el.tagName + el.className + el.src + el.href + el.textContent,
        i = str.length,
        sum = 0;

    while (i--) {
      sum += str.charCodeAt(i);
    }

    return sum.toString(36);
  }

  function _saveInputCheckedState(root) {
    savedInputChecked.length = 0;
    var inputs = root.getElementsByTagName('input');
    var idx = inputs.length;

    while (idx--) {
      var el = inputs[idx];
      el.checked && savedInputChecked.push(el);
    }
  }

  function _nextTick(fn) {
    return setTimeout(fn, 0);
  }

  function _cancelNextTick(id) {
    return clearTimeout(id);
  } // Fixed #973:


  if (documentExists) {
    on(document, 'touchmove', function (evt) {
      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
        evt.preventDefault();
      }
    });
  } // Export utils


  Sortable.utils = {
    on: on,
    off: off,
    css: css,
    find: find,
    is: function is(el, selector) {
      return !!closest(el, selector, el, false);
    },
    extend: extend,
    throttle: throttle,
    closest: closest,
    toggleClass: toggleClass,
    clone: clone,
    index: index,
    nextTick: _nextTick,
    cancelNextTick: _cancelNextTick,
    detectDirection: _detectDirection,
    getChild: getChild
  };
  /**
   * Get the Sortable instance of an element
   * @param  {HTMLElement} element The element
   * @return {Sortable|undefined}         The instance of Sortable
   */

  Sortable.get = function (element) {
    return element[expando];
  };
  /**
   * Mount a plugin to Sortable
   * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
   */


  Sortable.mount = function () {
    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }

    if (plugins[0].constructor === Array) plugins = plugins[0];
    plugins.forEach(function (plugin) {
      if (!plugin.prototype || !plugin.prototype.constructor) {
        throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
      }

      if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
      PluginManager.mount(plugin);
    });
  };
  /**
   * Create sortable instance
   * @param {HTMLElement}  el
   * @param {Object}      [options]
   */


  Sortable.create = function (el, options) {
    return new Sortable(el, options);
  }; // Export


  Sortable.version = version;

  var autoScrolls = [],
      scrollEl,
      scrollRootEl,
      scrolling = false,
      lastAutoScrollX,
      lastAutoScrollY,
      touchEvt$1,
      pointerElemChangedInterval;

  function AutoScrollPlugin() {
    function AutoScroll() {
      this.defaults = {
        scroll: true,
        forceAutoScrollFallback: false,
        scrollSensitivity: 30,
        scrollSpeed: 10,
        bubbleScroll: true
      }; // Bind all private methods

      for (var fn in this) {
        if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
          this[fn] = this[fn].bind(this);
        }
      }
    }

    AutoScroll.prototype = {
      dragStarted: function dragStarted(_ref) {
        var originalEvent = _ref.originalEvent;

        if (this.sortable.nativeDraggable) {
          on(document, 'dragover', this._handleAutoScroll);
        } else {
          if (this.options.supportPointer) {
            on(document, 'pointermove', this._handleFallbackAutoScroll);
          } else if (originalEvent.touches) {
            on(document, 'touchmove', this._handleFallbackAutoScroll);
          } else {
            on(document, 'mousemove', this._handleFallbackAutoScroll);
          }
        }
      },
      dragOverCompleted: function dragOverCompleted(_ref2) {
        var originalEvent = _ref2.originalEvent;

        // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
        if (!this.options.dragOverBubble && !originalEvent.rootEl) {
          this._handleAutoScroll(originalEvent);
        }
      },
      drop: function drop() {
        if (this.sortable.nativeDraggable) {
          off(document, 'dragover', this._handleAutoScroll);
        } else {
          off(document, 'pointermove', this._handleFallbackAutoScroll);
          off(document, 'touchmove', this._handleFallbackAutoScroll);
          off(document, 'mousemove', this._handleFallbackAutoScroll);
        }

        clearPointerElemChangedInterval();
        clearAutoScrolls();
        cancelThrottle();
      },
      nulling: function nulling() {
        touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
        autoScrolls.length = 0;
      },
      _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
        this._handleAutoScroll(evt, true);
      },
      _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
        var _this = this;

        var x = (evt.touches ? evt.touches[0] : evt).clientX,
            y = (evt.touches ? evt.touches[0] : evt).clientY,
            elem = document.elementFromPoint(x, y);
        touchEvt$1 = evt; // IE does not seem to have native autoscroll,
        // Edge's autoscroll seems too conditional,
        // MACOS Safari does not have autoscroll,
        // Firefox and Chrome are good

        if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
          autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

          var ogElemScroller = getParentAutoScrollElement(elem, true);

          if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
            pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

            pointerElemChangedInterval = setInterval(function () {
              var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

              if (newElem !== ogElemScroller) {
                ogElemScroller = newElem;
                clearAutoScrolls();
              }

              autoScroll(evt, _this.options, newElem, fallback);
            }, 10);
            lastAutoScrollX = x;
            lastAutoScrollY = y;
          }
        } else {
          // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
          if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
            clearAutoScrolls();
            return;
          }

          autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
        }
      }
    };
    return _extends(AutoScroll, {
      pluginName: 'scroll',
      initializeByDefault: true
    });
  }

  function clearAutoScrolls() {
    autoScrolls.forEach(function (autoScroll) {
      clearInterval(autoScroll.pid);
    });
    autoScrolls = [];
  }

  function clearPointerElemChangedInterval() {
    clearInterval(pointerElemChangedInterval);
  }

  var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
    // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
    if (!options.scroll) return;
    var x = (evt.touches ? evt.touches[0] : evt).clientX,
        y = (evt.touches ? evt.touches[0] : evt).clientY,
        sens = options.scrollSensitivity,
        speed = options.scrollSpeed,
        winScroller = getWindowScrollingElement();
    var scrollThisInstance = false,
        scrollCustomFn; // New scroll root, set scrollEl

    if (scrollRootEl !== rootEl) {
      scrollRootEl = rootEl;
      clearAutoScrolls();
      scrollEl = options.scroll;
      scrollCustomFn = options.scrollFn;

      if (scrollEl === true) {
        scrollEl = getParentAutoScrollElement(rootEl, true);
      }
    }

    var layersOut = 0;
    var currentParent = scrollEl;

    do {
      var el = currentParent,
          rect = getRect(el),
          top = rect.top,
          bottom = rect.bottom,
          left = rect.left,
          right = rect.right,
          width = rect.width,
          height = rect.height,
          canScrollX = void 0,
          canScrollY = void 0,
          scrollWidth = el.scrollWidth,
          scrollHeight = el.scrollHeight,
          elCSS = css(el),
          scrollPosX = el.scrollLeft,
          scrollPosY = el.scrollTop;

      if (el === winScroller) {
        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
      } else {
        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
      }

      var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
      var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

      if (!autoScrolls[layersOut]) {
        for (var i = 0; i <= layersOut; i++) {
          if (!autoScrolls[i]) {
            autoScrolls[i] = {};
          }
        }
      }

      if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
        autoScrolls[layersOut].el = el;
        autoScrolls[layersOut].vx = vx;
        autoScrolls[layersOut].vy = vy;
        clearInterval(autoScrolls[layersOut].pid);

        if (vx != 0 || vy != 0) {
          scrollThisInstance = true;
          /* jshint loopfunc:true */

          autoScrolls[layersOut].pid = setInterval(function () {
            // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
            if (isFallback && this.layer === 0) {
              Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

            }

            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

            if (typeof scrollCustomFn === 'function') {
              if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
                return;
              }
            }

            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
          }.bind({
            layer: layersOut
          }), 24);
        }
      }

      layersOut++;
    } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

    scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
  }, 30);

  var drop = function drop(_ref) {
    var originalEvent = _ref.originalEvent,
        putSortable = _ref.putSortable,
        dragEl = _ref.dragEl,
        activeSortable = _ref.activeSortable,
        dispatchSortableEvent = _ref.dispatchSortableEvent,
        hideGhostForTarget = _ref.hideGhostForTarget,
        unhideGhostForTarget = _ref.unhideGhostForTarget;
    if (!originalEvent) return;
    var toSortable = putSortable || activeSortable;
    hideGhostForTarget();
    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
    var target = document.elementFromPoint(touch.clientX, touch.clientY);
    unhideGhostForTarget();

    if (toSortable && !toSortable.el.contains(target)) {
      dispatchSortableEvent('spill');
      this.onSpill({
        dragEl: dragEl,
        putSortable: putSortable
      });
    }
  };

  function Revert() {}

  Revert.prototype = {
    startIndex: null,
    dragStart: function dragStart(_ref2) {
      var oldDraggableIndex = _ref2.oldDraggableIndex;
      this.startIndex = oldDraggableIndex;
    },
    onSpill: function onSpill(_ref3) {
      var dragEl = _ref3.dragEl,
          putSortable = _ref3.putSortable;
      this.sortable.captureAnimationState();

      if (putSortable) {
        putSortable.captureAnimationState();
      }

      var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

      if (nextSibling) {
        this.sortable.el.insertBefore(dragEl, nextSibling);
      } else {
        this.sortable.el.appendChild(dragEl);
      }

      this.sortable.animateAll();

      if (putSortable) {
        putSortable.animateAll();
      }
    },
    drop: drop
  };

  _extends(Revert, {
    pluginName: 'revertOnSpill'
  });

  function Remove() {}

  Remove.prototype = {
    onSpill: function onSpill(_ref4) {
      var dragEl = _ref4.dragEl,
          putSortable = _ref4.putSortable;
      var parentSortable = putSortable || this.sortable;
      parentSortable.captureAnimationState();
      dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
      parentSortable.animateAll();
    },
    drop: drop
  };

  _extends(Remove, {
    pluginName: 'removeOnSpill'
  });

  Sortable.mount(new AutoScrollPlugin());
  Sortable.mount(Remove, Revert);

  const _hoisted_1$8 = /* @__PURE__ */ vue.createElementVNode(
    "span",
    { class: "plus-table-column-drag-icon" },
    "\u2637",
    -1
    /* HOISTED */
  );
  var _sfc_main$g = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusTableColumnDragSort"
    },
    __name: "table-column-drag-sort",
    props: {
      sortable: { type: Boolean, required: true, skipCheck: true, default: true },
      tableInstance: { type: null, required: true, default: null },
      dragSortableTableColumnProps: { type: null, required: true, default: () => ({}) }
    },
    emits: ["dragSortEnd"],
    setup(__props, { emit }) {
      const props = __props;
      const { t } = useLocale();
      vue.watch(
        () => props.tableInstance,
        (val) => {
          if (val && props.sortable) {
            rowDrop();
          }
        }
      );
      const rowDrop = () => {
        var _a, _b;
        const tbody = (_b = (_a = props.tableInstance) == null ? void 0 : _a.$el) == null ? void 0 : _b.querySelector(".el-table__body-wrapper tbody");
        if (!tbody)
          return;
        let config = {
          handle: ".plus-table-column-drag-icon",
          animation: 150,
          group: "box",
          easing: "cubic-bezier(1, 0, 0, 1)",
          chosenClass: "sortable-chosen",
          forceFallback: true,
          onEnd({ newIndex, oldIndex }) {
            emit("dragSortEnd", newIndex, oldIndex);
          }
        };
        if (isPlainObject(props.sortable)) {
          config = { ...config, ...props.sortable };
        }
        Sortable.create(tbody, config);
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElTableColumn), vue.mergeProps({
          key: "dragSort",
          label: vue.unref(t)("plus.table.sort"),
          width: "60",
          "class-name": "plus-table-column-drag-sort"
        }, _ctx.dragSortableTableColumnProps), {
          default: vue.withCtx(() => [
            _hoisted_1$8
          ]),
          _: 1
          /* STABLE */
        }, 16, ["label"]);
      };
    }
  });

  var PlusTableColumnDragSort = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\table\\src\\table-column-drag-sort.vue"]]);

  const _hoisted_1$7 = {
    key: 0,
    style: { "padding-top": "12px" }
  };
  var _sfc_main$f = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusPopover"
    },
    __name: "index",
    props: {
      hasShowBottomButton: { type: Boolean, required: false, default: false },
      confirmLoading: { type: Boolean, required: false, default: false },
      cancelText: { type: String, required: false, default: "" },
      confirmText: { type: String, required: false, default: "" }
    },
    emits: ["cancel", "confirm"],
    setup(__props, { emit }) {
      const props = __props;
      const subVisible = vue.ref(false);
      const { t } = useLocale();
      vue.watch(
        () => props.visible,
        (val) => {
          subVisible.value = val;
        },
        {
          immediate: true
        }
      );
      const handleCancelPopover = () => {
        subVisible.value = false;
        emit("cancel");
      };
      const handleConfirmPopover = () => {
        subVisible.value = false;
        emit("confirm");
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElPopover), vue.mergeProps({
          visible: subVisible.value,
          "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => subVisible.value = $event)
        }, _ctx.$attrs), {
          reference: vue.withCtx(() => [
            vue.createElementVNode("span", null, [
              vue.renderSlot(_ctx.$slots, "reference")
            ])
          ]),
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "default"),
            _ctx.hasShowBottomButton ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$7, [
              vue.createVNode(vue.unref(elementPlus.ElButton), {
                size: "small",
                plain: "",
                onClick: handleCancelPopover
              }, {
                default: vue.withCtx(() => [
                  vue.createTextVNode(
                    vue.toDisplayString(_ctx.cancelText || vue.unref(t)("plus.popover.cancelText")),
                    1
                    /* TEXT */
                  )
                ]),
                _: 1
                /* STABLE */
              }),
              vue.createVNode(vue.unref(elementPlus.ElButton), {
                size: "small",
                type: "primary",
                loading: _ctx.confirmLoading,
                onClick: handleConfirmPopover
              }, {
                default: vue.withCtx(() => [
                  vue.createTextVNode(
                    vue.toDisplayString(_ctx.confirmText || vue.unref(t)("plus.popover.confirmText")),
                    1
                    /* TEXT */
                  )
                ]),
                _: 1
                /* STABLE */
              }, 8, ["loading"])
            ])) : vue.createCommentVNode("v-if", true)
          ]),
          _: 3
          /* FORWARDED */
        }, 16, ["visible"]);
      };
    }
  });

  var Popover = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\popover\\src\\index.vue"]]);

  const PlusPopover = Popover;

  const _hoisted_1$6 = { class: "plus-table-title-bar" };
  const _hoisted_2$4 = { class: "plus-table-title-bar__title" };
  const _hoisted_3$2 = { class: "plus-table-title-bar__toolbar" };
  const _hoisted_4$2 = { class: "plus-table-title-bar__toolbar__density" };
  const _hoisted_5$2 = /* @__PURE__ */ vue.createElementVNode(
    "svg",
    {
      viewBox: "0 0 1024 1024",
      focusable: "false",
      "data-icon": "column-height",
      fill: "currentColor",
      "aria-hidden": "true"
    },
    [
      /* @__PURE__ */ vue.createElementVNode("path", { d: "M840 836H184c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h656c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm0-724H184c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h656c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zM610.8 378c6 0 9.4-7 5.7-11.7L515.7 238.7a7.14 7.14 0 00-11.3 0L403.6 366.3a7.23 7.23 0 005.7 11.7H476v268h-62.8c-6 0-9.4 7-5.7 11.7l100.8 127.5c2.9 3.7 8.5 3.7 11.3 0l100.8-127.5c3.7-4.7.4-11.7-5.7-11.7H548V378h62.8z" })
    ],
    -1
    /* HOISTED */
  );
  const _hoisted_6$2 = { key: 1 };
  var _sfc_main$e = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusTableToolbar"
    },
    __name: "table-title-bar",
    props: {
      columns: { type: Array, required: false, default: () => [] },
      titleBar: { type: Boolean, required: false, skipCheck: true, default: true },
      filterTableHeaderOverflowLabelLength: { type: Number, required: false, default: 6 },
      defaultSize: { type: null, required: false, default: "default" },
      changeColumns: { type: Array, required: false, default: () => [] }
    },
    emits: ["filterTable", "clickDensity", "refresh"],
    setup(__props, { emit }) {
      const props = __props;
      const checkboxGroupInstance = vue.ref(null);
      const titleBarConfig = vue.computed(() => props.titleBar);
      const iconSize = vue.computed(() => {
        var _a;
        return ((_a = titleBarConfig.value.icon) == null ? void 0 : _a.size) || 18;
      });
      const iconColor = vue.computed(() => {
        var _a;
        return (_a = titleBarConfig.value.icon) == null ? void 0 : _a.color;
      });
      const { t } = useLocale();
      const buttonNameDensity = [
        {
          size: "default",
          text: vue.computed(() => t("plus.table.default"))
        },
        {
          size: "large",
          text: vue.computed(() => t("plus.table.loose"))
        },
        {
          size: "small",
          text: vue.computed(() => t("plus.table.compact"))
        }
      ];
      const subColumns = vue.computed(() => props.columns.filter((item) => vue.unref(item.hideInTable) !== true));
      const state = vue.reactive({
        checkAll: true,
        isIndeterminate: false,
        bigImageVisible: false,
        srcList: [],
        checkList: cloneDeep(subColumns.value).map((item) => getTableKey(item))
      });
      const handleCheckAllChange = (val) => {
        state.checkList = val ? cloneDeep(subColumns.value).map((item) => getTableKey(item)) : [];
        state.isIndeterminate = false;
      };
      const handleFilterTableConfirm = () => {
        const columns = cloneDeep(subColumns.value);
        const filterColumns = columns.filter((item) => state.checkList.includes(getTableKey(item)));
        emit("filterTable", filterColumns);
      };
      const handleCheckGroupChange = (value) => {
        const checkedCount = value.length;
        state.checkAll = checkedCount === subColumns.value.length;
        state.isIndeterminate = checkedCount > 0 && checkedCount < subColumns.value.length;
        handleFilterTableConfirm();
      };
      const handleClickDensity = (size) => {
        emit("clickDensity", size);
      };
      const handleRefresh = () => {
        emit("refresh");
      };
      const getLabel = (label) => {
        if ((label == null ? void 0 : label.length) <= props.filterTableHeaderOverflowLabelLength) {
          return label;
        }
        return (label == null ? void 0 : label.slice(0, props.filterTableHeaderOverflowLabelLength)) + "...";
      };
      const handleDrop = () => {
        var _a, _b;
        const checkbox = checkboxGroupInstance.value;
        if (!checkbox)
          return;
        let config = {
          onEnd: handleDragEnd
        };
        const dragSort = (_b = (_a = props.titleBar) == null ? void 0 : _a.columnSetting) == null ? void 0 : _b.dragSort;
        if (isPlainObject(dragSort)) {
          config = { ...config, ...dragSort, handle: ".plus-handle" };
        }
        new Sortable(checkbox, config);
      };
      const handleDragEnd = (event) => {
        const subDragCheckboxList = cloneDeep(props.changeColumns);
        const draggedCheckbox = props.changeColumns[event.oldIndex];
        subDragCheckboxList.splice(event.oldIndex, 1);
        subDragCheckboxList.splice(event.newIndex, 0, draggedCheckbox);
        emit("filterTable", subDragCheckboxList);
      };
      vue.onMounted(() => {
        var _a, _b;
        const dragSort = (_b = (_a = props.titleBar) == null ? void 0 : _a.columnSetting) == null ? void 0 : _b.dragSort;
        if (dragSort !== false) {
          if (checkboxGroupInstance.value) {
            handleDrop();
          }
        }
      });
      return (_ctx, _cache) => {
        var _a, _b, _c;
        return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$6, [
          vue.createElementVNode("div", _hoisted_2$4, [
            vue.renderSlot(_ctx.$slots, "title", {}, () => [
              vue.createTextVNode(
                vue.toDisplayString(titleBarConfig.value.title),
                1
                /* TEXT */
              )
            ])
          ]),
          vue.createElementVNode("div", _hoisted_3$2, [
            vue.renderSlot(_ctx.$slots, "toolbar"),
            ((_a = titleBarConfig.value) == null ? void 0 : _a.refresh) === true ? (vue.openBlock(), vue.createElementBlock("span", {
              key: 0,
              class: "plus-table-title-bar__toolbar__refresh",
              onClick: handleRefresh
            }, [
              vue.createVNode(vue.unref(elementPlus.ElTooltip), {
                effect: "dark",
                content: vue.unref(t)("plus.table.refresh"),
                placement: "top"
              }, {
                default: vue.withCtx(() => [
                  vue.createVNode(vue.unref(elementPlus.ElIcon), {
                    size: iconSize.value,
                    color: iconColor.value,
                    class: "plus-table-title-bar__toolbar__icon"
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(vue.unref(refresh_right_default))
                    ]),
                    _: 1
                    /* STABLE */
                  }, 8, ["size", "color"])
                ]),
                _: 1
                /* STABLE */
              }, 8, ["content"])
            ])) : vue.createCommentVNode("v-if", true),
            vue.createCommentVNode(" \u8868\u683C\u5BC6\u5EA6 "),
            ((_b = titleBarConfig.value) == null ? void 0 : _b.density) !== false ? (vue.openBlock(), vue.createBlock(vue.unref(PlusPopover), {
              key: 1,
              placement: "bottom",
              width: 150,
              trigger: "click",
              title: vue.unref(t)("plus.table.density")
            }, {
              reference: vue.withCtx(() => [
                vue.createVNode(vue.unref(elementPlus.ElTooltip), {
                  effect: "dark",
                  content: vue.unref(t)("plus.table.density"),
                  placement: "top"
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(elementPlus.ElIcon), {
                      size: iconSize.value,
                      color: iconColor.value,
                      class: "plus-table-title-bar__toolbar__icon"
                    }, {
                      default: vue.withCtx(() => [
                        _hoisted_5$2
                      ]),
                      _: 1
                      /* STABLE */
                    }, 8, ["size", "color"])
                  ]),
                  _: 1
                  /* STABLE */
                }, 8, ["content"])
              ]),
              default: vue.withCtx(() => [
                vue.createElementVNode("div", _hoisted_4$2, [
                  (vue.openBlock(), vue.createElementBlock(
                    vue.Fragment,
                    null,
                    vue.renderList(buttonNameDensity, (item) => {
                      return vue.createVNode(vue.unref(elementPlus.ElButton), {
                        key: item.size,
                        plain: _ctx.defaultSize !== item.size,
                        type: "primary",
                        size: "small",
                        onClick: ($event) => handleClickDensity(item.size)
                      }, {
                        default: vue.withCtx(() => [
                          vue.createTextVNode(
                            vue.toDisplayString(vue.unref(item.text)),
                            1
                            /* TEXT */
                          )
                        ]),
                        _: 2
                        /* DYNAMIC */
                      }, 1032, ["plain", "onClick"]);
                    }),
                    64
                    /* STABLE_FRAGMENT */
                  ))
                ])
              ]),
              _: 1
              /* STABLE */
            }, 8, ["title"])) : vue.createCommentVNode("v-if", true),
            vue.createCommentVNode(" \u5217\u8BBE\u7F6E "),
            ((_c = titleBarConfig.value) == null ? void 0 : _c.columnSetting) !== false ? (vue.openBlock(), vue.createBlock(vue.unref(PlusPopover), {
              key: 2,
              placement: "bottom",
              width: 100,
              trigger: "click",
              title: vue.unref(t)("plus.table.columnSettings")
            }, {
              reference: vue.withCtx(() => [
                vue.createVNode(vue.unref(elementPlus.ElTooltip), {
                  effect: "dark",
                  content: vue.unref(t)("plus.table.columnSettings"),
                  placement: "top"
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(elementPlus.ElIcon), {
                      size: iconSize.value,
                      color: iconColor.value,
                      class: "plus-table-title-bar__toolbar__icon"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(setting_default))
                      ]),
                      _: 1
                      /* STABLE */
                    }, 8, ["size", "color"])
                  ]),
                  _: 1
                  /* STABLE */
                }, 8, ["content"])
              ]),
              default: vue.withCtx(() => [
                vue.createVNode(vue.unref(elementPlus.ElCheckbox), {
                  modelValue: state.checkAll,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.checkAll = $event),
                  indeterminate: state.isIndeterminate,
                  onChange: handleCheckAllChange
                }, {
                  default: vue.withCtx(() => [
                    vue.createTextVNode(
                      vue.toDisplayString(vue.unref(t)("plus.table.selectAll")),
                      1
                      /* TEXT */
                    )
                  ]),
                  _: 1
                  /* STABLE */
                }, 8, ["modelValue", "indeterminate"]),
                vue.createVNode(vue.unref(elementPlus.ElCheckboxGroup), {
                  modelValue: state.checkList,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => state.checkList = $event),
                  onChange: handleCheckGroupChange
                }, {
                  default: vue.withCtx(() => [
                    vue.createElementVNode(
                      "div",
                      {
                        ref_key: "checkboxGroupInstance",
                        ref: checkboxGroupInstance,
                        class: "plus-checkbox-sortable-list"
                      },
                      [
                        (vue.openBlock(true), vue.createElementBlock(
                          vue.Fragment,
                          null,
                          vue.renderList(subColumns.value, (item) => {
                            return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElCheckbox), {
                              key: item.label,
                              label: vue.unref(getTableKey)(item),
                              disabled: item.headerFilter,
                              class: "plus-table-title-bar__toolbar__checkbox__item plus-handle"
                            }, {
                              default: vue.withCtx(() => {
                                var _a2;
                                return [
                                  ((_a2 = item.label) == null ? void 0 : _a2.length) > _ctx.filterTableHeaderOverflowLabelLength ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElTooltip), {
                                    key: 0,
                                    content: item.label,
                                    placement: "right-start"
                                  }, {
                                    default: vue.withCtx(() => [
                                      vue.createTextVNode(
                                        vue.toDisplayString(getLabel(item.label)),
                                        1
                                        /* TEXT */
                                      )
                                    ]),
                                    _: 2
                                    /* DYNAMIC */
                                  }, 1032, ["content"])) : (vue.openBlock(), vue.createElementBlock(
                                    "span",
                                    _hoisted_6$2,
                                    vue.toDisplayString(getLabel(item.label)),
                                    1
                                    /* TEXT */
                                  ))
                                ];
                              }),
                              _: 2
                              /* DYNAMIC */
                            }, 1032, ["label", "disabled"]);
                          }),
                          128
                          /* KEYED_FRAGMENT */
                        ))
                      ],
                      512
                      /* NEED_PATCH */
                    )
                  ]),
                  _: 1
                  /* STABLE */
                }, 8, ["modelValue"])
              ]),
              _: 1
              /* STABLE */
            }, 8, ["title"])) : vue.createCommentVNode("v-if", true)
          ])
        ]);
      };
    }
  });

  var PlusTableTitleBar = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\table\\src\\table-title-bar.vue"]]);

  const _hoisted_1$5 = { class: "plus-table" };
  const _hoisted_2$3 = { class: "plus-table-expand-col" };
  var _sfc_main$d = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusTable",
      inheritAttrs: false
    },
    __name: "index",
    props: {
      defaultSize: { type: null, required: false, default: "default" },
      pagination: { type: [Boolean, Object], required: false, default: false },
      actionBar: { type: [Boolean, Object], required: false, default: false },
      hasIndexColumn: { type: Boolean, required: false, default: false },
      titleBar: { type: [Boolean, Object], required: false, default: true },
      isSelection: { type: Boolean, required: false, default: false },
      hasExpand: { type: Boolean, required: false, default: false },
      loadingStatus: { type: Boolean, required: false, default: false },
      height: { type: String, required: false },
      tableData: { type: Array, required: true, default: () => [] },
      columns: { type: Array, required: true, default: () => [] },
      headerCellStyle: { type: Object, required: false, default: () => ({}) },
      rowKey: { type: String, required: false, default: "id" },
      dragSortable: { type: [Boolean, Object], required: false, default: false },
      dragSortableTableColumnProps: { type: null, required: false, default: () => ({}) },
      indexTableColumnProps: { type: null, required: false, default: () => ({}) },
      selectionTableColumnProps: { type: null, required: false, default: () => ({
        width: 40
      }) },
      expandTableColumnProps: { type: null, required: false, default: () => ({}) },
      indexContentStyle: { type: [Object, Function], required: false, default: () => ({}) }
    },
    emits: ["paginationChange", "clickAction", "clickActionConfirmCancel", "dragSortEnd", "formChange", "refresh"],
    setup(__props, { expose: __expose, emit }) {
      var _a;
      const props = __props;
      const PlusTableActionBar = PlusTableActionBarComponent;
      const PlusTableColumn = PlusTableColumnComponent;
      const subColumns = vue.ref([]);
      const tableInstance = vue.shallowRef(null);
      const state = vue.reactive({
        subPageInfo: {
          ...((_a = props.pagination) == null ? void 0 : _a.modelValue) || DefaultPageInfo
        },
        size: props.defaultSize
      });
      const slots = vue.useSlots();
      const cellSlots = filterSlots(slots, getTableCellSlotName());
      const headerSlots = filterSlots(slots, getTableHeaderSlotName());
      const fieldSlots = filterSlots(slots, getFieldSlotName());
      const extraSlots = filterSlots(slots, getExtraSlotName());
      const formRefs = vue.shallowRef({});
      vue.provide(TableFormRefInjectionKey, formRefs);
      vue.watch(
        () => props.columns,
        (val) => {
          subColumns.value = val.filter((item) => vue.unref(item.hideInTable) !== true);
        },
        {
          deep: true,
          immediate: true
        }
      );
      const handlePaginationChange = () => {
        emit("paginationChange", { ...state.subPageInfo });
      };
      const handleAction = (res) => {
        const { row, buttonRow, index, e } = res;
        emit("clickAction", { row, buttonRow, index, e, formRefs: formRefs.value[index] });
      };
      const handleClickActionConfirmCancel = (res) => {
        const { row, buttonRow, index, e } = res;
        emit("clickActionConfirmCancel", {
          row,
          buttonRow,
          index,
          e,
          formRefs: formRefs.value[index]
        });
      };
      const handleFilterTableConfirm = (data) => {
        subColumns.value = data.filter((item) => vue.unref(item.hideInTable) !== true);
      };
      const handleClickDensity = (data) => {
        state.size = data;
      };
      const handleDragSortEnd = (newIndex, oldIndex) => {
        emit("dragSortEnd", newIndex, oldIndex);
      };
      const handleRefresh = () => {
        emit("refresh");
      };
      const handleFormChange = (data) => {
        emit("formChange", data);
      };
      const { subPageInfo, size } = vue.toRefs(state);
      __expose({
        formRefs,
        tableInstance
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$5, [
          _ctx.titleBar ? (vue.openBlock(), vue.createBlock(PlusTableTitleBar, {
            key: 0,
            columns: _ctx.columns,
            "default-size": vue.unref(size),
            "title-bar": _ctx.titleBar,
            "change-columns": subColumns.value,
            onClickDensity: handleClickDensity,
            onFilterTable: handleFilterTableConfirm,
            onRefresh: handleRefresh
          }, {
            title: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "title")
            ]),
            toolbar: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "toolbar")
            ]),
            _: 3
            /* FORWARDED */
          }, 8, ["columns", "default-size", "title-bar", "change-columns"])) : vue.createCommentVNode("v-if", true),
          vue.withDirectives((vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElTable), vue.mergeProps({
            ref_key: "tableInstance",
            ref: tableInstance,
            "reserve-selection": true,
            data: _ctx.tableData,
            border: true,
            height: _ctx.height,
            "header-cell-style": _ctx.headerCellStyle,
            size: vue.unref(size),
            "row-key": _ctx.rowKey,
            "highlight-current-row": "",
            "scrollbar-always-on": ""
          }, _ctx.$attrs), {
            append: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "append")
            ]),
            empty: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "empty")
            ]),
            default: vue.withCtx(() => {
              var _a2;
              return [
                _ctx.isSelection ? (vue.openBlock(), vue.createBlock(
                  vue.unref(elementPlus.ElTableColumn),
                  vue.mergeProps({
                    key: "selection",
                    type: "selection"
                  }, _ctx.selectionTableColumnProps),
                  null,
                  16
                  /* FULL_PROPS */
                )) : vue.createCommentVNode("v-if", true),
                _ctx.hasIndexColumn ? (vue.openBlock(), vue.createBlock(PlusTableTableColumnIndex, {
                  key: 1,
                  "index-content-style": _ctx.indexContentStyle,
                  "index-table-column-props": _ctx.indexTableColumnProps,
                  "page-info": (_a2 = _ctx.pagination) == null ? void 0 : _a2.modelValue
                }, null, 8, ["index-content-style", "index-table-column-props", "page-info"])) : vue.createCommentVNode("v-if", true),
                _ctx.dragSortable ? (vue.openBlock(), vue.createBlock(PlusTableColumnDragSort, {
                  key: 2,
                  sortable: _ctx.dragSortable,
                  "drag-sortable-table-column-props": _ctx.dragSortableTableColumnProps,
                  "table-instance": tableInstance.value,
                  onDragSortEnd: handleDragSortEnd
                }, null, 8, ["sortable", "drag-sortable-table-column-props", "table-instance"])) : vue.createCommentVNode("v-if", true),
                _ctx.hasExpand ? (vue.openBlock(), vue.createBlock(
                  vue.unref(elementPlus.ElTableColumn),
                  vue.mergeProps({
                    key: 3,
                    type: "expand"
                  }, _ctx.expandTableColumnProps),
                  {
                    default: vue.withCtx(({ row, $index }) => [
                      vue.createElementVNode("div", _hoisted_2$3, [
                        vue.renderSlot(_ctx.$slots, "expand", {
                          row,
                          index: $index
                        })
                      ])
                    ]),
                    _: 3
                    /* FORWARDED */
                  },
                  16
                  /* FULL_PROPS */
                )) : vue.createCommentVNode("v-if", true),
                vue.createVNode(vue.unref(PlusTableColumn), {
                  columns: subColumns.value,
                  onFormChange: handleFormChange
                }, vue.createSlots({
                  _: 2
                  /* DYNAMIC */
                }, [
                  vue.renderList(vue.unref(headerSlots), (_, key) => {
                    return {
                      name: key,
                      fn: vue.withCtx((data) => [
                        vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                      ])
                    };
                  }),
                  vue.renderList(vue.unref(cellSlots), (_, key) => {
                    return {
                      name: key,
                      fn: vue.withCtx((data) => [
                        vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                      ])
                    };
                  }),
                  vue.renderList(vue.unref(fieldSlots), (_, key) => {
                    return {
                      name: key,
                      fn: vue.withCtx((data) => [
                        vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                      ])
                    };
                  }),
                  vue.renderList(vue.unref(extraSlots), (_, key) => {
                    return {
                      name: key,
                      fn: vue.withCtx((data) => [
                        vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                      ])
                    };
                  })
                ]), 1032, ["columns"]),
                _ctx.actionBar ? (vue.openBlock(), vue.createBlock(
                  vue.unref(PlusTableActionBar),
                  vue.mergeProps({ key: 4 }, _ctx.actionBar, {
                    onClickAction: handleAction,
                    onClickActionConfirmCancel: handleClickActionConfirmCancel
                  }),
                  null,
                  16
                  /* FULL_PROPS */
                )) : vue.createCommentVNode("v-if", true)
              ];
            }),
            _: 3
            /* FORWARDED */
          }, 16, ["data", "height", "header-cell-style", "size", "row-key"])), [
            [vue.unref(elementPlus.vLoading), _ctx.loadingStatus]
          ]),
          vue.createCommentVNode(" \u5206\u9875 "),
          _ctx.pagination ? (vue.openBlock(), vue.createBlock(vue.unref(PlusPagination), vue.mergeProps({
            key: 1,
            modelValue: vue.unref(subPageInfo),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vue.isRef(subPageInfo) ? subPageInfo.value = $event : null)
          }, _ctx.pagination, { onChange: handlePaginationChange }), vue.createSlots({
            _: 2
            /* DYNAMIC */
          }, [
            _ctx.$slots["pagination-left"] ? {
              name: "pagination-left",
              fn: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "pagination-left")
              ]),
              key: "0"
            } : void 0,
            _ctx.$slots["pagination-right"] ? {
              name: "pagination-right",
              fn: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "pagination-right")
              ]),
              key: "1"
            } : void 0
          ]), 1040, ["modelValue"])) : vue.createCommentVNode("v-if", true)
        ]);
      };
    }
  });

  var Table = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\table\\src\\index.vue"]]);

  const PlusTable = Table;

  var _sfc_main$c = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusDescriptions"
    },
    __name: "index",
    props: {
      data: { type: null, required: true, default: () => ({}) },
      columns: { type: Array, required: false, default: () => [] },
      column: { type: Number, required: false, default: 3 },
      title: { type: String, required: false, default: "" }
    },
    setup(__props) {
      const props = __props;
      const subColumns = vue.computed(
        () => props.columns.filter((item) => vue.unref(item.hideInDescriptions) !== true)
      );
      const getDisplayValue = (prop) => getValue(props.data, prop);
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElDescriptions), vue.mergeProps({
          title: _ctx.title,
          column: _ctx.column,
          class: "plus-description",
          border: ""
        }, _ctx.$attrs), {
          title: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "title")
          ]),
          extra: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "extra")
          ]),
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "default", {}, () => [
              (vue.openBlock(true), vue.createElementBlock(
                vue.Fragment,
                null,
                vue.renderList(subColumns.value, (item) => {
                  var _a, _b;
                  return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElDescriptionsItem), vue.mergeProps({
                    key: item.label,
                    label: item.label,
                    "class-name": (((_a = item.descriptionsItemProps) == null ? void 0 : _a.className) || "") + " plus-description__name",
                    "label-class-name": (((_b = item.descriptionsItemProps) == null ? void 0 : _b.labelClassName) || "") + " plus-description__label"
                  }, item.descriptionsItemProps), {
                    label: vue.withCtx(() => [
                      item.renderDescriptionsLabel && vue.unref(isFunction)(item.renderDescriptionsLabel) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(item.renderDescriptionsLabel), {
                        key: 0,
                        label: item.label,
                        column: item,
                        row: _ctx.data
                      }, null, 8, ["label", "column", "row"])) : _ctx.$slots[vue.unref(getDescLabelSlotName)(item.prop)] ? (vue.openBlock(), vue.createElementBlock(
                        vue.Fragment,
                        { key: 1 },
                        [
                          vue.createCommentVNode(" plus-desc-label-* "),
                          vue.renderSlot(_ctx.$slots, vue.unref(getDescLabelSlotName)(item.prop), {
                            column: item,
                            row: _ctx.data,
                            label: item.label
                          })
                        ],
                        64
                        /* STABLE_FRAGMENT */
                      )) : (vue.openBlock(), vue.createElementBlock(
                        vue.Fragment,
                        { key: 2 },
                        [
                          vue.createCommentVNode(" normal "),
                          vue.createTextVNode(
                            vue.toDisplayString(item.label),
                            1
                            /* TEXT */
                          )
                        ],
                        64
                        /* STABLE_FRAGMENT */
                      ))
                    ]),
                    default: vue.withCtx(() => [
                      item.renderDescriptionsItem && vue.unref(isFunction)(item.renderDescriptionsItem) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(item.renderDescriptionsItem), {
                        key: 0,
                        value: getDisplayValue(item.prop),
                        column: item,
                        row: _ctx.data
                      }, null, 8, ["value", "column", "row"])) : _ctx.$slots[vue.unref(getDescSlotName)(item.prop)] ? (vue.openBlock(), vue.createElementBlock(
                        vue.Fragment,
                        { key: 1 },
                        [
                          vue.createCommentVNode(" plus-desc-* "),
                          vue.renderSlot(_ctx.$slots, vue.unref(getDescSlotName)(item.prop), {
                            column: item,
                            row: _ctx.data,
                            value: getDisplayValue(item.prop)
                          })
                        ],
                        64
                        /* STABLE_FRAGMENT */
                      )) : (vue.openBlock(), vue.createElementBlock(
                        vue.Fragment,
                        { key: 2 },
                        [
                          vue.createCommentVNode(" normal "),
                          vue.createVNode(vue.unref(PlusDisplayItem), {
                            column: item,
                            row: _ctx.data
                          }, null, 8, ["column", "row"])
                        ],
                        64
                        /* STABLE_FRAGMENT */
                      ))
                    ]),
                    _: 2
                    /* DYNAMIC */
                  }, 1040, ["label", "class-name", "label-class-name"]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ])
          ]),
          _: 3
          /* FORWARDED */
        }, 16, ["title", "column"]);
      };
    }
  });

  var Descriptions = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\descriptions\\src\\index.vue"]]);

  const PlusDescriptions = Descriptions;

  var _sfc_main$b = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusSearch"
    },
    __name: "index",
    props: {
      modelValue: { type: null, required: false, default: () => ({}) },
      defaultValues: { type: null, required: false, default: () => ({}) },
      columns: { type: Array, required: false, default: () => [] },
      hasFooter: { type: Boolean, required: false, default: true },
      hasReset: { type: Boolean, required: false, default: true },
      hasUnfold: { type: Boolean, required: false, default: true },
      searchText: { type: String, required: false, default: "" },
      resetText: { type: String, required: false, default: "" },
      searchLoading: { type: Boolean, required: false, default: false },
      inline: { type: Boolean, required: false, default: true },
      showNumber: { type: Number, required: false, default: 2 },
      rowProps: { type: Object, required: false, default: () => ({
        gutter: 20
      }) },
      colProps: { type: Object, required: false, default: () => ({
        xs: 24,
        sm: 12,
        md: 8,
        lg: 8,
        xl: 6
      }) }
    },
    emits: ["update:modelValue", "search", "change", "reset"],
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      const { t } = useLocale();
      const plusFormInstance = vue.ref();
      const state = vue.reactive({
        values: {},
        subColumns: [],
        originData: [],
        isShowUnfold: false
      });
      const slots = vue.useSlots();
      const labelSlots = filterSlots(slots, getLabelSlotName());
      const fieldSlots = filterSlots(slots, getFieldSlotName());
      const extraSlots = filterSlots(slots, getExtraSlotName());
      state.originData = vue.computed(() => {
        return props.columns.filter((item) => vue.unref(item.hideInSearch) !== true).map((item) => ({ ...item, hideInForm: false }));
      });
      state.subColumns = vue.computed(() => {
        const data = cloneDeep(state.originData);
        if (props.hasUnfold && !state.isShowUnfold) {
          return data.slice(0, props.showNumber);
        } else {
          return data;
        }
      });
      vue.watch(
        () => props.modelValue,
        (val) => {
          state.values = val;
        },
        {
          immediate: true
        }
      );
      const handleChange = async (values, column) => {
        emit("change", values, column);
        emit("update:modelValue", values);
      };
      const handleSearch = async () => {
        emit("search", state.values);
      };
      const handleReset = () => {
        state.values = { ...props.defaultValues };
        emit("reset", state.values);
      };
      const handleUnfold = () => {
        state.isShowUnfold = !state.isShowUnfold;
      };
      __expose({
        plusFormInstance,
        handleReset,
        handleSearch,
        handleUnfold
      });
      const { isShowUnfold, subColumns } = vue.toRefs(state);
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(PlusForm), vue.mergeProps({
          ref_key: "plusFormInstance",
          ref: plusFormInstance
        }, _ctx.$attrs, {
          modelValue: state.values,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.values = $event),
          inline: _ctx.inline,
          "row-props": _ctx.rowProps,
          "col-props": _ctx.colProps,
          columns: vue.unref(subColumns),
          class: "plus-search",
          "has-footer": false,
          onChange: handleChange
        }), vue.createSlots({
          "search-footer": vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "footer", {
              isShowUnfold: vue.unref(isShowUnfold),
              handleReset,
              handleSearch,
              handleUnfold
            }, () => [
              _ctx.hasFooter ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElFormItem), {
                key: 0,
                class: "plus-search__button__wrapper"
              }, {
                default: vue.withCtx(() => [
                  _ctx.hasReset ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElButton), {
                    key: 0,
                    icon: vue.unref(refresh_right_default),
                    onClick: handleReset
                  }, {
                    default: vue.withCtx(() => [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.resetText || vue.unref(t)("plus.search.resetText")),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 1
                    /* STABLE */
                  }, 8, ["icon"])) : vue.createCommentVNode("v-if", true),
                  vue.createVNode(vue.unref(elementPlus.ElButton), {
                    type: "primary",
                    loading: _ctx.searchLoading,
                    icon: vue.unref(search_default),
                    onClick: handleSearch
                  }, {
                    default: vue.withCtx(() => [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.searchText || vue.unref(t)("plus.search.searchText")),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 1
                    /* STABLE */
                  }, 8, ["loading", "icon"]),
                  _ctx.hasUnfold && state.originData.length > _ctx.showNumber ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElButton), {
                    key: 1,
                    type: "primary",
                    link: "",
                    onClick: handleUnfold
                  }, {
                    default: vue.withCtx(() => [
                      vue.createTextVNode(
                        vue.toDisplayString(vue.unref(isShowUnfold) ? vue.unref(t)("plus.search.retract") : vue.unref(t)("plus.search.expand")) + " ",
                        1
                        /* TEXT */
                      ),
                      vue.createVNode(vue.unref(elementPlus.ElIcon), null, {
                        default: vue.withCtx(() => [
                          vue.unref(isShowUnfold) ? (vue.openBlock(), vue.createBlock(vue.unref(arrow_up_default), { key: 0 })) : (vue.openBlock(), vue.createBlock(vue.unref(arrow_down_default), { key: 1 }))
                        ]),
                        _: 1
                        /* STABLE */
                      })
                    ]),
                    _: 1
                    /* STABLE */
                  })) : vue.createCommentVNode("v-if", true)
                ]),
                _: 1
                /* STABLE */
              })) : vue.createCommentVNode("v-if", true)
            ])
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          vue.renderList(vue.unref(labelSlots), (_, key) => {
            return {
              name: key,
              fn: vue.withCtx((data) => [
                vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
              ])
            };
          }),
          vue.renderList(vue.unref(fieldSlots), (_, key) => {
            return {
              name: key,
              fn: vue.withCtx((data) => [
                vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
              ])
            };
          }),
          vue.renderList(vue.unref(extraSlots), (_, key) => {
            return {
              name: key,
              fn: vue.withCtx((data) => [
                vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
              ])
            };
          })
        ]), 1040, ["modelValue", "inline", "row-props", "col-props", "columns"]);
      };
    }
  });

  var Search = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\search\\src\\index.vue"]]);

  const PlusSearch = Search;

  var _sfc_main$a = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusDialogForm"
    },
    __name: "index",
    props: {
      modelValue: { type: null, required: false, default: () => ({}) },
      visible: { type: Boolean, required: false, default: false },
      dialog: { type: null, required: false, default: () => ({}) },
      form: { type: null, required: false, default: () => ({}) }
    },
    emits: ["update:modelValue", "update:visible", "confirm", "change", "cancel"],
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      const { t } = useLocale();
      const formInstance = vue.ref();
      const computedFormInstance = vue.computed(() => {
        var _a;
        return (_a = formInstance.value) == null ? void 0 : _a.formInstance;
      });
      const state = vue.ref({});
      const subVisible = vue.ref(false);
      const slots = vue.useSlots();
      const labelSlots = filterSlots(slots, getLabelSlotName());
      const fieldSlots = filterSlots(slots, getFieldSlotName());
      const extraSlots = filterSlots(slots, getExtraSlotName());
      vue.watch(
        () => props.visible,
        (val) => {
          subVisible.value = val;
        },
        {
          immediate: true
        }
      );
      vue.watch(
        () => props.modelValue,
        (val) => {
          state.value = val;
        },
        {
          immediate: true
        }
      );
      const handleChange = (values, column) => {
        emit("update:modelValue", values);
        emit("change", values, column);
      };
      const handleConfirm = async () => {
        var _a;
        try {
          const valid = await ((_a = computedFormInstance.value) == null ? void 0 : _a.validate());
          if (valid) {
            emit("confirm", state.value);
          }
        } catch (error) {
          console.warn(error);
        }
      };
      const handleCancel = () => {
        subVisible.value = false;
        emit("update:visible", subVisible.value);
        emit("cancel");
      };
      __expose({
        handleConfirm,
        handleCancel,
        formInstance: computedFormInstance
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(PlusDialog), vue.mergeProps({
          modelValue: subVisible.value,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => subVisible.value = $event),
          width: "800px",
          top: "10vh",
          title: vue.unref(t)("plus.dialogForm.title")
        }, _ctx.dialog, {
          onCancel: handleCancel,
          onConfirm: handleConfirm
        }), vue.createSlots({
          default: vue.withCtx(() => [
            vue.createVNode(vue.unref(PlusForm), vue.mergeProps({
              ref_key: "formInstance",
              ref: formInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.value = $event),
              "has-footer": false,
              "footer-align": "right"
            }, _ctx.form, { onChange: handleChange }), vue.createSlots({
              _: 2
              /* DYNAMIC */
            }, [
              _ctx.$slots["form-footer"] ? {
                name: "footer",
                fn: vue.withCtx((data) => [
                  vue.renderSlot(_ctx.$slots, "form-footer", vue.normalizeProps(vue.guardReactiveProps(data)))
                ]),
                key: "0"
              } : void 0,
              _ctx.$slots["form-group-header"] ? {
                name: "group-header",
                fn: vue.withCtx((data) => [
                  vue.renderSlot(_ctx.$slots, "form-group-header", vue.normalizeProps(vue.guardReactiveProps(data)))
                ]),
                key: "1"
              } : void 0,
              vue.renderList(vue.unref(labelSlots), (_, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                  ])
                };
              }),
              vue.renderList(vue.unref(fieldSlots), (_, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                  ])
                };
              }),
              vue.renderList(vue.unref(extraSlots), (_, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                  ])
                };
              })
            ]), 1040, ["modelValue"])
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          _ctx.$slots["dialog-header"] ? {
            name: "header",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "dialog-header")
            ]),
            key: "0"
          } : void 0,
          _ctx.$slots["dialog-footer"] ? {
            name: "footer",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "dialog-footer", vue.normalizeProps(vue.guardReactiveProps({ handleConfirm, handleCancel })))
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["modelValue", "title"]);
      };
    }
  });

  var DialogForm = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\dialog-form\\src\\index.vue"]]);

  const PlusDialogForm = DialogForm;

  var _sfc_main$9 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusDrawerForm"
    },
    __name: "index",
    props: {
      modelValue: { type: null, required: false, default: () => ({}) },
      visible: { type: Boolean, required: false, default: false },
      drawer: { type: null, required: false, default: () => ({}) },
      size: { type: [String, Number], required: false, default: "540px" },
      form: { type: null, required: false, default: () => ({}) }
    },
    emits: ["update:modelValue", "update:visible", "submit", "change", "cancel", "reset"],
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      const { t } = useLocale();
      const formInstance = vue.ref();
      const computedFormInstance = vue.computed(() => {
        var _a;
        return (_a = formInstance.value) == null ? void 0 : _a.formInstance;
      });
      const drawerInstance = vue.ref();
      const state = vue.ref({});
      const subVisible = vue.ref(false);
      const slots = vue.useSlots();
      const labelSlots = filterSlots(slots, getLabelSlotName());
      const fieldSlots = filterSlots(slots, getFieldSlotName());
      const extraSlots = filterSlots(slots, getExtraSlotName());
      vue.watch(
        () => props.visible,
        (val) => {
          subVisible.value = val;
        },
        {
          immediate: true
        }
      );
      vue.watch(
        () => props.modelValue,
        (val) => {
          state.value = val;
        },
        {
          immediate: true
        }
      );
      const handleChange = (values, column) => {
        emit("update:modelValue", values);
        emit("change", values, column);
      };
      const handleSubmitForm = () => {
        emit("submit", state.value);
      };
      const handleCancel = () => {
        subVisible.value = false;
        emit("update:visible", subVisible.value);
        emit("cancel");
      };
      const handleReset = () => {
        emit("reset");
      };
      __expose({
        drawerInstance,
        formInstance: computedFormInstance
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElDrawer), vue.mergeProps({
          ref_key: "drawerInstance",
          ref: drawerInstance,
          modelValue: subVisible.value,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => subVisible.value = $event),
          size: _ctx.size || "540px",
          title: vue.unref(t)("plus.drawerForm.title"),
          "close-on-click-modal": false,
          "close-on-press-escape": false
        }, _ctx.drawer, { onClose: handleCancel }), vue.createSlots({
          default: vue.withCtx(() => [
            vue.createVNode(vue.unref(PlusForm), vue.mergeProps({
              ref_key: "formInstance",
              ref: formInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.value = $event),
              "footer-align": "right"
            }, _ctx.form, {
              onSubmit: handleSubmitForm,
              onChange: handleChange,
              onReset: handleReset
            }), vue.createSlots({
              _: 2
              /* DYNAMIC */
            }, [
              _ctx.$slots["form-footer"] ? {
                name: "footer",
                fn: vue.withCtx(() => [
                  vue.renderSlot(_ctx.$slots, "form-footer")
                ]),
                key: "0"
              } : void 0,
              _ctx.$slots["form-group-header"] ? {
                name: "group-header",
                fn: vue.withCtx(() => [
                  vue.renderSlot(_ctx.$slots, "form-group-header")
                ]),
                key: "1"
              } : void 0,
              vue.renderList(vue.unref(labelSlots), (_, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                  ])
                };
              }),
              vue.renderList(vue.unref(fieldSlots), (_, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                  ])
                };
              }),
              vue.renderList(vue.unref(extraSlots), (_, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                  ])
                };
              })
            ]), 1040, ["modelValue"])
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          _ctx.$slots["drawer-header"] ? {
            name: "header",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "drawer-header")
            ]),
            key: "0"
          } : void 0,
          _ctx.$slots["drawer-footer"] ? {
            name: "footer",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "drawer-footer")
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["modelValue", "size", "title"]);
      };
    }
  });

  var DrawerForm = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\drawer-form\\src\\index.vue"]]);

  const PlusDrawerForm = DrawerForm;

  const _hoisted_1$4 = { class: "plus-page" };
  var _sfc_main$8 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusPage"
    },
    __name: "index",
    props: {
      columns: { type: Array, required: true, default: () => [] },
      request: { type: Function, required: true },
      search: { type: [Boolean, Object], required: false, default: () => ({}) },
      table: { type: Object, required: false, default: () => ({}) },
      params: { type: null, required: false, default: () => ({}) },
      postData: { type: Function, required: false, default: void 0 },
      beforeSearchSubmit: { type: Function, required: false, default: void 0 },
      isCard: { type: Boolean, required: false, default: true },
      searchCardProps: { type: Object, required: false, default: () => ({}) },
      tableCardProps: { type: Object, required: false, default: () => ({}) },
      defaultPageInfo: { type: null, required: false, default: () => ({ ...DefaultPageInfo }) },
      defaultPageSizeList: { type: Array, required: false, default: () => DefaultPageSizeList },
      pagination: { type: null, required: false, default: () => ({}) }
    },
    emits: ["requestError", "search", "reset", "paginationChange"],
    setup(__props, { expose: __expose, emit }) {
      var _a;
      const props = __props;
      const PlusSearch$1 = PlusSearch;
      const PlusTable$1 = PlusTable;
      const computedDefaultPageInfo = vue.computed(() => props.defaultPageInfo);
      const computedDefaultPageSizeList = vue.computed(() => props.defaultPageSizeList);
      const { tableData, pageInfo, total, loadingStatus } = useTable(computedDefaultPageInfo);
      const plusSearchInstance = vue.ref();
      const plusTableInstance = vue.ref();
      const state = vue.reactive({
        params: { ...(_a = props.search) == null ? void 0 : _a.defaultValues },
        values: {}
      });
      const slots = vue.useSlots();
      const cellSlots = filterSlots(slots, getTableCellSlotName());
      const headerSlots = filterSlots(slots, getTableHeaderSlotName());
      const fieldSlots = filterSlots(slots, getFieldSlotName());
      const renderWrapper = () => {
        if (props.isCard) {
          return {
            search: vue.h(elementPlus.ElCard, props.searchCardProps),
            table: vue.h(elementPlus.ElCard, props.tableCardProps)
          };
        }
        return { search: vue.h("div"), table: vue.h("div") };
      };
      const getList = async () => {
        if (!props.request)
          return;
        try {
          loadingStatus.value = true;
          const { data, total: dataTotal } = await props.request({
            ...state.params,
            ...pageInfo.value,
            ...props.params
          });
          const list = props.postData && props.postData(data) || data;
          tableData.value = list || [];
          total.value = dataTotal || list.length;
        } catch (error) {
          emit("requestError", error);
        }
        loadingStatus.value = false;
      };
      getList();
      const handlePaginationChange = (_pageInfo) => {
        pageInfo.value = _pageInfo;
        getList();
        emit("paginationChange", _pageInfo);
      };
      const handleSearch = (values) => {
        const data = props.beforeSearchSubmit && props.beforeSearchSubmit(values) || values;
        state.params = data;
        getList();
        emit("search", state.params);
      };
      const handleRest = (values) => {
        state.params = { ...values };
        pageInfo.value.page = 1;
        getList();
        emit("reset", state.params);
      };
      const handleRefresh = () => {
        getList();
      };
      __expose({
        plusSearchInstance,
        plusTableInstance,
        getList,
        handleRest
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$4, [
          _ctx.search ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(renderWrapper().search), { key: 0 }, {
            default: vue.withCtx(() => [
              vue.createVNode(vue.unref(PlusSearch$1), vue.mergeProps({
                ref_key: "plusSearchInstance",
                ref: plusSearchInstance
              }, _ctx.search, {
                modelValue: state.params,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.params = $event),
                columns: _ctx.columns,
                "search-loading": vue.unref(loadingStatus),
                onSearch: handleSearch,
                onReset: handleRest
              }), vue.createSlots({
                _: 2
                /* DYNAMIC */
              }, [
                _ctx.$slots["search-footer"] ? {
                  name: "footer",
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, "search-footer", vue.normalizeProps(vue.guardReactiveProps(data)))
                  ]),
                  key: "0"
                } : void 0
              ]), 1040, ["modelValue", "columns", "search-loading"])
            ]),
            _: 3
            /* FORWARDED */
          })) : vue.createCommentVNode("v-if", true),
          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(renderWrapper().table), { class: "plus-page__table_wrapper" }, {
            default: vue.withCtx(() => [
              vue.createVNode(vue.unref(PlusTable$1), vue.mergeProps({
                ref_key: "plusTableInstance",
                ref: plusTableInstance,
                "title-bar": { refresh: true }
              }, _ctx.table, {
                "table-data": vue.unref(tableData),
                "loading-status": vue.unref(loadingStatus),
                columns: _ctx.columns,
                pagination: {
                  ..._ctx.pagination,
                  total: vue.unref(total),
                  modelValue: vue.unref(pageInfo),
                  pageSizeList: computedDefaultPageSizeList.value
                },
                onPaginationChange: handlePaginationChange,
                onRefresh: handleRefresh
              }), vue.createSlots({
                _: 2
                /* DYNAMIC */
              }, [
                vue.renderList(vue.unref(headerSlots), (_, key) => {
                  return {
                    name: key,
                    fn: vue.withCtx((data) => [
                      vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                    ])
                  };
                }),
                vue.renderList(vue.unref(cellSlots), (_, key) => {
                  return {
                    name: key,
                    fn: vue.withCtx((data) => [
                      vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                    ])
                  };
                }),
                vue.renderList(vue.unref(fieldSlots), (_, key) => {
                  return {
                    name: key,
                    fn: vue.withCtx((data) => [
                      vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                    ])
                  };
                }),
                _ctx.$slots["table-title"] ? {
                  name: "title",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "table-title")
                  ]),
                  key: "0"
                } : void 0,
                _ctx.$slots["table-toolbar"] ? {
                  name: "toolbar",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "table-toolbar")
                  ]),
                  key: "1"
                } : void 0,
                _ctx.$slots["table-expand"] ? {
                  name: "expand",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "table-expand")
                  ]),
                  key: "2"
                } : void 0,
                _ctx.$slots["table-append"] ? {
                  name: "append",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "table-append")
                  ]),
                  key: "3"
                } : void 0,
                _ctx.$slots["table-empty"] ? {
                  name: "empty",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "table-empty")
                  ]),
                  key: "4"
                } : void 0
              ]), 1040, ["table-data", "loading-status", "columns", "pagination"])
            ]),
            _: 3
            /* FORWARDED */
          }))
        ]);
      };
    }
  });

  var Page = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\page\\src\\index.vue"]]);

  const PlusPage = Page;

  var _sfc_main$7 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusStepsForm"
    },
    __name: "index",
    props: {
      modelValue: { type: Number, required: true, default: 1 },
      data: { type: Array, required: true, default: () => [] }
    },
    emits: ["pre", "next", "update:modelValue", "change"],
    setup(__props, { emit }) {
      const props = __props;
      const { t } = useLocale();
      const active = vue.ref(cloneDeep(props.modelValue));
      const handleChange = (values, column) => {
        emit("change", values, column);
      };
      const pre = () => {
        if (active.value-- > props.data.length + 1)
          active.value = 1;
        emit("pre", active.value);
        emit("update:modelValue", active.value);
      };
      const next = (values) => {
        if (active.value++ > props.data.length - 1)
          active.value = props.data.length;
        emit("next", active.value, values);
        emit("update:modelValue", active.value);
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(["plus-steps-form", _ctx.$attrs.direction === "vertical" ? "plus-steps-from-vertical" : ""])
          },
          [
            vue.createVNode(vue.unref(elementPlus.ElSteps), vue.mergeProps({
              active: active.value,
              "finish-status": "success"
            }, _ctx.$attrs), {
              default: vue.withCtx(() => [
                (vue.openBlock(true), vue.createElementBlock(
                  vue.Fragment,
                  null,
                  vue.renderList(_ctx.data, (item) => {
                    return vue.openBlock(), vue.createBlock(
                      vue.unref(elementPlus.ElStep),
                      vue.mergeProps({
                        key: item.title
                      }, item),
                      vue.createSlots({
                        _: 2
                        /* DYNAMIC */
                      }, [
                        _ctx.$slots.icon ? {
                          name: "icon",
                          fn: vue.withCtx(() => [
                            vue.renderSlot(_ctx.$slots, "icon", {
                              icon: item.icon,
                              title: item.title,
                              description: item.description
                            })
                          ]),
                          key: "0"
                        } : void 0,
                        _ctx.$slots.title ? {
                          name: "title",
                          fn: vue.withCtx(() => [
                            vue.renderSlot(_ctx.$slots, "title", {
                              icon: item.icon,
                              title: item.title,
                              description: item.description
                            })
                          ]),
                          key: "1"
                        } : void 0,
                        _ctx.$slots.description ? {
                          name: "description",
                          fn: vue.withCtx(() => [
                            vue.renderSlot(_ctx.$slots, "description", {
                              icon: item.icon,
                              title: item.title,
                              description: item.description
                            })
                          ]),
                          key: "2"
                        } : void 0
                      ]),
                      1040
                      /* FULL_PROPS, DYNAMIC_SLOTS */
                    );
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ]),
              _: 3
              /* FORWARDED */
            }, 16, ["active"]),
            vue.createVNode(vue.unref(PlusForm), vue.mergeProps(_ctx.data[active.value - 1].form, {
              "has-reset": active.value !== 1,
              "submit-text": active.value === _ctx.data.length ? vue.unref(t)("plus.stepsForm.submitText") : vue.unref(t)("plus.stepsForm.nextText"),
              "reset-text": vue.unref(t)("plus.stepsForm.preText"),
              onSubmit: next,
              onReset: pre,
              onChange: handleChange
            }), null, 16, ["has-reset", "submit-text", "reset-text"])
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  var StepsForm = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\steps-form\\src\\index.vue"]]);

  const PlusStepsForm = StepsForm;

  var _sfc_main$6 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusBreadcrumb"
    },
    __name: "index",
    props: {
      routes: { type: Array, required: false, default: () => [] },
      replace: { type: Boolean, required: false, default: false },
      renderTitle: { type: Function, required: false }
    },
    setup(__props) {
      const props = __props;
      const instance = vue.getCurrentInstance();
      const route = vue.computed(
        () => instance.appContext.config.globalProperties.$route
      );
      const breadcrumbList = vue.ref([]);
      vue.watchEffect(() => {
        var _a;
        const breadcrumb = ((_a = props.routes) == null ? void 0 : _a.length) ? props.routes : route.value ? route.value.matched : [];
        breadcrumbList.value = breadcrumb.filter((item) => {
          var _a2;
          return ((_a2 = item.meta) == null ? void 0 : _a2.hideInBreadcrumb) !== true;
        });
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(
          vue.unref(elementPlus.ElBreadcrumb),
          vue.mergeProps(_ctx.$attrs, { class: "plus-breadcrumb" }),
          {
            default: vue.withCtx(() => [
              (vue.openBlock(true), vue.createElementBlock(
                vue.Fragment,
                null,
                vue.renderList(breadcrumbList.value, (item) => {
                  return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElBreadcrumbItem), {
                    key: item.path,
                    class: "plus-breadcrumb-item",
                    to: item.redirect || item.path,
                    replace: _ctx.replace
                  }, {
                    default: vue.withCtx(() => {
                      var _a;
                      return [
                        _ctx.renderTitle && vue.unref(isFunction)(_ctx.renderTitle) ? (vue.openBlock(), vue.createBlock(
                          vue.resolveDynamicComponent(_ctx.renderTitle),
                          vue.normalizeProps(vue.mergeProps({ key: 0 }, item)),
                          null,
                          16
                          /* FULL_PROPS */
                        )) : _ctx.$slots["breadcrumb-item-title"] ? (vue.openBlock(), vue.createElementBlock(
                          vue.Fragment,
                          { key: 1 },
                          [
                            vue.createCommentVNode(" \u9762\u5305\u5C51title \u63D2\u69FD "),
                            vue.renderSlot(_ctx.$slots, "breadcrumb-item-title", vue.normalizeProps(vue.guardReactiveProps(item)))
                          ],
                          2112
                          /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                        )) : (vue.openBlock(), vue.createElementBlock(
                          vue.Fragment,
                          { key: 2 },
                          [
                            vue.createTextVNode(
                              vue.toDisplayString(((_a = item.meta) == null ? void 0 : _a.title) || item.name || item.path),
                              1
                              /* TEXT */
                            )
                          ],
                          64
                          /* STABLE_FRAGMENT */
                        ))
                      ];
                    }),
                    _: 2
                    /* DYNAMIC */
                  }, 1032, ["to", "replace"]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ]),
            _: 3
            /* FORWARDED */
          },
          16
          /* FULL_PROPS */
        );
      };
    }
  });

  var Breadcrumb = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\breadcrumb\\src\\index.vue"]]);

  const PlusBreadcrumb = Breadcrumb;

  const _hoisted_1$3 = { class: "plus-sidebar__item-title" };
  const _hoisted_2$2 = { class: "plus-sidebar__item-title" };
  var _sfc_main$5 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusSidebarItem"
    },
    __name: "sidebar-item",
    props: {
      item: { type: null, required: true },
      collapse: { type: Boolean, required: false, default: false },
      renderMenuItem: { type: Function, required: false, default: void 0 },
      renderSubMenuItem: { type: Function, required: false, default: void 0 },
      renderTitle: { type: Function, required: false, default: void 0 }
    },
    setup(__props) {
      const instance = vue.getCurrentInstance();
      const router = instance.appContext.config.globalProperties.$router;
      const resolveMenuItem = (item) => {
        var _a;
        if (!((_a = item.children) == null ? void 0 : _a.length))
          return true;
        const children = item.children.filter((i) => {
          var _a2;
          return ((_a2 = i.meta) == null ? void 0 : _a2.hideInMenu) !== true;
        });
        if (!children.length) {
          return true;
        }
        return false;
      };
      const replacePath = (path) => path.replace("/http", "http");
      const getIndex = (item) => {
        return item.redirect || item.path;
      };
      const handleClickItem = (item) => {
        if (isUrl(replacePath(item.path))) {
          const url = replacePath(item.path);
          window.open(url);
        } else {
          router && router.push(getIndex(item));
        }
      };
      return (_ctx, _cache) => {
        var _a, _b;
        const _component_PlusSidebarItem = vue.resolveComponent("PlusSidebarItem");
        return ((_a = _ctx.item.meta) == null ? void 0 : _a.hideInMenu) !== true ? (vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          { key: 0 },
          [
            vue.createCommentVNode(" \u6CA1\u6709\u5B50\u83DC\u5355\u7684\u60C5\u51B5 "),
            resolveMenuItem(_ctx.item) ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElMenuItem), {
              key: getIndex(_ctx.item),
              class: "plus-sidebar__item",
              index: getIndex(_ctx.item),
              disabled: (_b = _ctx.item.meta) == null ? void 0 : _b.disabled,
              onClick: _cache[0] || (_cache[0] = ($event) => handleClickItem(_ctx.item))
            }, {
              title: vue.withCtx(() => {
                var _a2;
                return [
                  vue.createElementVNode("span", _hoisted_1$3, [
                    _ctx.renderTitle && vue.unref(isFunction)(_ctx.renderTitle) ? (vue.openBlock(), vue.createBlock(
                      vue.resolveDynamicComponent(_ctx.renderTitle),
                      vue.normalizeProps(vue.mergeProps({ key: 0 }, _ctx.item)),
                      null,
                      16
                      /* FULL_PROPS */
                    )) : _ctx.$slots["sidebar-item-title"] ? (vue.openBlock(), vue.createElementBlock(
                      vue.Fragment,
                      { key: 1 },
                      [
                        vue.createCommentVNode(" menu-item title \u63D2\u69FD "),
                        vue.renderSlot(_ctx.$slots, "sidebar-item-title", vue.normalizeProps(vue.guardReactiveProps(_ctx.item)))
                      ],
                      2112
                      /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                    )) : (vue.openBlock(), vue.createElementBlock(
                      vue.Fragment,
                      { key: 2 },
                      [
                        vue.createTextVNode(
                          vue.toDisplayString(((_a2 = _ctx.item.meta) == null ? void 0 : _a2.title) || _ctx.item.name || _ctx.item.path),
                          1
                          /* TEXT */
                        )
                      ],
                      64
                      /* STABLE_FRAGMENT */
                    ))
                  ])
                ];
              }),
              default: vue.withCtx(() => [
                _ctx.renderMenuItem && vue.unref(isFunction)(_ctx.renderMenuItem) ? (vue.openBlock(), vue.createBlock(
                  vue.resolveDynamicComponent(_ctx.renderMenuItem),
                  vue.normalizeProps(vue.mergeProps({ key: 0 }, _ctx.item)),
                  null,
                  16
                  /* FULL_PROPS */
                )) : _ctx.$slots["sidebar-item"] ? (vue.openBlock(), vue.createElementBlock(
                  vue.Fragment,
                  { key: 1 },
                  [
                    vue.createCommentVNode(" menu-item \u63D2\u69FD "),
                    vue.renderSlot(_ctx.$slots, "sidebar-item", vue.normalizeProps(vue.guardReactiveProps(_ctx.item)))
                  ],
                  2112
                  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                )) : _ctx.item.meta && _ctx.item.meta.icon ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElIcon), {
                  key: 2,
                  class: "plus-sidebar__item-icon"
                }, {
                  default: vue.withCtx(() => [
                    (vue.openBlock(), vue.createBlock(
                      vue.resolveDynamicComponent(_ctx.item.meta.icon),
                      vue.normalizeProps(vue.guardReactiveProps(_ctx.item)),
                      null,
                      16
                      /* FULL_PROPS */
                    ))
                  ]),
                  _: 1
                  /* STABLE */
                })) : vue.createCommentVNode("v-if", true)
              ]),
              _: 3
              /* FORWARDED */
            }, 8, ["index", "disabled"])) : (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 1 },
              [
                vue.createCommentVNode(" \u6709\u5B50\u83DC\u5355\u7684\u60C5\u51B5 "),
                (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElSubMenu), {
                  key: getIndex(_ctx.item),
                  index: getIndex(_ctx.item),
                  class: "plus-sidebar__item-sub"
                }, {
                  title: vue.withCtx(() => {
                    var _a2, _b2;
                    return [
                      vue.createCommentVNode(" \u81EA\u5B9A\u4E49\u663E\u793A "),
                      _ctx.renderSubMenuItem && vue.unref(isFunction)(_ctx.renderSubMenuItem) ? (vue.openBlock(), vue.createBlock(
                        vue.resolveDynamicComponent(_ctx.renderSubMenuItem),
                        vue.normalizeProps(vue.mergeProps({ key: 0 }, _ctx.item)),
                        null,
                        16
                        /* FULL_PROPS */
                      )) : _ctx.$slots["sidebar-sub"] ? (vue.openBlock(), vue.createElementBlock(
                        vue.Fragment,
                        { key: 1 },
                        [
                          vue.createCommentVNode(" sub-menu \u63D2\u69FD "),
                          vue.renderSlot(_ctx.$slots, "sidebar-sub", vue.normalizeProps(vue.guardReactiveProps(_ctx.item)))
                        ],
                        2112
                        /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                      )) : ((_a2 = _ctx.item.meta) == null ? void 0 : _a2.icon) ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElIcon), {
                        key: 2,
                        class: "plus-sidebar__item-icon"
                      }, {
                        default: vue.withCtx(() => {
                          var _a3;
                          return [
                            (vue.openBlock(), vue.createBlock(
                              vue.resolveDynamicComponent((_a3 = _ctx.item.meta) == null ? void 0 : _a3.icon),
                              vue.normalizeProps(vue.guardReactiveProps(_ctx.item)),
                              null,
                              16
                              /* FULL_PROPS */
                            ))
                          ];
                        }),
                        _: 1
                        /* STABLE */
                      })) : vue.createCommentVNode("v-if", true),
                      vue.createElementVNode("span", _hoisted_2$2, [
                        _ctx.renderTitle && vue.unref(isFunction)(_ctx.renderTitle) ? (vue.openBlock(), vue.createBlock(
                          vue.resolveDynamicComponent(_ctx.renderTitle),
                          vue.normalizeProps(vue.mergeProps({ key: 0 }, _ctx.item)),
                          null,
                          16
                          /* FULL_PROPS */
                        )) : _ctx.$slots["sidebar-item-title"] ? (vue.openBlock(), vue.createElementBlock(
                          vue.Fragment,
                          { key: 1 },
                          [
                            vue.createCommentVNode(" sub-menu title \u63D2\u69FD "),
                            vue.renderSlot(_ctx.$slots, "sidebar-item-title", vue.normalizeProps(vue.guardReactiveProps(_ctx.item)))
                          ],
                          2112
                          /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                        )) : (vue.openBlock(), vue.createElementBlock(
                          vue.Fragment,
                          { key: 2 },
                          [
                            vue.createTextVNode(
                              vue.toDisplayString(((_b2 = _ctx.item.meta) == null ? void 0 : _b2.title) || _ctx.item.name || _ctx.item.path),
                              1
                              /* TEXT */
                            )
                          ],
                          64
                          /* STABLE_FRAGMENT */
                        ))
                      ])
                    ];
                  }),
                  default: vue.withCtx(() => [
                    (vue.openBlock(true), vue.createElementBlock(
                      vue.Fragment,
                      null,
                      vue.renderList(_ctx.item.children, (child) => {
                        return vue.openBlock(), vue.createBlock(_component_PlusSidebarItem, {
                          key: child.path,
                          item: child,
                          collapse: _ctx.collapse,
                          "render-menu-item": _ctx.renderMenuItem,
                          "render-sub-menu-item": _ctx.renderSubMenuItem,
                          "render-title": _ctx.renderTitle
                        }, vue.createSlots({
                          _: 2
                          /* DYNAMIC */
                        }, [
                          _ctx.$slots["sidebar-item"] ? {
                            name: "sidebar-item",
                            fn: vue.withCtx((data) => [
                              vue.renderSlot(_ctx.$slots, "sidebar-item", vue.normalizeProps(vue.guardReactiveProps(data)))
                            ]),
                            key: "0"
                          } : void 0,
                          _ctx.$slots["sidebar-sub"] ? {
                            name: "sidebar-sub",
                            fn: vue.withCtx((data) => [
                              vue.renderSlot(_ctx.$slots, "sidebar-sub", vue.normalizeProps(vue.guardReactiveProps(data)))
                            ]),
                            key: "1"
                          } : void 0,
                          _ctx.$slots["sidebar-item-title"] ? {
                            name: "sidebar-item-title",
                            fn: vue.withCtx((data) => [
                              vue.renderSlot(_ctx.$slots, "sidebar-item-title", vue.normalizeProps(vue.guardReactiveProps(data)))
                            ]),
                            key: "2"
                          } : void 0
                        ]), 1032, ["item", "collapse", "render-menu-item", "render-sub-menu-item", "render-title"]);
                      }),
                      128
                      /* KEYED_FRAGMENT */
                    ))
                  ]),
                  _: 3
                  /* FORWARDED */
                }, 8, ["index"]))
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            ))
          ],
          64
          /* STABLE_FRAGMENT */
        )) : vue.createCommentVNode("v-if", true);
      };
    }
  });

  var SidebarItem = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\sidebar\\src\\sidebar-item.vue"]]);

  var _sfc_main$4 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusSidebar"
    },
    __name: "index",
    props: {
      routes: { type: Array, required: false, default: () => [] },
      collapse: { type: Boolean, required: false, default: false },
      defaultActive: { type: null, required: false, default: void 0 },
      renderMenuItem: { type: Function, required: false, default: void 0 },
      renderSubMenuItem: { type: Function, required: false, default: void 0 },
      renderTitle: { type: Function, required: false, default: void 0 },
      renderMenuExtra: { type: Function, required: false, default: void 0 },
      scrollbarProps: { type: Object, required: false, default: () => ({}) },
      width: { type: [Number, String], required: false, default: 200 }
    },
    emits: ["update:collapse", "toggleCollapse"],
    setup(__props, { expose: __expose, emit }) {
      const props = __props;
      const w = vue.computed(() => isString(props.width) ? props.width : props.width + "px");
      const instance = vue.getCurrentInstance();
      const route = vue.computed(
        () => instance.appContext.config.globalProperties.$route
      );
      const plusSidebarInstance = vue.ref(null);
      const subCollapse = vue.ref(false);
      const subRoutes = vue.computed(
        () => cloneDeep(props.routes).sort((a, b) => {
          var _a, _b;
          return (((_a = a.meta) == null ? void 0 : _a.sort) || 0) - (((_b = b.meta) == null ? void 0 : _b.sort) || 0);
        })
      );
      const computedDefaultActive = vue.computed(
        () => {
          var _a, _b, _c, _d;
          return ((_a = route.value) == null ? void 0 : _a.redirectedFrom) && ((_c = (_b = route.value) == null ? void 0 : _b.redirectedFrom) == null ? void 0 : _c.path) || ((_d = route.value) == null ? void 0 : _d.path);
        }
      );
      const subDefaultActive = vue.computed(
        () => vue.unref(props.defaultActive) || computedDefaultActive.value
      );
      const toggleCollapse = () => {
        subCollapse.value = !subCollapse.value;
        emit("update:collapse", subCollapse.value);
        emit("toggleCollapse", subCollapse.value);
      };
      vue.watchEffect(() => {
        subCollapse.value = props.collapse;
      });
      __expose({
        collapse: subCollapse,
        toggleCollapse,
        plusSidebarInstance
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElMenu), vue.mergeProps({
          ref_key: "plusSidebarInstance",
          ref: plusSidebarInstance,
          style: {
            "--plus-sidebar-width": w.value
          },
          mode: "vertical",
          collapse: subCollapse.value,
          "default-active": subDefaultActive.value,
          "collapse-transition": true,
          class: ["plus-sidebar", [_ctx.$attrs.mode === "horizontal" ? "is-horizontal" : "is-vertical"]],
          ellipsis: false,
          "unique-opened": ""
        }, _ctx.$attrs), {
          default: vue.withCtx(() => [
            _ctx.renderMenuExtra && vue.unref(isFunction)(_ctx.renderMenuExtra) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.renderMenuExtra), { key: 0 })) : _ctx.$slots["sidebar-extra"] ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 1 },
              [
                vue.createCommentVNode(" \u83DC\u5355\u5934\u63D2\u69FD "),
                vue.renderSlot(_ctx.$slots, "sidebar-extra")
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : vue.createCommentVNode("v-if", true),
            vue.createVNode(
              vue.unref(elementPlus.ElScrollbar),
              vue.mergeProps({ class: "plus-sidebar__scrollbar" }, _ctx.scrollbarProps),
              {
                default: vue.withCtx(() => [
                  vue.createCommentVNode(" \u6DFB\u52A0\u9012\u5F52\u7EC4\u4EF6\uFF0C\u7528\u6765\u751F\u6210\u591A\u7EA7\u83DC\u5355 "),
                  (vue.openBlock(true), vue.createElementBlock(
                    vue.Fragment,
                    null,
                    vue.renderList(subRoutes.value, (item) => {
                      return vue.openBlock(), vue.createBlock(SidebarItem, {
                        key: item.path,
                        item,
                        collapse: subCollapse.value,
                        "render-menu-item": _ctx.renderMenuItem,
                        "render-sub-menu-item": _ctx.renderSubMenuItem,
                        "render-title": _ctx.renderTitle
                      }, vue.createSlots({
                        _: 2
                        /* DYNAMIC */
                      }, [
                        _ctx.$slots["sidebar-item"] ? {
                          name: "sidebar-item",
                          fn: vue.withCtx((data) => [
                            vue.renderSlot(_ctx.$slots, "sidebar-item", vue.normalizeProps(vue.guardReactiveProps(data)))
                          ]),
                          key: "0"
                        } : void 0,
                        _ctx.$slots["sidebar-sub"] ? {
                          name: "sidebar-sub",
                          fn: vue.withCtx((data) => [
                            vue.renderSlot(_ctx.$slots, "sidebar-sub", vue.normalizeProps(vue.guardReactiveProps(data)))
                          ]),
                          key: "1"
                        } : void 0,
                        _ctx.$slots["sidebar-item-title"] ? {
                          name: "sidebar-item-title",
                          fn: vue.withCtx((data) => [
                            vue.renderSlot(_ctx.$slots, "sidebar-item-title", vue.normalizeProps(vue.guardReactiveProps(data)))
                          ]),
                          key: "2"
                        } : void 0
                      ]), 1032, ["item", "collapse", "render-menu-item", "render-sub-menu-item", "render-title"]);
                    }),
                    128
                    /* KEYED_FRAGMENT */
                  ))
                ]),
                _: 3
                /* FORWARDED */
              },
              16
              /* FULL_PROPS */
            ),
            _ctx.$attrs.mode !== "horizontal" ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElMenuItem), {
              key: 2,
              class: vue.normalizeClass(["plus-sidebar__collapse", subCollapse.value ? "is-collapse" : ""]),
              onClick: toggleCollapse
            }, {
              default: vue.withCtx(() => [
                _ctx.collapse ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElIcon), { key: 0 }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(expand_default))
                  ]),
                  _: 1
                  /* STABLE */
                })) : (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElIcon), { key: 1 }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(fold_default))
                  ]),
                  _: 1
                  /* STABLE */
                }))
              ]),
              _: 1
              /* STABLE */
            }, 8, ["class"])) : vue.createCommentVNode("v-if", true)
          ]),
          _: 3
          /* FORWARDED */
        }, 16, ["style", "collapse", "default-active", "class"]);
      };
    }
  });

  var Sidebar = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\sidebar\\src\\index.vue"]]);

  const PlusSidebar = Sidebar;
  const PlusSidebarItem = SidebarItem;

  const _hoisted_1$2 = { class: "plus-header__left" };
  const _hoisted_2$1 = ["src"];
  const _hoisted_3$1 = {
    key: 1,
    class: "plus-header__title"
  };
  const _hoisted_4$1 = /* @__PURE__ */ vue.createElementVNode(
    "div",
    { class: "plus-header__placeholder" },
    null,
    -1
    /* HOISTED */
  );
  const _hoisted_5$1 = { class: "plus-header__right" };
  const _hoisted_6$1 = { class: "plus-header__dropdown-area" };
  const _hoisted_7 = ["src"];
  const _hoisted_8 = { class: "plus-header__username" };
  const _hoisted_9 = {
    key: 0,
    class: "plus-header-placeholder"
  };
  var _sfc_main$3 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusHeader"
    },
    __name: "index",
    props: {
      logo: { type: String, required: false, default: "https://plus-pro-components.com/logo.png" },
      fixed: { type: Boolean, required: false, default: false },
      title: { type: String, required: false, default: "PlusProComponents" },
      logoutText: { type: String, required: false, default: "" },
      trigger: { type: String, required: false, default: "click" },
      userInfo: { type: Object, required: false, default: () => ({}) },
      hasUserInfo: { type: Boolean, required: false, default: true },
      dropdownList: { type: Array, required: false, default: () => [] },
      renderHeaderLeft: { type: Function, required: false },
      renderHeaderRight: { type: Function, required: false }
    },
    emits: ["clickDropdownItem"],
    setup(__props, { emit }) {
      const props = __props;
      const { t } = useLocale();
      const logoutItem = {
        label: props.logoutText || t("plus.header.logout"),
        value: "logout"
      };
      const handleClickItem = (item) => {
        emit("clickDropdownItem", item);
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          null,
          [
            vue.createVNode(vue.unref(elementPlus.ElHeader), {
              class: vue.normalizeClass(["plus-header", { "is-fixed": _ctx.fixed }])
            }, {
              default: vue.withCtx(() => [
                vue.createElementVNode("div", _hoisted_1$2, [
                  _ctx.renderHeaderLeft && vue.unref(isFunction)(_ctx.renderHeaderLeft) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.renderHeaderLeft), {
                    key: 0,
                    logo: _ctx.logo,
                    title: _ctx.title
                  }, null, 8, ["logo", "title"])) : _ctx.$slots["header-left"] ? vue.renderSlot(_ctx.$slots, "header-left", {
                    key: 1,
                    logo: _ctx.logo,
                    title: _ctx.title
                  }) : (vue.openBlock(), vue.createElementBlock(
                    vue.Fragment,
                    { key: 2 },
                    [
                      _ctx.logo ? (vue.openBlock(), vue.createElementBlock("img", {
                        key: 0,
                        src: _ctx.logo,
                        alt: "",
                        class: "plus-header__logo"
                      }, null, 8, _hoisted_2$1)) : vue.createCommentVNode("v-if", true),
                      _ctx.title ? (vue.openBlock(), vue.createElementBlock(
                        "h2",
                        _hoisted_3$1,
                        vue.toDisplayString(_ctx.title),
                        1
                        /* TEXT */
                      )) : vue.createCommentVNode("v-if", true)
                    ],
                    64
                    /* STABLE_FRAGMENT */
                  ))
                ]),
                _hoisted_4$1,
                vue.createElementVNode("div", _hoisted_5$1, [
                  _ctx.renderHeaderRight && vue.unref(isFunction)(_ctx.renderHeaderRight) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.renderHeaderRight), {
                    key: 0,
                    "user-info": _ctx.userInfo,
                    title: _ctx.title
                  }, null, 8, ["user-info", "title"])) : _ctx.$slots["header-right"] ? vue.renderSlot(_ctx.$slots, "header-right", {
                    key: 1,
                    userInfo: _ctx.userInfo,
                    title: _ctx.title
                  }) : vue.createCommentVNode("v-if", true),
                  _ctx.hasUserInfo ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElDropdown), {
                    key: 2,
                    placement: "bottom-end",
                    trigger: "click"
                  }, {
                    dropdown: vue.withCtx(() => [
                      vue.createVNode(vue.unref(elementPlus.ElDropdownMenu), { class: "header-dropdown" }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(vue.unref(elementPlus.ElDropdownItem), {
                            onClick: _cache[0] || (_cache[0] = ($event) => handleClickItem(logoutItem))
                          }, {
                            default: vue.withCtx(() => [
                              vue.createTextVNode(
                                vue.toDisplayString(_ctx.logoutText || vue.unref(t)("plus.header.logout")),
                                1
                                /* TEXT */
                              )
                            ]),
                            _: 1
                            /* STABLE */
                          }),
                          (vue.openBlock(true), vue.createElementBlock(
                            vue.Fragment,
                            null,
                            vue.renderList(_ctx.dropdownList, (item) => {
                              return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElDropdownItem), {
                                key: item.value,
                                onClick: ($event) => handleClickItem(item)
                              }, {
                                default: vue.withCtx(() => [
                                  vue.createTextVNode(
                                    vue.toDisplayString(item.label),
                                    1
                                    /* TEXT */
                                  )
                                ]),
                                _: 2
                                /* DYNAMIC */
                              }, 1032, ["onClick"]);
                            }),
                            128
                            /* KEYED_FRAGMENT */
                          ))
                        ]),
                        _: 1
                        /* STABLE */
                      })
                    ]),
                    default: vue.withCtx(() => [
                      vue.createElementVNode("span", _hoisted_6$1, [
                        vue.createCommentVNode(" avatar "),
                        _ctx.userInfo.avatar ? (vue.openBlock(), vue.createElementBlock("img", {
                          key: 0,
                          src: _ctx.userInfo.avatar,
                          alt: "",
                          class: "plus-header__avatar"
                        }, null, 8, _hoisted_7)) : (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElIcon), {
                          key: 1,
                          size: 20,
                          class: "plus-header__avatar"
                        }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(user_default))
                          ]),
                          _: 1
                          /* STABLE */
                        })),
                        vue.createCommentVNode(" username "),
                        vue.createElementVNode(
                          "p",
                          _hoisted_8,
                          vue.toDisplayString(_ctx.userInfo.username || "admin"),
                          1
                          /* TEXT */
                        ),
                        vue.createVNode(vue.unref(elementPlus.ElIcon), { class: "el-icon-caret-bottom el-icon--right" }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(arrow_down_default))
                          ]),
                          _: 1
                          /* STABLE */
                        })
                      ])
                    ]),
                    _: 1
                    /* STABLE */
                  })) : vue.createCommentVNode("v-if", true)
                ])
              ]),
              _: 3
              /* FORWARDED */
            }, 8, ["class"]),
            _ctx.fixed ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_9)) : vue.createCommentVNode("v-if", true)
          ],
          64
          /* STABLE_FRAGMENT */
        );
      };
    }
  });

  var Header = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\header\\src\\index.vue"]]);

  const PlusHeader = Header;

  var _sfc_main$2 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusLayout"
    },
    __name: "index",
    props: {
      sidebarProps: { type: null, required: false, default: void 0 },
      headerProps: { type: null, required: false, default: void 0 },
      breadcrumbProps: { type: null, required: false, default: void 0 },
      scrollbarProps: { type: Object, required: false, default: () => ({
        always: true
      }) },
      backtop: { type: [Boolean, Object], required: false, default: true }
    },
    setup(__props, { expose: __expose }) {
      const props = __props;
      const PlusBreadcrumb$1 = PlusBreadcrumb;
      const PlusSidebar$1 = PlusSidebar;
      const PlusHeader$1 = PlusHeader;
      const plusSidebarInstance = vue.ref();
      const backtopProps = vue.computed(
        () => isPlainObject(props.backtop) ? props.backtop : {}
      );
      __expose({
        plusSidebarInstance
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElContainer), { class: "plus-layout" }, {
          default: vue.withCtx(() => [
            vue.createCommentVNode(" \u5934\u90E8 "),
            vue.createVNode(
              vue.unref(PlusHeader$1),
              vue.normalizeProps(vue.guardReactiveProps(_ctx.headerProps)),
              vue.createSlots({
                _: 2
                /* DYNAMIC */
              }, [
                _ctx.$slots["header-left"] ? {
                  name: "header-left",
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, "header-left", vue.normalizeProps(vue.guardReactiveProps(data)))
                  ]),
                  key: "0"
                } : void 0,
                _ctx.$slots["header-right"] ? {
                  name: "header-right",
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, "header-right", vue.normalizeProps(vue.guardReactiveProps(data)))
                  ]),
                  key: "1"
                } : void 0
              ]),
              1040
              /* FULL_PROPS, DYNAMIC_SLOTS */
            ),
            vue.createVNode(vue.unref(elementPlus.ElContainer), null, {
              default: vue.withCtx(() => [
                vue.createCommentVNode(" \u4FA7\u8FB9\u680F "),
                vue.createVNode(
                  vue.unref(PlusSidebar$1),
                  vue.mergeProps(_ctx.sidebarProps, {
                    ref_key: "plusSidebarInstance",
                    ref: plusSidebarInstance
                  }),
                  vue.createSlots({
                    _: 2
                    /* DYNAMIC */
                  }, [
                    _ctx.$slots["sidebar-extra"] ? {
                      name: "sidebar-extra",
                      fn: vue.withCtx((data) => [
                        vue.renderSlot(_ctx.$slots, "sidebar-extra", vue.normalizeProps(vue.guardReactiveProps(data)))
                      ]),
                      key: "0"
                    } : void 0,
                    _ctx.$slots["sidebar-item"] ? {
                      name: "sidebar-item",
                      fn: vue.withCtx((data) => [
                        vue.renderSlot(_ctx.$slots, "sidebar-item", vue.normalizeProps(vue.guardReactiveProps(data)))
                      ]),
                      key: "1"
                    } : void 0,
                    _ctx.$slots["sidebar-sub"] ? {
                      name: "sidebar-sub",
                      fn: vue.withCtx((data) => [
                        vue.renderSlot(_ctx.$slots, "sidebar-sub", vue.normalizeProps(vue.guardReactiveProps(data)))
                      ]),
                      key: "2"
                    } : void 0,
                    _ctx.$slots["sidebar-item-title"] ? {
                      name: "sidebar-item-title",
                      fn: vue.withCtx((data) => [
                        vue.renderSlot(_ctx.$slots, "sidebar-item-title", vue.normalizeProps(vue.guardReactiveProps(data)))
                      ]),
                      key: "3"
                    } : void 0
                  ]),
                  1040
                  /* FULL_PROPS, DYNAMIC_SLOTS */
                ),
                vue.createCommentVNode(" \u4E3B\u5185\u5BB9 "),
                vue.createVNode(vue.unref(elementPlus.ElMain), null, {
                  default: vue.withCtx(() => [
                    vue.createVNode(
                      vue.unref(elementPlus.ElScrollbar),
                      vue.mergeProps({ class: "plus-layout-main__scrollbar" }, _ctx.scrollbarProps),
                      {
                        default: vue.withCtx(() => [
                          vue.createCommentVNode(" \u9762\u5305\u5C51\u4E0A\u65B9 "),
                          _ctx.$slots["layout-extra"] ? vue.renderSlot(_ctx.$slots, "layout-extra", { key: 0 }) : vue.createCommentVNode("v-if", true),
                          vue.createCommentVNode(" \u9762\u5305\u5C51 "),
                          vue.createVNode(
                            vue.unref(PlusBreadcrumb$1),
                            vue.normalizeProps(vue.guardReactiveProps(_ctx.breadcrumbProps)),
                            vue.createSlots({
                              _: 2
                              /* DYNAMIC */
                            }, [
                              _ctx.$slots["breadcrumb-item-title"] ? {
                                name: "breadcrumb-item-title",
                                fn: vue.withCtx((data) => [
                                  vue.renderSlot(_ctx.$slots, "breadcrumb-item-title", vue.normalizeProps(vue.guardReactiveProps(data)))
                                ]),
                                key: "0"
                              } : void 0
                            ]),
                            1040
                            /* FULL_PROPS, DYNAMIC_SLOTS */
                          ),
                          vue.renderSlot(_ctx.$slots, "default"),
                          _ctx.backtop ? (vue.openBlock(), vue.createBlock(
                            vue.unref(elementPlus.ElBacktop),
                            vue.mergeProps({ key: 1 }, backtopProps.value, { target: ".plus-layout .plus-layout-main__scrollbar" }),
                            null,
                            16
                            /* FULL_PROPS */
                          )) : vue.createCommentVNode("v-if", true)
                        ]),
                        _: 3
                        /* FORWARDED */
                      },
                      16
                      /* FULL_PROPS */
                    )
                  ]),
                  _: 3
                  /* FORWARDED */
                })
              ]),
              _: 3
              /* FORWARDED */
            })
          ]),
          _: 3
          /* FORWARDED */
        });
      };
    }
  });

  var Layout = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\layout\\src\\index.vue"]]);

  const PlusLayout = Layout;

  const _hoisted_1$1 = { class: "plus-check-card__avatar-wrapper" };
  const _hoisted_2 = { class: "plus-check-card__right-content" };
  const _hoisted_3 = {
    key: 0,
    class: "plus-check-card__title"
  };
  const _hoisted_4 = { class: "plus-check-card__title-left" };
  const _hoisted_5 = ["onClick"];
  const _hoisted_6 = {
    key: 1,
    class: "plus-check-card__description"
  };
  var _sfc_main$1 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusCheckCard"
    },
    __name: "index",
    props: {
      modelValue: { type: Boolean, required: false, default: false },
      size: { type: null, required: false, default: "default" },
      avatar: { type: [String, Function], required: false, default: void 0 },
      avatarProps: { type: null, required: false, default: () => ({}) },
      title: { type: [String, Function], required: false, default: void 0 },
      description: { type: [String, Function], required: false, default: void 0 },
      disabled: { type: Boolean, required: false, default: false },
      extra: { type: Function, required: false, default: void 0 }
    },
    emits: ["update:modelValue", "change", "extra"],
    setup(__props, { emit }) {
      const props = __props;
      const classDataEnum = {
        large: "plus-check-card--large",
        default: "plus-check-card--default",
        small: "plus-check-card--small"
      };
      const state = vue.reactive({
        checked: false
      });
      vue.watchEffect(() => {
        state.checked = props.modelValue;
      });
      const getClass = () => {
        return props.size ? classDataEnum[props.size] : "plus-check-card--default";
      };
      const handleClick = () => {
        if (props.disabled)
          return;
        state.checked = !state.checked;
        emit("update:modelValue", state.checked);
        emit("change", state.checked);
      };
      const handelExtra = () => {
        if (props.disabled)
          return;
        emit("extra");
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(["plus-check-card", [
              getClass(),
              state.checked ? "plus-check-card--checked" : "",
              _ctx.disabled ? "plus-check-card--disabled" : ""
            ]]),
            onClick: handleClick
          },
          [
            vue.createElementVNode("div", _hoisted_1$1, [
              vue.unref(isFunction)(_ctx.avatar) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.avatar), {
                key: 0,
                avatar: _ctx.avatar,
                title: _ctx.title,
                description: _ctx.description
              }, null, 8, ["avatar", "title", "description"])) : _ctx.$slots.avatar ? vue.renderSlot(_ctx.$slots, "avatar", {
                key: 1,
                avatar: _ctx.avatar,
                title: _ctx.title,
                description: _ctx.description
              }) : vue.unref(isString)(_ctx.avatar) ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElAvatar), vue.mergeProps({
                key: 2,
                src: _ctx.avatar
              }, _ctx.avatarProps), null, 16, ["src"])) : vue.createCommentVNode("v-if", true)
            ]),
            vue.createElementVNode("div", _hoisted_2, [
              _ctx.title || _ctx.$slots.title ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3, [
                vue.createElementVNode("div", _hoisted_4, [
                  vue.unref(isFunction)(_ctx.title) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.title), {
                    key: 0,
                    avatar: _ctx.avatar,
                    title: _ctx.title,
                    description: _ctx.description
                  }, null, 8, ["avatar", "title", "description"])) : _ctx.$slots.title ? vue.renderSlot(_ctx.$slots, "title", {
                    key: 1,
                    title: _ctx.title,
                    avatar: _ctx.avatar,
                    description: _ctx.description
                  }) : (vue.openBlock(), vue.createElementBlock(
                    vue.Fragment,
                    { key: 2 },
                    [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.title),
                        1
                        /* TEXT */
                      )
                    ],
                    64
                    /* STABLE_FRAGMENT */
                  ))
                ]),
                vue.createElementVNode("div", {
                  class: "plus-check-card__title-right",
                  onClick: vue.withModifiers(handelExtra, ["stop"])
                }, [
                  vue.unref(isFunction)(_ctx.extra) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.extra), {
                    key: 0,
                    avatar: _ctx.avatar,
                    title: _ctx.title,
                    description: _ctx.description
                  }, null, 8, ["avatar", "title", "description"])) : _ctx.$slots.extra ? vue.renderSlot(_ctx.$slots, "extra", {
                    key: 1,
                    title: _ctx.title,
                    avatar: _ctx.avatar,
                    description: _ctx.description
                  }) : vue.createCommentVNode("v-if", true)
                ], 8, _hoisted_5)
              ])) : vue.createCommentVNode("v-if", true),
              _ctx.description || _ctx.$slots.description ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_6, [
                vue.unref(isFunction)(_ctx.description) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.description), {
                  key: 0,
                  title: _ctx.title,
                  avatar: _ctx.avatar,
                  description: _ctx.description
                }, null, 8, ["title", "avatar", "description"])) : _ctx.$slots.description ? vue.renderSlot(_ctx.$slots, "description", {
                  key: 1,
                  title: _ctx.title,
                  description: _ctx.description,
                  avatar: _ctx.avatar
                }) : (vue.openBlock(), vue.createElementBlock(
                  vue.Fragment,
                  { key: 2 },
                  [
                    vue.createTextVNode(
                      vue.toDisplayString(_ctx.description),
                      1
                      /* TEXT */
                    )
                  ],
                  64
                  /* STABLE_FRAGMENT */
                ))
              ])) : vue.createCommentVNode("v-if", true)
            ])
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  var CheckCard = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\check-card\\src\\index.vue"]]);

  const PlusCheckCard = CheckCard;

  const _hoisted_1 = { class: "plus-check-card-group" };
  var _sfc_main = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusCheckCardGroup"
    },
    __name: "index",
    props: {
      modelValue: { type: [Array, String, Number], required: false, default: () => [] },
      options: { type: Array, required: false, default: () => [] },
      size: { type: null, required: false, default: void 0 },
      disabled: { type: Boolean, required: false, default: false },
      multiple: { type: Boolean, required: false, default: false }
    },
    emits: ["update:modelValue", "change", "extra"],
    setup(__props, { emit }) {
      const props = __props;
      const state = vue.reactive({
        checkList: [],
        checked: ""
      });
      vue.watchEffect(() => {
        if (props.multiple) {
          state.checkList = props.modelValue;
        } else {
          state.checked = props.modelValue;
        }
      });
      const getChecked = (value) => {
        if (props.multiple) {
          return state.checkList.includes(value);
        } else {
          return state.checked === value;
        }
      };
      const handleChange = (model, value) => {
        if (props.multiple) {
          if (model) {
            state.checkList.push(value);
          } else {
            state.checkList = state.checkList.filter((item) => item !== value);
          }
          emit("update:modelValue", state.checkList);
          emit("change", state.checkList);
        } else {
          const val = model ? value : "";
          emit("update:modelValue", val);
          emit("change", val);
        }
      };
      const handleExtra = (item) => {
        if (props.disabled)
          return;
        emit("extra", item);
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock("div", _hoisted_1, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList(_ctx.options, (item, index) => {
              return vue.openBlock(), vue.createBlock(vue.unref(PlusCheckCard), vue.mergeProps({
                key: item.value || index,
                size: _ctx.size,
                disabled: _ctx.disabled
              }, item, {
                "model-value": getChecked(item.value),
                onChange: ($event) => handleChange($event, item.value),
                onExtra: ($event) => handleExtra(item)
              }), vue.createSlots({
                _: 2
                /* DYNAMIC */
              }, [
                _ctx.$slots["avatar-" + item.value] || _ctx.$slots.avatar ? {
                  name: "avatar",
                  fn: vue.withCtx((data) => [
                    _ctx.$slots["avatar-" + item.value] ? vue.renderSlot(_ctx.$slots, "avatar-" + item.value, vue.normalizeProps(vue.mergeProps({ key: 0 }, data))) : vue.createCommentVNode("v-if", true),
                    _ctx.$slots.avatar ? vue.renderSlot(_ctx.$slots, "avatar", vue.normalizeProps(vue.mergeProps({ key: 1 }, data))) : vue.createCommentVNode("v-if", true)
                  ]),
                  key: "0"
                } : void 0,
                _ctx.$slots["title-" + item.value] || _ctx.$slots.title ? {
                  name: "title",
                  fn: vue.withCtx((data) => [
                    _ctx.$slots["title-" + item.value] ? vue.renderSlot(_ctx.$slots, "title-" + item.value, vue.normalizeProps(vue.mergeProps({ key: 0 }, data))) : vue.createCommentVNode("v-if", true),
                    _ctx.$slots.title ? vue.renderSlot(_ctx.$slots, "title", vue.normalizeProps(vue.mergeProps({ key: 1 }, data))) : vue.createCommentVNode("v-if", true)
                  ]),
                  key: "1"
                } : void 0,
                _ctx.$slots["description-" + item.value] || _ctx.$slots.description ? {
                  name: "description",
                  fn: vue.withCtx((data) => [
                    _ctx.$slots["description-" + item.value] ? vue.renderSlot(_ctx.$slots, "description-" + item.value, vue.normalizeProps(vue.mergeProps({ key: 0 }, data))) : vue.createCommentVNode("v-if", true),
                    _ctx.$slots.description ? vue.renderSlot(_ctx.$slots, "description", vue.normalizeProps(vue.mergeProps({ key: 1 }, data))) : vue.createCommentVNode("v-if", true)
                  ]),
                  key: "2"
                } : void 0,
                _ctx.$slots["extra-" + item.value] || _ctx.$slots.extra ? {
                  name: "extra",
                  fn: vue.withCtx((data) => [
                    _ctx.$slots["extra-" + item.value] ? vue.renderSlot(_ctx.$slots, "extra-" + item.value, vue.normalizeProps(vue.mergeProps({ key: 0 }, data))) : vue.createCommentVNode("v-if", true),
                    _ctx.$slots.extra ? vue.renderSlot(_ctx.$slots, "extra", vue.normalizeProps(vue.mergeProps({ key: 1 }, data))) : vue.createCommentVNode("v-if", true)
                  ]),
                  key: "3"
                } : void 0
              ]), 1040, ["size", "disabled", "model-value", "onChange", "onExtra"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ]);
      };
    }
  });

  var CheckCardGroup = /* @__PURE__ */ _export_sfc(_sfc_main, [["__file", "E:\\open-source\\plus-pro-components\\packages\\components\\check-card-group\\src\\index.vue"]]);

  const PlusCheckCardGroup = CheckCardGroup;

  const plugins = [
    PlusDialog,
    PlusPagination,
    PlusTable,
    PlusRadio,
    PlusDatePicker,
    PlusDescriptions,
    PlusDisplayItem,
    PlusFormItem,
    PlusForm,
    PlusPopover,
    PlusSearch,
    PlusDialogForm,
    PlusDrawerForm,
    PlusPage,
    PlusStepsForm,
    PlusInputTag,
    PlusBreadcrumb,
    PlusSidebar,
    PlusHeader,
    PlusLayout,
    PlusCheckCard,
    PlusCheckCardGroup
  ];

  var installer = makeInstaller([...plugins]);

  const install = installer.install;

  exports.DefaultPageInfo = DefaultPageInfo;
  exports.DefaultPageSizeList = DefaultPageSizeList;
  exports.PlusBreadcrumb = PlusBreadcrumb;
  exports.PlusCheckCard = PlusCheckCard;
  exports.PlusCheckCardGroup = PlusCheckCardGroup;
  exports.PlusDatePicker = PlusDatePicker;
  exports.PlusDescriptions = PlusDescriptions;
  exports.PlusDialog = PlusDialog;
  exports.PlusDialogForm = PlusDialogForm;
  exports.PlusDisplayItem = PlusDisplayItem;
  exports.PlusDrawerForm = PlusDrawerForm;
  exports.PlusForm = PlusForm;
  exports.PlusFormItem = PlusFormItem;
  exports.PlusHeader = PlusHeader;
  exports.PlusInputTag = PlusInputTag;
  exports.PlusLayout = PlusLayout;
  exports.PlusPage = PlusPage;
  exports.PlusPagination = PlusPagination;
  exports.PlusPopover = PlusPopover;
  exports.PlusRadio = PlusRadio;
  exports.PlusSearch = PlusSearch;
  exports.PlusSidebar = PlusSidebar;
  exports.PlusSidebarItem = PlusSidebarItem;
  exports.PlusStepsForm = PlusStepsForm;
  exports.PlusTable = PlusTable;
  exports.TableFormRefInjectionKey = TableFormRefInjectionKey;
  exports.buildLocaleContext = buildLocaleContext;
  exports.buildTranslator = buildTranslator;
  exports.default = installer;
  exports.install = install;
  exports.translate = translate;
  exports.useGetOptions = useGetOptions;
  exports.useLocale = useLocale;
  exports.useTable = useTable;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
