import { computed, defineComponent, watch, ref, reactive, onBeforeUnmount, provide, Teleport, nextTick, } from 'vue';
import { CLASSES } from '../constants';
var DEFAULT_REFERENCE_OPTIONS = {
    trigger: ['contextmenu'],
};
var Contextmenu = defineComponent({
    name: 'VContextmenu',
    props: {
        modelValue: {
            type: Boolean,
            default: false,
        },
        autoAdjustPlacement: {
            type: Boolean,
            default: true,
        },
        disabled: {
            type: Boolean,
            default: false,
        },
        teleport: {
            type: [String, Object],
            default: function () { return 'body'; },
        },
        preventContextmenu: {
            type: Boolean,
            default: true,
        },
        // destroyOnHide: {
        //   type: Boolean,
        //   default: false,
        // },
    },
    emits: ['show', 'hide', 'update:modelValue', 'contextmenu'],
    setup: function (props, _a) {
        var emit = _a.emit;
        var contextmenuRef = ref(null);
        var visible = ref(props.modelValue || false);
        var toggle = function (value) {
            visible.value = value;
            emit('update:modelValue', value);
        };
        var position = ref({ top: 0, left: 0 });
        var style = computed(function () { return ({
            top: "".concat(position.value.top, "px"),
            left: "".concat(position.value.left, "px"),
        }); });
        var currentOptions = ref(null);
        var show = function (evt, options) {
            var _a, _b;
            var targetOptions = evt instanceof Event ? options : evt;
            var autoAdjustPlacement = (targetOptions === null || targetOptions === void 0 ? void 0 : targetOptions.autoAdjustPlacement) || props.autoAdjustPlacement;
            var targetPosition = {
                top: (targetOptions === null || targetOptions === void 0 ? void 0 : targetOptions.top) || 0,
                left: (targetOptions === null || targetOptions === void 0 ? void 0 : targetOptions.left) || 0,
            };
            if (evt instanceof Event) {
                evt.preventDefault();
                targetPosition.top = (_a = targetOptions === null || targetOptions === void 0 ? void 0 : targetOptions.top) !== null && _a !== void 0 ? _a : evt.pageY;
                targetPosition.left = (_b = targetOptions === null || targetOptions === void 0 ? void 0 : targetOptions.left) !== null && _b !== void 0 ? _b : evt.pageX;
            }
            toggle(true);
            nextTick(function () {
                if (autoAdjustPlacement) {
                    var el = contextmenuRef.value;
                    if (!el)
                        return;
                    var width = el.clientWidth;
                    var height = el.clientHeight;
                    if (height + targetPosition.top >=
                        window.innerHeight + window.scrollY) {
                        var targetTop = targetPosition.top - height;
                        if (targetTop > window.scrollY) {
                            targetPosition.top = targetTop;
                        }
                    }
                    if (width + targetPosition.left >=
                        window.innerWidth + window.scrollX) {
                        var targetWidth = targetPosition.left - width;
                        if (targetWidth > window.scrollX) {
                            targetPosition.left = targetWidth;
                        }
                    }
                }
                position.value = targetPosition;
                // TODO: 添加回调参数
                emit('show');
            });
        };
        var hide = function () {
            currentOptions.value = null;
            toggle(false);
            // TODO: 添加回调参数
            emit('hide');
        };
        var references = reactive(new Map());
        var currentReference = ref();
        var currentReferenceOptions = computed(function () { return currentReference.value && references.get(currentReference.value); });
        var addReference = function (el, options) {
            var triggers = (function () {
                if (options === null || options === void 0 ? void 0 : options.trigger) {
                    return Array.isArray(options.trigger)
                        ? options.trigger
                        : [options.trigger];
                }
                return DEFAULT_REFERENCE_OPTIONS.trigger;
            })();
            var handler = function (evt) {
                if (props.disabled)
                    return;
                currentReference.value = el;
                show(evt, {});
            };
            triggers.forEach(function (eventType) {
                el.addEventListener(eventType, handler);
            });
            references.set(el, {
                triggers: triggers,
                handler: handler,
            });
        };
        var removeReference = function (el) {
            var options = references.get(el);
            if (!options)
                return;
            options.triggers.forEach(function (eventType) {
                el.removeEventListener(eventType, options.handler);
            });
            references.delete(el);
        };
        var onBodyClick = function (evt) {
            if (!evt.target || !contextmenuRef.value || !currentReference.value)
                return;
            var notOutside = contextmenuRef.value.contains(evt.target) ||
                (currentReferenceOptions.value &&
                    currentReferenceOptions.value.triggers.includes('click') &&
                    currentReference.value.contains(evt.target));
            if (!notOutside) {
                toggle(false);
            }
        };
        // watch(props.modelValue, (value) => {
        //   if (value !== visible.value) {
        //     toggle(value);
        //   }
        // });
        watch(visible, function (value) {
            if (value) {
                document.addEventListener('click', onBodyClick);
            }
            else {
                document.removeEventListener('click', onBodyClick);
            }
        });
        onBeforeUnmount(function () {
            document.removeEventListener('click', onBodyClick);
        });
        provide('visible', visible);
        provide('autoAdjustPlacement', props.autoAdjustPlacement);
        provide('show', show);
        provide('hide', hide);
        return {
            visible: visible,
            style: style,
            currentReferenceOptions: currentReferenceOptions,
            currentOptions: currentOptions,
            contextmenuRef: contextmenuRef,
            addReference: addReference,
            removeReference: removeReference,
            toggle: toggle,
            show: show,
            hide: hide,
        };
    },
    methods: {
        renderContent: function () {
            var _this = this;
            var _a, _b;
            return (<div class={CLASSES.contextmenu} ref="contextmenuRef" v-show="visible" style={this.style} onContextmenu={function (evt) {
                    if (_this.$props.preventContextmenu) {
                        evt.preventDefault();
                    }
                    _this.$emit('contextmenu', evt);
                }}>
          <ul class={CLASSES.contextmenuInner}>
            {(_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a, {
                    triggerOptions: 'currentReferenceOptions',
                    options: 'currentOptions',
                })}
          </ul>
        </div>);
        },
    },
    render: function () {
        if (!this.visible)
            return null;
        return this.teleport ? (<Teleport to={this.teleport}>{this.renderContent()}</Teleport>) : (this.renderContent());
    },
});
export default Contextmenu;
//# sourceMappingURL=Contextmenu.jsx.map