var Xw = Object.defineProperty;
var Kw = (u, n, i) => n in u ? Xw(u, n, { enumerable: !0, configurable: !0, writable: !0, value: i }) : u[n] = i;
var bt = (u, n, i) => (Kw(u, typeof n != "symbol" ? n + "" : n, i), i), Mm = (u, n, i) => {
  if (!n.has(u))
    throw TypeError("Cannot " + i);
};
var r = (u, n, i) => (Mm(u, n, "read from private field"), i ? i.call(u) : n.get(u)), v = (u, n, i) => {
  if (n.has(u))
    throw TypeError("Cannot add the same private member more than once");
  n instanceof WeakSet ? n.add(u) : n.set(u, i);
}, x = (u, n, i, l) => (Mm(u, n, "write to private field"), l ? l.call(u, i) : n.set(u, i), i);
var De = (u, n, i, l) => ({
  set _(d) {
    x(u, n, d, i);
  },
  get _() {
    return r(u, n, l);
  }
}), E = (u, n, i) => (Mm(u, n, "access private method"), i);
import { shallowRef as Md, watchEffect as Yw, toValue as Qw, onBeforeUnmount as Ky, defineComponent as Zw, ref as Jw, toRef as qw, computed as tS, watch as Om, openBlock as od, createElementBlock as ld, Fragment as eS, renderList as sS, renderSlot as cy, createElementVNode as Yy, normalizeStyle as iS, createCommentVNode as dy } from "vue";
var nS = {
  /***/
  9306: (
    /***/
    (u, n, i) => {
      var l = i(4901), d = i(6823), f = TypeError;
      u.exports = function(m) {
        if (l(m))
          return m;
        throw new f(d(m) + " is not a function");
      };
    }
  ),
  /***/
  3506: (
    /***/
    (u, n, i) => {
      var l = i(3925), d = String, f = TypeError;
      u.exports = function(m) {
        if (l(m))
          return m;
        throw new f("Can't set " + d(m) + " as a prototype");
      };
    }
  ),
  /***/
  7080: (
    /***/
    (u, n, i) => {
      var l = i(4402).has;
      u.exports = function(d) {
        return l(d), d;
      };
    }
  ),
  /***/
  679: (
    /***/
    (u, n, i) => {
      var l = i(1625), d = TypeError;
      u.exports = function(f, m) {
        if (l(m, f))
          return f;
        throw new d("Incorrect invocation");
      };
    }
  ),
  /***/
  8551: (
    /***/
    (u, n, i) => {
      var l = i(34), d = String, f = TypeError;
      u.exports = function(m) {
        if (l(m))
          return m;
        throw new f(d(m) + " is not an object");
      };
    }
  ),
  /***/
  7811: (
    /***/
    (u) => {
      u.exports = typeof ArrayBuffer < "u" && typeof DataView < "u";
    }
  ),
  /***/
  7394: (
    /***/
    (u, n, i) => {
      var l = i(6706), d = i(4576), f = TypeError;
      u.exports = l(ArrayBuffer.prototype, "byteLength", "get") || function(m) {
        if (d(m) !== "ArrayBuffer")
          throw new f("ArrayBuffer expected");
        return m.byteLength;
      };
    }
  ),
  /***/
  3238: (
    /***/
    (u, n, i) => {
      var l = i(9504), d = i(7394), f = l(ArrayBuffer.prototype.slice);
      u.exports = function(m) {
        if (d(m) !== 0)
          return !1;
        try {
          return f(m, 0, 0), !1;
        } catch {
          return !0;
        }
      };
    }
  ),
  /***/
  5636: (
    /***/
    (u, n, i) => {
      var l = i(4475), d = i(9504), f = i(6706), m = i(7696), y = i(3238), w = i(7394), P = i(4483), I = i(1548), L = l.structuredClone, _ = l.ArrayBuffer, D = l.DataView, k = l.TypeError, H = Math.min, X = _.prototype, N = D.prototype, z = d(X.slice), V = f(X, "resizable", "get"), Z = f(X, "maxByteLength", "get"), K = d(N.getInt8), $ = d(N.setInt8);
      u.exports = (I || P) && function(j, Q, B) {
        var G = w(j), q = Q === void 0 ? G : m(Q), tt = !V || !V(j), lt;
        if (y(j))
          throw new k("ArrayBuffer is detached");
        if (I && (j = L(j, { transfer: [j] }), G === q && (B || tt)))
          return j;
        if (G >= q && (!B || tt))
          lt = z(j, 0, q);
        else {
          var vt = B && !tt && Z ? { maxByteLength: Z(j) } : void 0;
          lt = new _(q, vt);
          for (var dt = new D(j), W = new D(lt), Et = H(q, G), Pt = 0; Pt < Et; Pt++)
            $(W, Pt, K(dt, Pt));
        }
        return I || P(j), lt;
      };
    }
  ),
  /***/
  4644: (
    /***/
    (u, n, i) => {
      var l = i(7811), d = i(3724), f = i(4475), m = i(4901), y = i(34), w = i(9297), P = i(6955), I = i(6823), L = i(6699), _ = i(6840), D = i(2106), k = i(1625), H = i(2787), X = i(2967), N = i(8227), z = i(3392), V = i(1181), Z = V.enforce, K = V.get, $ = f.Int8Array, j = $ && $.prototype, Q = f.Uint8ClampedArray, B = Q && Q.prototype, G = $ && H($), q = j && H(j), tt = Object.prototype, lt = f.TypeError, vt = N("toStringTag"), dt = z("TYPED_ARRAY_TAG"), W = "TypedArrayConstructor", Et = l && !!X && P(f.opera) !== "Opera", Pt = !1, Ht, Ft, We, be = {
        Int8Array: 1,
        Uint8Array: 1,
        Uint8ClampedArray: 1,
        Int16Array: 2,
        Uint16Array: 2,
        Int32Array: 4,
        Uint32Array: 4,
        Float32Array: 4,
        Float64Array: 8
      }, Gs = {
        BigInt64Array: 8,
        BigUint64Array: 8
      }, Bn = function(Bt) {
        if (!y(Bt))
          return !1;
        var Vt = P(Bt);
        return Vt === "DataView" || w(be, Vt) || w(Gs, Vt);
      }, Ta = function(ct) {
        var Bt = H(ct);
        if (y(Bt)) {
          var Vt = K(Bt);
          return Vt && w(Vt, W) ? Vt[W] : Ta(Bt);
        }
      }, ht = function(ct) {
        if (!y(ct))
          return !1;
        var Bt = P(ct);
        return w(be, Bt) || w(Gs, Bt);
      }, nt = function(ct) {
        if (ht(ct))
          return ct;
        throw new lt("Target is not a typed array");
      }, at = function(ct) {
        if (m(ct) && (!X || k(G, ct)))
          return ct;
        throw new lt(I(ct) + " is not a typed array constructor");
      }, et = function(ct, Bt, Vt, Ge) {
        if (d) {
          if (Vt)
            for (var ne in be) {
              var Lt = f[ne];
              if (Lt && w(Lt.prototype, ct))
                try {
                  delete Lt.prototype[ct];
                } catch {
                  try {
                    Lt.prototype[ct] = Bt;
                  } catch {
                  }
                }
            }
          (!q[ct] || Vt) && _(q, ct, Vt ? Bt : Et && j[ct] || Bt, Ge);
        }
      }, Mt = function(ct, Bt, Vt) {
        var Ge, ne;
        if (d) {
          if (X) {
            if (Vt) {
              for (Ge in be)
                if (ne = f[Ge], ne && w(ne, ct))
                  try {
                    delete ne[ct];
                  } catch {
                  }
            }
            if (!G[ct] || Vt)
              try {
                return _(G, ct, Vt ? Bt : Et && G[ct] || Bt);
              } catch {
              }
            else
              return;
          }
          for (Ge in be)
            ne = f[Ge], ne && (!ne[ct] || Vt) && _(ne, ct, Bt);
        }
      };
      for (Ht in be)
        Ft = f[Ht], We = Ft && Ft.prototype, We ? Z(We)[W] = Ft : Et = !1;
      for (Ht in Gs)
        Ft = f[Ht], We = Ft && Ft.prototype, We && (Z(We)[W] = Ft);
      if ((!Et || !m(G) || G === Function.prototype) && (G = function() {
        throw new lt("Incorrect invocation");
      }, Et))
        for (Ht in be)
          f[Ht] && X(f[Ht], G);
      if ((!Et || !q || q === tt) && (q = G.prototype, Et))
        for (Ht in be)
          f[Ht] && X(f[Ht].prototype, q);
      if (Et && H(B) !== q && X(B, q), d && !w(q, vt)) {
        Pt = !0, D(q, vt, {
          configurable: !0,
          get: function() {
            return y(this) ? this[dt] : void 0;
          }
        });
        for (Ht in be)
          f[Ht] && L(f[Ht], dt, Ht);
      }
      u.exports = {
        NATIVE_ARRAY_BUFFER_VIEWS: Et,
        TYPED_ARRAY_TAG: Pt && dt,
        aTypedArray: nt,
        aTypedArrayConstructor: at,
        exportTypedArrayMethod: et,
        exportTypedArrayStaticMethod: Mt,
        getTypedArrayConstructor: Ta,
        isView: Bn,
        isTypedArray: ht,
        TypedArray: G,
        TypedArrayPrototype: q
      };
    }
  ),
  /***/
  5370: (
    /***/
    (u, n, i) => {
      var l = i(6198);
      u.exports = function(d, f, m) {
        for (var y = 0, w = arguments.length > 2 ? m : l(f), P = new d(w); w > y; )
          P[y] = f[y++];
        return P;
      };
    }
  ),
  /***/
  9617: (
    /***/
    (u, n, i) => {
      var l = i(5397), d = i(5610), f = i(6198), m = function(y) {
        return function(w, P, I) {
          var L = l(w), _ = f(L);
          if (_ === 0)
            return !y && -1;
          var D = d(I, _), k;
          if (y && P !== P) {
            for (; _ > D; )
              if (k = L[D++], k !== k)
                return !0;
          } else
            for (; _ > D; D++)
              if ((y || D in L) && L[D] === P)
                return y || D || 0;
          return !y && -1;
        };
      };
      u.exports = {
        // `Array.prototype.includes` method
        // https://tc39.es/ecma262/#sec-array.prototype.includes
        includes: m(!0),
        // `Array.prototype.indexOf` method
        // https://tc39.es/ecma262/#sec-array.prototype.indexof
        indexOf: m(!1)
      };
    }
  ),
  /***/
  4527: (
    /***/
    (u, n, i) => {
      var l = i(3724), d = i(4376), f = TypeError, m = Object.getOwnPropertyDescriptor, y = l && !function() {
        if (this !== void 0)
          return !0;
        try {
          Object.defineProperty([], "length", { writable: !1 }).length = 1;
        } catch (w) {
          return w instanceof TypeError;
        }
      }();
      u.exports = y ? function(w, P) {
        if (d(w) && !m(w, "length").writable)
          throw new f("Cannot set read only .length");
        return w.length = P;
      } : function(w, P) {
        return w.length = P;
      };
    }
  ),
  /***/
  7628: (
    /***/
    (u, n, i) => {
      var l = i(6198);
      u.exports = function(d, f) {
        for (var m = l(d), y = new f(m), w = 0; w < m; w++)
          y[w] = d[m - w - 1];
        return y;
      };
    }
  ),
  /***/
  9928: (
    /***/
    (u, n, i) => {
      var l = i(6198), d = i(1291), f = RangeError;
      u.exports = function(m, y, w, P) {
        var I = l(m), L = d(w), _ = L < 0 ? I + L : L;
        if (_ >= I || _ < 0)
          throw new f("Incorrect index");
        for (var D = new y(I), k = 0; k < I; k++)
          D[k] = k === _ ? P : m[k];
        return D;
      };
    }
  ),
  /***/
  6319: (
    /***/
    (u, n, i) => {
      var l = i(8551), d = i(9539);
      u.exports = function(f, m, y, w) {
        try {
          return w ? m(l(y)[0], y[1]) : m(y);
        } catch (P) {
          d(f, "throw", P);
        }
      };
    }
  ),
  /***/
  4576: (
    /***/
    (u, n, i) => {
      var l = i(9504), d = l({}.toString), f = l("".slice);
      u.exports = function(m) {
        return f(d(m), 8, -1);
      };
    }
  ),
  /***/
  6955: (
    /***/
    (u, n, i) => {
      var l = i(2140), d = i(4901), f = i(4576), m = i(8227), y = m("toStringTag"), w = Object, P = f(function() {
        return arguments;
      }()) === "Arguments", I = function(L, _) {
        try {
          return L[_];
        } catch {
        }
      };
      u.exports = l ? f : function(L) {
        var _, D, k;
        return L === void 0 ? "Undefined" : L === null ? "Null" : typeof (D = I(_ = w(L), y)) == "string" ? D : P ? f(_) : (k = f(_)) === "Object" && d(_.callee) ? "Arguments" : k;
      };
    }
  ),
  /***/
  7740: (
    /***/
    (u, n, i) => {
      var l = i(9297), d = i(5031), f = i(7347), m = i(4913);
      u.exports = function(y, w, P) {
        for (var I = d(w), L = m.f, _ = f.f, D = 0; D < I.length; D++) {
          var k = I[D];
          !l(y, k) && !(P && l(P, k)) && L(y, k, _(w, k));
        }
      };
    }
  ),
  /***/
  2211: (
    /***/
    (u, n, i) => {
      var l = i(9039);
      u.exports = !l(function() {
        function d() {
        }
        return d.prototype.constructor = null, Object.getPrototypeOf(new d()) !== d.prototype;
      });
    }
  ),
  /***/
  2529: (
    /***/
    (u) => {
      u.exports = function(n, i) {
        return { value: n, done: i };
      };
    }
  ),
  /***/
  6699: (
    /***/
    (u, n, i) => {
      var l = i(3724), d = i(4913), f = i(6980);
      u.exports = l ? function(m, y, w) {
        return d.f(m, y, f(1, w));
      } : function(m, y, w) {
        return m[y] = w, m;
      };
    }
  ),
  /***/
  6980: (
    /***/
    (u) => {
      u.exports = function(n, i) {
        return {
          enumerable: !(n & 1),
          configurable: !(n & 2),
          writable: !(n & 4),
          value: i
        };
      };
    }
  ),
  /***/
  4659: (
    /***/
    (u, n, i) => {
      var l = i(3724), d = i(4913), f = i(6980);
      u.exports = function(m, y, w) {
        l ? d.f(m, y, f(0, w)) : m[y] = w;
      };
    }
  ),
  /***/
  2106: (
    /***/
    (u, n, i) => {
      var l = i(283), d = i(4913);
      u.exports = function(f, m, y) {
        return y.get && l(y.get, m, { getter: !0 }), y.set && l(y.set, m, { setter: !0 }), d.f(f, m, y);
      };
    }
  ),
  /***/
  6840: (
    /***/
    (u, n, i) => {
      var l = i(4901), d = i(4913), f = i(283), m = i(9433);
      u.exports = function(y, w, P, I) {
        I || (I = {});
        var L = I.enumerable, _ = I.name !== void 0 ? I.name : w;
        if (l(P) && f(P, _, I), I.global)
          L ? y[w] = P : m(w, P);
        else {
          try {
            I.unsafe ? y[w] && (L = !0) : delete y[w];
          } catch {
          }
          L ? y[w] = P : d.f(y, w, {
            value: P,
            enumerable: !1,
            configurable: !I.nonConfigurable,
            writable: !I.nonWritable
          });
        }
        return y;
      };
    }
  ),
  /***/
  6279: (
    /***/
    (u, n, i) => {
      var l = i(6840);
      u.exports = function(d, f, m) {
        for (var y in f)
          l(d, y, f[y], m);
        return d;
      };
    }
  ),
  /***/
  9433: (
    /***/
    (u, n, i) => {
      var l = i(4475), d = Object.defineProperty;
      u.exports = function(f, m) {
        try {
          d(l, f, { value: m, configurable: !0, writable: !0 });
        } catch {
          l[f] = m;
        }
        return m;
      };
    }
  ),
  /***/
  3724: (
    /***/
    (u, n, i) => {
      var l = i(9039);
      u.exports = !l(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] !== 7;
      });
    }
  ),
  /***/
  4483: (
    /***/
    (u, n, i) => {
      var l = i(4475), d = i(9714), f = i(1548), m = l.structuredClone, y = l.ArrayBuffer, w = l.MessageChannel, P = !1, I, L, _, D;
      if (f)
        P = function(k) {
          m(k, { transfer: [k] });
        };
      else if (y)
        try {
          w || (I = d("worker_threads"), I && (w = I.MessageChannel)), w && (L = new w(), _ = new y(2), D = function(k) {
            L.port1.postMessage(null, [k]);
          }, _.byteLength === 2 && (D(_), _.byteLength === 0 && (P = D)));
        } catch {
        }
      u.exports = P;
    }
  ),
  /***/
  4055: (
    /***/
    (u, n, i) => {
      var l = i(4475), d = i(34), f = l.document, m = d(f) && d(f.createElement);
      u.exports = function(y) {
        return m ? f.createElement(y) : {};
      };
    }
  ),
  /***/
  6837: (
    /***/
    (u) => {
      var n = TypeError, i = 9007199254740991;
      u.exports = function(l) {
        if (l > i)
          throw n("Maximum allowed index exceeded");
        return l;
      };
    }
  ),
  /***/
  5002: (
    /***/
    (u) => {
      u.exports = {
        IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 },
        DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 },
        HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 },
        WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 },
        InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 },
        NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 },
        NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 },
        NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 },
        NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 },
        InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 },
        InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 },
        SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 },
        InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 },
        NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 },
        InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 },
        ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 },
        TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 },
        SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 },
        NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 },
        AbortError: { s: "ABORT_ERR", c: 20, m: 1 },
        URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 },
        QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 },
        TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 },
        InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 },
        DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 }
      };
    }
  ),
  /***/
  7290: (
    /***/
    (u, n, i) => {
      var l = i(516), d = i(9088);
      u.exports = !l && !d && typeof window == "object" && typeof document == "object";
    }
  ),
  /***/
  516: (
    /***/
    (u) => {
      u.exports = typeof Deno == "object" && Deno && typeof Deno.version == "object";
    }
  ),
  /***/
  9088: (
    /***/
    (u, n, i) => {
      var l = i(4475), d = i(4576);
      u.exports = d(l.process) === "process";
    }
  ),
  /***/
  9392: (
    /***/
    (u) => {
      u.exports = typeof navigator < "u" && String(navigator.userAgent) || "";
    }
  ),
  /***/
  7388: (
    /***/
    (u, n, i) => {
      var l = i(4475), d = i(9392), f = l.process, m = l.Deno, y = f && f.versions || m && m.version, w = y && y.v8, P, I;
      w && (P = w.split("."), I = P[0] > 0 && P[0] < 4 ? 1 : +(P[0] + P[1])), !I && d && (P = d.match(/Edge\/(\d+)/), (!P || P[1] >= 74) && (P = d.match(/Chrome\/(\d+)/), P && (I = +P[1]))), u.exports = I;
    }
  ),
  /***/
  8727: (
    /***/
    (u) => {
      u.exports = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
      ];
    }
  ),
  /***/
  6193: (
    /***/
    (u, n, i) => {
      var l = i(9504), d = Error, f = l("".replace), m = function(P) {
        return String(new d(P).stack);
      }("zxcasd"), y = /\n\s*at [^:]*:[^\n]*/, w = y.test(m);
      u.exports = function(P, I) {
        if (w && typeof P == "string" && !d.prepareStackTrace)
          for (; I--; )
            P = f(P, y, "");
        return P;
      };
    }
  ),
  /***/
  6518: (
    /***/
    (u, n, i) => {
      var l = i(4475), d = i(7347).f, f = i(6699), m = i(6840), y = i(9433), w = i(7740), P = i(2796);
      u.exports = function(I, L) {
        var _ = I.target, D = I.global, k = I.stat, H, X, N, z, V, Z;
        if (D ? X = l : k ? X = l[_] || y(_, {}) : X = l[_] && l[_].prototype, X)
          for (N in L) {
            if (V = L[N], I.dontCallGetSet ? (Z = d(X, N), z = Z && Z.value) : z = X[N], H = P(D ? N : _ + (k ? "." : "#") + N, I.forced), !H && z !== void 0) {
              if (typeof V == typeof z)
                continue;
              w(V, z);
            }
            (I.sham || z && z.sham) && f(V, "sham", !0), m(X, N, V, I);
          }
      };
    }
  ),
  /***/
  9039: (
    /***/
    (u) => {
      u.exports = function(n) {
        try {
          return !!n();
        } catch {
          return !0;
        }
      };
    }
  ),
  /***/
  6080: (
    /***/
    (u, n, i) => {
      var l = i(7476), d = i(9306), f = i(616), m = l(l.bind);
      u.exports = function(y, w) {
        return d(y), w === void 0 ? y : f ? m(y, w) : function() {
          return y.apply(w, arguments);
        };
      };
    }
  ),
  /***/
  616: (
    /***/
    (u, n, i) => {
      var l = i(9039);
      u.exports = !l(function() {
        var d = (function() {
        }).bind();
        return typeof d != "function" || d.hasOwnProperty("prototype");
      });
    }
  ),
  /***/
  9565: (
    /***/
    (u, n, i) => {
      var l = i(616), d = Function.prototype.call;
      u.exports = l ? d.bind(d) : function() {
        return d.apply(d, arguments);
      };
    }
  ),
  /***/
  350: (
    /***/
    (u, n, i) => {
      var l = i(3724), d = i(9297), f = Function.prototype, m = l && Object.getOwnPropertyDescriptor, y = d(f, "name"), w = y && (function() {
      }).name === "something", P = y && (!l || l && m(f, "name").configurable);
      u.exports = {
        EXISTS: y,
        PROPER: w,
        CONFIGURABLE: P
      };
    }
  ),
  /***/
  6706: (
    /***/
    (u, n, i) => {
      var l = i(9504), d = i(9306);
      u.exports = function(f, m, y) {
        try {
          return l(d(Object.getOwnPropertyDescriptor(f, m)[y]));
        } catch {
        }
      };
    }
  ),
  /***/
  7476: (
    /***/
    (u, n, i) => {
      var l = i(4576), d = i(9504);
      u.exports = function(f) {
        if (l(f) === "Function")
          return d(f);
      };
    }
  ),
  /***/
  9504: (
    /***/
    (u, n, i) => {
      var l = i(616), d = Function.prototype, f = d.call, m = l && d.bind.bind(f, f);
      u.exports = l ? m : function(y) {
        return function() {
          return f.apply(y, arguments);
        };
      };
    }
  ),
  /***/
  7751: (
    /***/
    (u, n, i) => {
      var l = i(4475), d = i(4901), f = function(m) {
        return d(m) ? m : void 0;
      };
      u.exports = function(m, y) {
        return arguments.length < 2 ? f(l[m]) : l[m] && l[m][y];
      };
    }
  ),
  /***/
  1767: (
    /***/
    (u) => {
      u.exports = function(n) {
        return {
          iterator: n,
          next: n.next,
          done: !1
        };
      };
    }
  ),
  /***/
  8646: (
    /***/
    (u, n, i) => {
      var l = i(9565), d = i(8551), f = i(1767), m = i(851);
      u.exports = function(y, w) {
        (!w || typeof y != "string") && d(y);
        var P = m(y);
        return f(d(P !== void 0 ? l(P, y) : y));
      };
    }
  ),
  /***/
  851: (
    /***/
    (u, n, i) => {
      var l = i(6955), d = i(5966), f = i(4117), m = i(6269), y = i(8227), w = y("iterator");
      u.exports = function(P) {
        if (!f(P))
          return d(P, w) || d(P, "@@iterator") || m[l(P)];
      };
    }
  ),
  /***/
  81: (
    /***/
    (u, n, i) => {
      var l = i(9565), d = i(9306), f = i(8551), m = i(6823), y = i(851), w = TypeError;
      u.exports = function(P, I) {
        var L = arguments.length < 2 ? y(P) : I;
        if (d(L))
          return f(l(L, P));
        throw new w(m(P) + " is not iterable");
      };
    }
  ),
  /***/
  5966: (
    /***/
    (u, n, i) => {
      var l = i(9306), d = i(4117);
      u.exports = function(f, m) {
        var y = f[m];
        return d(y) ? void 0 : l(y);
      };
    }
  ),
  /***/
  3789: (
    /***/
    (u, n, i) => {
      var l = i(9306), d = i(8551), f = i(9565), m = i(1291), y = i(1767), w = "Invalid size", P = RangeError, I = TypeError, L = Math.max, _ = function(D, k) {
        this.set = D, this.size = L(k, 0), this.has = l(D.has), this.keys = l(D.keys);
      };
      _.prototype = {
        getIterator: function() {
          return y(d(f(this.keys, this.set)));
        },
        includes: function(D) {
          return f(this.has, this.set, D);
        }
      }, u.exports = function(D) {
        d(D);
        var k = +D.size;
        if (k !== k)
          throw new I(w);
        var H = m(k);
        if (H < 0)
          throw new P(w);
        return new _(D, H);
      };
    }
  ),
  /***/
  4475: (
    /***/
    function(u) {
      var n = function(i) {
        return i && i.Math === Math && i;
      };
      u.exports = // eslint-disable-next-line es/no-global-this -- safe
      n(typeof globalThis == "object" && globalThis) || n(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
      n(typeof self == "object" && self) || n(typeof global == "object" && global) || n(typeof this == "object" && this) || // eslint-disable-next-line no-new-func -- fallback
      function() {
        return this;
      }() || Function("return this")();
    }
  ),
  /***/
  9297: (
    /***/
    (u, n, i) => {
      var l = i(9504), d = i(8981), f = l({}.hasOwnProperty);
      u.exports = Object.hasOwn || function(y, w) {
        return f(d(y), w);
      };
    }
  ),
  /***/
  421: (
    /***/
    (u) => {
      u.exports = {};
    }
  ),
  /***/
  397: (
    /***/
    (u, n, i) => {
      var l = i(7751);
      u.exports = l("document", "documentElement");
    }
  ),
  /***/
  5917: (
    /***/
    (u, n, i) => {
      var l = i(3724), d = i(9039), f = i(4055);
      u.exports = !l && !d(function() {
        return Object.defineProperty(f("div"), "a", {
          get: function() {
            return 7;
          }
        }).a !== 7;
      });
    }
  ),
  /***/
  7055: (
    /***/
    (u, n, i) => {
      var l = i(9504), d = i(9039), f = i(4576), m = Object, y = l("".split);
      u.exports = d(function() {
        return !m("z").propertyIsEnumerable(0);
      }) ? function(w) {
        return f(w) === "String" ? y(w, "") : m(w);
      } : m;
    }
  ),
  /***/
  3167: (
    /***/
    (u, n, i) => {
      var l = i(4901), d = i(34), f = i(2967);
      u.exports = function(m, y, w) {
        var P, I;
        return (
          // it can work only with native `setPrototypeOf`
          f && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
          l(P = y.constructor) && P !== w && d(I = P.prototype) && I !== w.prototype && f(m, I), m
        );
      };
    }
  ),
  /***/
  3706: (
    /***/
    (u, n, i) => {
      var l = i(9504), d = i(4901), f = i(7629), m = l(Function.toString);
      d(f.inspectSource) || (f.inspectSource = function(y) {
        return m(y);
      }), u.exports = f.inspectSource;
    }
  ),
  /***/
  1181: (
    /***/
    (u, n, i) => {
      var l = i(8622), d = i(4475), f = i(34), m = i(6699), y = i(9297), w = i(7629), P = i(6119), I = i(421), L = "Object already initialized", _ = d.TypeError, D = d.WeakMap, k, H, X, N = function(K) {
        return X(K) ? H(K) : k(K, {});
      }, z = function(K) {
        return function($) {
          var j;
          if (!f($) || (j = H($)).type !== K)
            throw new _("Incompatible receiver, " + K + " required");
          return j;
        };
      };
      if (l || w.state) {
        var V = w.state || (w.state = new D());
        V.get = V.get, V.has = V.has, V.set = V.set, k = function(K, $) {
          if (V.has(K))
            throw new _(L);
          return $.facade = K, V.set(K, $), $;
        }, H = function(K) {
          return V.get(K) || {};
        }, X = function(K) {
          return V.has(K);
        };
      } else {
        var Z = P("state");
        I[Z] = !0, k = function(K, $) {
          if (y(K, Z))
            throw new _(L);
          return $.facade = K, m(K, Z, $), $;
        }, H = function(K) {
          return y(K, Z) ? K[Z] : {};
        }, X = function(K) {
          return y(K, Z);
        };
      }
      u.exports = {
        set: k,
        get: H,
        has: X,
        enforce: N,
        getterFor: z
      };
    }
  ),
  /***/
  4209: (
    /***/
    (u, n, i) => {
      var l = i(8227), d = i(6269), f = l("iterator"), m = Array.prototype;
      u.exports = function(y) {
        return y !== void 0 && (d.Array === y || m[f] === y);
      };
    }
  ),
  /***/
  4376: (
    /***/
    (u, n, i) => {
      var l = i(4576);
      u.exports = Array.isArray || function(f) {
        return l(f) === "Array";
      };
    }
  ),
  /***/
  1108: (
    /***/
    (u, n, i) => {
      var l = i(6955);
      u.exports = function(d) {
        var f = l(d);
        return f === "BigInt64Array" || f === "BigUint64Array";
      };
    }
  ),
  /***/
  4901: (
    /***/
    (u) => {
      var n = typeof document == "object" && document.all;
      u.exports = typeof n > "u" && n !== void 0 ? function(i) {
        return typeof i == "function" || i === n;
      } : function(i) {
        return typeof i == "function";
      };
    }
  ),
  /***/
  2796: (
    /***/
    (u, n, i) => {
      var l = i(9039), d = i(4901), f = /#|\.prototype\./, m = function(L, _) {
        var D = w[y(L)];
        return D === I ? !0 : D === P ? !1 : d(_) ? l(_) : !!_;
      }, y = m.normalize = function(L) {
        return String(L).replace(f, ".").toLowerCase();
      }, w = m.data = {}, P = m.NATIVE = "N", I = m.POLYFILL = "P";
      u.exports = m;
    }
  ),
  /***/
  4117: (
    /***/
    (u) => {
      u.exports = function(n) {
        return n == null;
      };
    }
  ),
  /***/
  34: (
    /***/
    (u, n, i) => {
      var l = i(4901);
      u.exports = function(d) {
        return typeof d == "object" ? d !== null : l(d);
      };
    }
  ),
  /***/
  3925: (
    /***/
    (u, n, i) => {
      var l = i(34);
      u.exports = function(d) {
        return l(d) || d === null;
      };
    }
  ),
  /***/
  6395: (
    /***/
    (u) => {
      u.exports = !1;
    }
  ),
  /***/
  757: (
    /***/
    (u, n, i) => {
      var l = i(7751), d = i(4901), f = i(1625), m = i(7040), y = Object;
      u.exports = m ? function(w) {
        return typeof w == "symbol";
      } : function(w) {
        var P = l("Symbol");
        return d(P) && f(P.prototype, y(w));
      };
    }
  ),
  /***/
  507: (
    /***/
    (u, n, i) => {
      var l = i(9565);
      u.exports = function(d, f, m) {
        for (var y = m ? d : d.iterator, w = d.next, P, I; !(P = l(w, y)).done; )
          if (I = f(P.value), I !== void 0)
            return I;
      };
    }
  ),
  /***/
  2652: (
    /***/
    (u, n, i) => {
      var l = i(6080), d = i(9565), f = i(8551), m = i(6823), y = i(4209), w = i(6198), P = i(1625), I = i(81), L = i(851), _ = i(9539), D = TypeError, k = function(X, N) {
        this.stopped = X, this.result = N;
      }, H = k.prototype;
      u.exports = function(X, N, z) {
        var V = z && z.that, Z = !!(z && z.AS_ENTRIES), K = !!(z && z.IS_RECORD), $ = !!(z && z.IS_ITERATOR), j = !!(z && z.INTERRUPTED), Q = l(N, V), B, G, q, tt, lt, vt, dt, W = function(Pt) {
          return B && _(B, "normal", Pt), new k(!0, Pt);
        }, Et = function(Pt) {
          return Z ? (f(Pt), j ? Q(Pt[0], Pt[1], W) : Q(Pt[0], Pt[1])) : j ? Q(Pt, W) : Q(Pt);
        };
        if (K)
          B = X.iterator;
        else if ($)
          B = X;
        else {
          if (G = L(X), !G)
            throw new D(m(X) + " is not iterable");
          if (y(G)) {
            for (q = 0, tt = w(X); tt > q; q++)
              if (lt = Et(X[q]), lt && P(H, lt))
                return lt;
            return new k(!1);
          }
          B = I(X, G);
        }
        for (vt = K ? X.next : B.next; !(dt = d(vt, B)).done; ) {
          try {
            lt = Et(dt.value);
          } catch (Pt) {
            _(B, "throw", Pt);
          }
          if (typeof lt == "object" && lt && P(H, lt))
            return lt;
        }
        return new k(!1);
      };
    }
  ),
  /***/
  9539: (
    /***/
    (u, n, i) => {
      var l = i(9565), d = i(8551), f = i(5966);
      u.exports = function(m, y, w) {
        var P, I;
        d(m);
        try {
          if (P = f(m, "return"), !P) {
            if (y === "throw")
              throw w;
            return w;
          }
          P = l(P, m);
        } catch (L) {
          I = !0, P = L;
        }
        if (y === "throw")
          throw w;
        if (I)
          throw P;
        return d(P), w;
      };
    }
  ),
  /***/
  9462: (
    /***/
    (u, n, i) => {
      var l = i(9565), d = i(2360), f = i(6699), m = i(6279), y = i(8227), w = i(1181), P = i(5966), I = i(7657).IteratorPrototype, L = i(2529), _ = i(9539), D = y("toStringTag"), k = "IteratorHelper", H = "WrapForValidIterator", X = w.set, N = function(Z) {
        var K = w.getterFor(Z ? H : k);
        return m(d(I), {
          next: function() {
            var j = K(this);
            if (Z)
              return j.nextHandler();
            try {
              var Q = j.done ? void 0 : j.nextHandler();
              return L(Q, j.done);
            } catch (B) {
              throw j.done = !0, B;
            }
          },
          return: function() {
            var $ = K(this), j = $.iterator;
            if ($.done = !0, Z) {
              var Q = P(j, "return");
              return Q ? l(Q, j) : L(void 0, !0);
            }
            if ($.inner)
              try {
                _($.inner.iterator, "normal");
              } catch (B) {
                return _(j, "throw", B);
              }
            return _(j, "normal"), L(void 0, !0);
          }
        });
      }, z = N(!0), V = N(!1);
      f(V, D, "Iterator Helper"), u.exports = function(Z, K) {
        var $ = function(Q, B) {
          B ? (B.iterator = Q.iterator, B.next = Q.next) : B = Q, B.type = K ? H : k, B.nextHandler = Z, B.counter = 0, B.done = !1, X(this, B);
        };
        return $.prototype = K ? z : V, $;
      };
    }
  ),
  /***/
  713: (
    /***/
    (u, n, i) => {
      var l = i(9565), d = i(9306), f = i(8551), m = i(1767), y = i(9462), w = i(6319), P = y(function() {
        var I = this.iterator, L = f(l(this.next, I)), _ = this.done = !!L.done;
        if (!_)
          return w(I, this.mapper, [L.value, this.counter++], !0);
      });
      u.exports = function(L) {
        return f(this), d(L), new P(m(this), {
          mapper: L
        });
      };
    }
  ),
  /***/
  7657: (
    /***/
    (u, n, i) => {
      var l = i(9039), d = i(4901), f = i(34), m = i(2360), y = i(2787), w = i(6840), P = i(8227), I = i(6395), L = P("iterator"), _ = !1, D, k, H;
      [].keys && (H = [].keys(), "next" in H ? (k = y(y(H)), k !== Object.prototype && (D = k)) : _ = !0);
      var X = !f(D) || l(function() {
        var N = {};
        return D[L].call(N) !== N;
      });
      X ? D = {} : I && (D = m(D)), d(D[L]) || w(D, L, function() {
        return this;
      }), u.exports = {
        IteratorPrototype: D,
        BUGGY_SAFARI_ITERATORS: _
      };
    }
  ),
  /***/
  6269: (
    /***/
    (u) => {
      u.exports = {};
    }
  ),
  /***/
  6198: (
    /***/
    (u, n, i) => {
      var l = i(8014);
      u.exports = function(d) {
        return l(d.length);
      };
    }
  ),
  /***/
  283: (
    /***/
    (u, n, i) => {
      var l = i(9504), d = i(9039), f = i(4901), m = i(9297), y = i(3724), w = i(350).CONFIGURABLE, P = i(3706), I = i(1181), L = I.enforce, _ = I.get, D = String, k = Object.defineProperty, H = l("".slice), X = l("".replace), N = l([].join), z = y && !d(function() {
        return k(function() {
        }, "length", { value: 8 }).length !== 8;
      }), V = String(String).split("String"), Z = u.exports = function(K, $, j) {
        H(D($), 0, 7) === "Symbol(" && ($ = "[" + X(D($), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), j && j.getter && ($ = "get " + $), j && j.setter && ($ = "set " + $), (!m(K, "name") || w && K.name !== $) && (y ? k(K, "name", { value: $, configurable: !0 }) : K.name = $), z && j && m(j, "arity") && K.length !== j.arity && k(K, "length", { value: j.arity });
        try {
          j && m(j, "constructor") && j.constructor ? y && k(K, "prototype", { writable: !1 }) : K.prototype && (K.prototype = void 0);
        } catch {
        }
        var Q = L(K);
        return m(Q, "source") || (Q.source = N(V, typeof $ == "string" ? $ : "")), K;
      };
      Function.prototype.toString = Z(function() {
        return f(this) && _(this).source || P(this);
      }, "toString");
    }
  ),
  /***/
  741: (
    /***/
    (u) => {
      var n = Math.ceil, i = Math.floor;
      u.exports = Math.trunc || function(d) {
        var f = +d;
        return (f > 0 ? i : n)(f);
      };
    }
  ),
  /***/
  6043: (
    /***/
    (u, n, i) => {
      var l = i(9306), d = TypeError, f = function(m) {
        var y, w;
        this.promise = new m(function(P, I) {
          if (y !== void 0 || w !== void 0)
            throw new d("Bad Promise constructor");
          y = P, w = I;
        }), this.resolve = l(y), this.reject = l(w);
      };
      u.exports.f = function(m) {
        return new f(m);
      };
    }
  ),
  /***/
  2603: (
    /***/
    (u, n, i) => {
      var l = i(655);
      u.exports = function(d, f) {
        return d === void 0 ? arguments.length < 2 ? "" : f : l(d);
      };
    }
  ),
  /***/
  2360: (
    /***/
    (u, n, i) => {
      var l = i(8551), d = i(6801), f = i(8727), m = i(421), y = i(397), w = i(4055), P = i(6119), I = ">", L = "<", _ = "prototype", D = "script", k = P("IE_PROTO"), H = function() {
      }, X = function(K) {
        return L + D + I + K + L + "/" + D + I;
      }, N = function(K) {
        K.write(X("")), K.close();
        var $ = K.parentWindow.Object;
        return K = null, $;
      }, z = function() {
        var K = w("iframe"), $ = "java" + D + ":", j;
        return K.style.display = "none", y.appendChild(K), K.src = String($), j = K.contentWindow.document, j.open(), j.write(X("document.F=Object")), j.close(), j.F;
      }, V, Z = function() {
        try {
          V = new ActiveXObject("htmlfile");
        } catch {
        }
        Z = typeof document < "u" ? document.domain && V ? N(V) : z() : N(V);
        for (var K = f.length; K--; )
          delete Z[_][f[K]];
        return Z();
      };
      m[k] = !0, u.exports = Object.create || function($, j) {
        var Q;
        return $ !== null ? (H[_] = l($), Q = new H(), H[_] = null, Q[k] = $) : Q = Z(), j === void 0 ? Q : d.f(Q, j);
      };
    }
  ),
  /***/
  6801: (
    /***/
    (u, n, i) => {
      var l = i(3724), d = i(8686), f = i(4913), m = i(8551), y = i(5397), w = i(1072);
      n.f = l && !d ? Object.defineProperties : function(I, L) {
        m(I);
        for (var _ = y(L), D = w(L), k = D.length, H = 0, X; k > H; )
          f.f(I, X = D[H++], _[X]);
        return I;
      };
    }
  ),
  /***/
  4913: (
    /***/
    (u, n, i) => {
      var l = i(3724), d = i(5917), f = i(8686), m = i(8551), y = i(6969), w = TypeError, P = Object.defineProperty, I = Object.getOwnPropertyDescriptor, L = "enumerable", _ = "configurable", D = "writable";
      n.f = l ? f ? function(H, X, N) {
        if (m(H), X = y(X), m(N), typeof H == "function" && X === "prototype" && "value" in N && D in N && !N[D]) {
          var z = I(H, X);
          z && z[D] && (H[X] = N.value, N = {
            configurable: _ in N ? N[_] : z[_],
            enumerable: L in N ? N[L] : z[L],
            writable: !1
          });
        }
        return P(H, X, N);
      } : P : function(H, X, N) {
        if (m(H), X = y(X), m(N), d)
          try {
            return P(H, X, N);
          } catch {
          }
        if ("get" in N || "set" in N)
          throw new w("Accessors not supported");
        return "value" in N && (H[X] = N.value), H;
      };
    }
  ),
  /***/
  7347: (
    /***/
    (u, n, i) => {
      var l = i(3724), d = i(9565), f = i(8773), m = i(6980), y = i(5397), w = i(6969), P = i(9297), I = i(5917), L = Object.getOwnPropertyDescriptor;
      n.f = l ? L : function(D, k) {
        if (D = y(D), k = w(k), I)
          try {
            return L(D, k);
          } catch {
          }
        if (P(D, k))
          return m(!d(f.f, D, k), D[k]);
      };
    }
  ),
  /***/
  8480: (
    /***/
    (u, n, i) => {
      var l = i(1828), d = i(8727), f = d.concat("length", "prototype");
      n.f = Object.getOwnPropertyNames || function(y) {
        return l(y, f);
      };
    }
  ),
  /***/
  3717: (
    /***/
    (u, n) => {
      n.f = Object.getOwnPropertySymbols;
    }
  ),
  /***/
  2787: (
    /***/
    (u, n, i) => {
      var l = i(9297), d = i(4901), f = i(8981), m = i(6119), y = i(2211), w = m("IE_PROTO"), P = Object, I = P.prototype;
      u.exports = y ? P.getPrototypeOf : function(L) {
        var _ = f(L);
        if (l(_, w))
          return _[w];
        var D = _.constructor;
        return d(D) && _ instanceof D ? D.prototype : _ instanceof P ? I : null;
      };
    }
  ),
  /***/
  1625: (
    /***/
    (u, n, i) => {
      var l = i(9504);
      u.exports = l({}.isPrototypeOf);
    }
  ),
  /***/
  1828: (
    /***/
    (u, n, i) => {
      var l = i(9504), d = i(9297), f = i(5397), m = i(9617).indexOf, y = i(421), w = l([].push);
      u.exports = function(P, I) {
        var L = f(P), _ = 0, D = [], k;
        for (k in L)
          !d(y, k) && d(L, k) && w(D, k);
        for (; I.length > _; )
          d(L, k = I[_++]) && (~m(D, k) || w(D, k));
        return D;
      };
    }
  ),
  /***/
  1072: (
    /***/
    (u, n, i) => {
      var l = i(1828), d = i(8727);
      u.exports = Object.keys || function(m) {
        return l(m, d);
      };
    }
  ),
  /***/
  8773: (
    /***/
    (u, n) => {
      var i = {}.propertyIsEnumerable, l = Object.getOwnPropertyDescriptor, d = l && !i.call({ 1: 2 }, 1);
      n.f = d ? function(m) {
        var y = l(this, m);
        return !!y && y.enumerable;
      } : i;
    }
  ),
  /***/
  2967: (
    /***/
    (u, n, i) => {
      var l = i(6706), d = i(34), f = i(7750), m = i(3506);
      u.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var y = !1, w = {}, P;
        try {
          P = l(Object.prototype, "__proto__", "set"), P(w, []), y = w instanceof Array;
        } catch {
        }
        return function(L, _) {
          return f(L), m(_), d(L) && (y ? P(L, _) : L.__proto__ = _), L;
        };
      }() : void 0);
    }
  ),
  /***/
  4270: (
    /***/
    (u, n, i) => {
      var l = i(9565), d = i(4901), f = i(34), m = TypeError;
      u.exports = function(y, w) {
        var P, I;
        if (w === "string" && d(P = y.toString) && !f(I = l(P, y)) || d(P = y.valueOf) && !f(I = l(P, y)) || w !== "string" && d(P = y.toString) && !f(I = l(P, y)))
          return I;
        throw new m("Can't convert object to primitive value");
      };
    }
  ),
  /***/
  5031: (
    /***/
    (u, n, i) => {
      var l = i(7751), d = i(9504), f = i(8480), m = i(3717), y = i(8551), w = d([].concat);
      u.exports = l("Reflect", "ownKeys") || function(I) {
        var L = f.f(y(I)), _ = m.f;
        return _ ? w(L, _(I)) : L;
      };
    }
  ),
  /***/
  8235: (
    /***/
    (u, n, i) => {
      var l = i(9504), d = i(9297), f = SyntaxError, m = parseInt, y = String.fromCharCode, w = l("".charAt), P = l("".slice), I = l(/./.exec), L = {
        '\\"': '"',
        "\\\\": "\\",
        "\\/": "/",
        "\\b": "\b",
        "\\f": "\f",
        "\\n": `
`,
        "\\r": "\r",
        "\\t": "	"
      }, _ = /^[\da-f]{4}$/i, D = /^[\u0000-\u001F]$/;
      u.exports = function(k, H) {
        for (var X = !0, N = ""; H < k.length; ) {
          var z = w(k, H);
          if (z === "\\") {
            var V = P(k, H, H + 2);
            if (d(L, V))
              N += L[V], H += 2;
            else if (V === "\\u") {
              H += 2;
              var Z = P(k, H, H + 4);
              if (!I(_, Z))
                throw new f("Bad Unicode escape at: " + H);
              N += y(m(Z, 16)), H += 4;
            } else
              throw new f('Unknown escape sequence: "' + V + '"');
          } else if (z === '"') {
            X = !1, H++;
            break;
          } else {
            if (I(D, z))
              throw new f("Bad control character in string literal at: " + H);
            N += z, H++;
          }
        }
        if (X)
          throw new f("Unterminated string at: " + H);
        return { value: N, end: H };
      };
    }
  ),
  /***/
  7750: (
    /***/
    (u, n, i) => {
      var l = i(4117), d = TypeError;
      u.exports = function(f) {
        if (l(f))
          throw new d("Can't call method on " + f);
        return f;
      };
    }
  ),
  /***/
  9286: (
    /***/
    (u, n, i) => {
      var l = i(4402), d = i(8469), f = l.Set, m = l.add;
      u.exports = function(y) {
        var w = new f();
        return d(y, function(P) {
          m(w, P);
        }), w;
      };
    }
  ),
  /***/
  3440: (
    /***/
    (u, n, i) => {
      var l = i(7080), d = i(4402), f = i(9286), m = i(5170), y = i(3789), w = i(8469), P = i(507), I = d.has, L = d.remove;
      u.exports = function(D) {
        var k = l(this), H = y(D), X = f(k);
        return m(k) <= H.size ? w(k, function(N) {
          H.includes(N) && L(X, N);
        }) : P(H.getIterator(), function(N) {
          I(k, N) && L(X, N);
        }), X;
      };
    }
  ),
  /***/
  4402: (
    /***/
    (u, n, i) => {
      var l = i(9504), d = Set.prototype;
      u.exports = {
        // eslint-disable-next-line es/no-set -- safe
        Set,
        add: l(d.add),
        has: l(d.has),
        remove: l(d.delete),
        proto: d
      };
    }
  ),
  /***/
  8750: (
    /***/
    (u, n, i) => {
      var l = i(7080), d = i(4402), f = i(5170), m = i(3789), y = i(8469), w = i(507), P = d.Set, I = d.add, L = d.has;
      u.exports = function(D) {
        var k = l(this), H = m(D), X = new P();
        return f(k) > H.size ? w(H.getIterator(), function(N) {
          L(k, N) && I(X, N);
        }) : y(k, function(N) {
          H.includes(N) && I(X, N);
        }), X;
      };
    }
  ),
  /***/
  4449: (
    /***/
    (u, n, i) => {
      var l = i(7080), d = i(4402).has, f = i(5170), m = i(3789), y = i(8469), w = i(507), P = i(9539);
      u.exports = function(L) {
        var _ = l(this), D = m(L);
        if (f(_) <= D.size)
          return y(_, function(H) {
            if (D.includes(H))
              return !1;
          }, !0) !== !1;
        var k = D.getIterator();
        return w(k, function(H) {
          if (d(_, H))
            return P(k, "normal", !1);
        }) !== !1;
      };
    }
  ),
  /***/
  3838: (
    /***/
    (u, n, i) => {
      var l = i(7080), d = i(5170), f = i(8469), m = i(3789);
      u.exports = function(w) {
        var P = l(this), I = m(w);
        return d(P) > I.size ? !1 : f(P, function(L) {
          if (!I.includes(L))
            return !1;
        }, !0) !== !1;
      };
    }
  ),
  /***/
  8527: (
    /***/
    (u, n, i) => {
      var l = i(7080), d = i(4402).has, f = i(5170), m = i(3789), y = i(507), w = i(9539);
      u.exports = function(I) {
        var L = l(this), _ = m(I);
        if (f(L) < _.size)
          return !1;
        var D = _.getIterator();
        return y(D, function(k) {
          if (!d(L, k))
            return w(D, "normal", !1);
        }) !== !1;
      };
    }
  ),
  /***/
  8469: (
    /***/
    (u, n, i) => {
      var l = i(9504), d = i(507), f = i(4402), m = f.Set, y = f.proto, w = l(y.forEach), P = l(y.keys), I = P(new m()).next;
      u.exports = function(L, _, D) {
        return D ? d({ iterator: P(L), next: I }, _) : w(L, _);
      };
    }
  ),
  /***/
  4916: (
    /***/
    (u, n, i) => {
      var l = i(7751), d = function(f) {
        return {
          size: f,
          has: function() {
            return !1;
          },
          keys: function() {
            return {
              next: function() {
                return { done: !0 };
              }
            };
          }
        };
      };
      u.exports = function(f) {
        var m = l("Set");
        try {
          new m()[f](d(0));
          try {
            return new m()[f](d(-1)), !1;
          } catch {
            return !0;
          }
        } catch {
          return !1;
        }
      };
    }
  ),
  /***/
  5170: (
    /***/
    (u, n, i) => {
      var l = i(6706), d = i(4402);
      u.exports = l(d.proto, "size", "get") || function(f) {
        return f.size;
      };
    }
  ),
  /***/
  3650: (
    /***/
    (u, n, i) => {
      var l = i(7080), d = i(4402), f = i(9286), m = i(3789), y = i(507), w = d.add, P = d.has, I = d.remove;
      u.exports = function(_) {
        var D = l(this), k = m(_).getIterator(), H = f(D);
        return y(k, function(X) {
          P(D, X) ? I(H, X) : w(H, X);
        }), H;
      };
    }
  ),
  /***/
  4204: (
    /***/
    (u, n, i) => {
      var l = i(7080), d = i(4402).add, f = i(9286), m = i(3789), y = i(507);
      u.exports = function(P) {
        var I = l(this), L = m(P).getIterator(), _ = f(I);
        return y(L, function(D) {
          d(_, D);
        }), _;
      };
    }
  ),
  /***/
  6119: (
    /***/
    (u, n, i) => {
      var l = i(5745), d = i(3392), f = l("keys");
      u.exports = function(m) {
        return f[m] || (f[m] = d(m));
      };
    }
  ),
  /***/
  7629: (
    /***/
    (u, n, i) => {
      var l = i(6395), d = i(4475), f = i(9433), m = "__core-js_shared__", y = u.exports = d[m] || f(m, {});
      (y.versions || (y.versions = [])).push({
        version: "3.37.1",
        mode: l ? "pure" : "global",
        copyright: "© 2014-2024 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.37.1/LICENSE",
        source: "https://github.com/zloirock/core-js"
      });
    }
  ),
  /***/
  5745: (
    /***/
    (u, n, i) => {
      var l = i(7629);
      u.exports = function(d, f) {
        return l[d] || (l[d] = f || {});
      };
    }
  ),
  /***/
  1548: (
    /***/
    (u, n, i) => {
      var l = i(4475), d = i(9039), f = i(7388), m = i(7290), y = i(516), w = i(9088), P = l.structuredClone;
      u.exports = !!P && !d(function() {
        if (y && f > 92 || w && f > 94 || m && f > 97)
          return !1;
        var I = new ArrayBuffer(8), L = P(I, { transfer: [I] });
        return I.byteLength !== 0 || L.byteLength !== 8;
      });
    }
  ),
  /***/
  4495: (
    /***/
    (u, n, i) => {
      var l = i(7388), d = i(9039), f = i(4475), m = f.String;
      u.exports = !!Object.getOwnPropertySymbols && !d(function() {
        var y = Symbol("symbol detection");
        return !m(y) || !(Object(y) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
        !Symbol.sham && l && l < 41;
      });
    }
  ),
  /***/
  5610: (
    /***/
    (u, n, i) => {
      var l = i(1291), d = Math.max, f = Math.min;
      u.exports = function(m, y) {
        var w = l(m);
        return w < 0 ? d(w + y, 0) : f(w, y);
      };
    }
  ),
  /***/
  5854: (
    /***/
    (u, n, i) => {
      var l = i(2777), d = TypeError;
      u.exports = function(f) {
        var m = l(f, "number");
        if (typeof m == "number")
          throw new d("Can't convert number to bigint");
        return BigInt(m);
      };
    }
  ),
  /***/
  7696: (
    /***/
    (u, n, i) => {
      var l = i(1291), d = i(8014), f = RangeError;
      u.exports = function(m) {
        if (m === void 0)
          return 0;
        var y = l(m), w = d(y);
        if (y !== w)
          throw new f("Wrong length or index");
        return w;
      };
    }
  ),
  /***/
  5397: (
    /***/
    (u, n, i) => {
      var l = i(7055), d = i(7750);
      u.exports = function(f) {
        return l(d(f));
      };
    }
  ),
  /***/
  1291: (
    /***/
    (u, n, i) => {
      var l = i(741);
      u.exports = function(d) {
        var f = +d;
        return f !== f || f === 0 ? 0 : l(f);
      };
    }
  ),
  /***/
  8014: (
    /***/
    (u, n, i) => {
      var l = i(1291), d = Math.min;
      u.exports = function(f) {
        var m = l(f);
        return m > 0 ? d(m, 9007199254740991) : 0;
      };
    }
  ),
  /***/
  8981: (
    /***/
    (u, n, i) => {
      var l = i(7750), d = Object;
      u.exports = function(f) {
        return d(l(f));
      };
    }
  ),
  /***/
  2777: (
    /***/
    (u, n, i) => {
      var l = i(9565), d = i(34), f = i(757), m = i(5966), y = i(4270), w = i(8227), P = TypeError, I = w("toPrimitive");
      u.exports = function(L, _) {
        if (!d(L) || f(L))
          return L;
        var D = m(L, I), k;
        if (D) {
          if (_ === void 0 && (_ = "default"), k = l(D, L, _), !d(k) || f(k))
            return k;
          throw new P("Can't convert object to primitive value");
        }
        return _ === void 0 && (_ = "number"), y(L, _);
      };
    }
  ),
  /***/
  6969: (
    /***/
    (u, n, i) => {
      var l = i(2777), d = i(757);
      u.exports = function(f) {
        var m = l(f, "string");
        return d(m) ? m : m + "";
      };
    }
  ),
  /***/
  2140: (
    /***/
    (u, n, i) => {
      var l = i(8227), d = l("toStringTag"), f = {};
      f[d] = "z", u.exports = String(f) === "[object z]";
    }
  ),
  /***/
  655: (
    /***/
    (u, n, i) => {
      var l = i(6955), d = String;
      u.exports = function(f) {
        if (l(f) === "Symbol")
          throw new TypeError("Cannot convert a Symbol value to a string");
        return d(f);
      };
    }
  ),
  /***/
  9714: (
    /***/
    (u, n, i) => {
      var l = i(9088);
      u.exports = function(d) {
        try {
          if (l)
            return Function('return require("' + d + '")')();
        } catch {
        }
      };
    }
  ),
  /***/
  6823: (
    /***/
    (u) => {
      var n = String;
      u.exports = function(i) {
        try {
          return n(i);
        } catch {
          return "Object";
        }
      };
    }
  ),
  /***/
  3392: (
    /***/
    (u, n, i) => {
      var l = i(9504), d = 0, f = Math.random(), m = l(1 .toString);
      u.exports = function(y) {
        return "Symbol(" + (y === void 0 ? "" : y) + ")_" + m(++d + f, 36);
      };
    }
  ),
  /***/
  7040: (
    /***/
    (u, n, i) => {
      var l = i(4495);
      u.exports = l && !Symbol.sham && typeof Symbol.iterator == "symbol";
    }
  ),
  /***/
  8686: (
    /***/
    (u, n, i) => {
      var l = i(3724), d = i(9039);
      u.exports = l && d(function() {
        return Object.defineProperty(function() {
        }, "prototype", {
          value: 42,
          writable: !1
        }).prototype !== 42;
      });
    }
  ),
  /***/
  2812: (
    /***/
    (u) => {
      var n = TypeError;
      u.exports = function(i, l) {
        if (i < l)
          throw new n("Not enough arguments");
        return i;
      };
    }
  ),
  /***/
  8622: (
    /***/
    (u, n, i) => {
      var l = i(4475), d = i(4901), f = l.WeakMap;
      u.exports = d(f) && /native code/.test(String(f));
    }
  ),
  /***/
  8227: (
    /***/
    (u, n, i) => {
      var l = i(4475), d = i(5745), f = i(9297), m = i(3392), y = i(4495), w = i(7040), P = l.Symbol, I = d("wks"), L = w ? P.for || P : P && P.withoutSetter || m;
      u.exports = function(_) {
        return f(I, _) || (I[_] = y && f(P, _) ? P[_] : L("Symbol." + _)), I[_];
      };
    }
  ),
  /***/
  6573: (
    /***/
    (u, n, i) => {
      var l = i(3724), d = i(2106), f = i(3238), m = ArrayBuffer.prototype;
      l && !("detached" in m) && d(m, "detached", {
        configurable: !0,
        get: function() {
          return f(this);
        }
      });
    }
  ),
  /***/
  7936: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(5636);
      d && l({ target: "ArrayBuffer", proto: !0 }, {
        transferToFixedLength: function() {
          return d(this, arguments.length ? arguments[0] : void 0, !1);
        }
      });
    }
  ),
  /***/
  8100: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(5636);
      d && l({ target: "ArrayBuffer", proto: !0 }, {
        transfer: function() {
          return d(this, arguments.length ? arguments[0] : void 0, !0);
        }
      });
    }
  ),
  /***/
  4114: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(8981), f = i(6198), m = i(4527), y = i(6837), w = i(9039), P = w(function() {
        return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
      }), I = function() {
        try {
          Object.defineProperty([], "length", { writable: !1 }).push();
        } catch (_) {
          return _ instanceof TypeError;
        }
      }, L = P || !I();
      l({ target: "Array", proto: !0, arity: 1, forced: L }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        push: function(D) {
          var k = d(this), H = f(k), X = arguments.length;
          y(H + X);
          for (var N = 0; N < X; N++)
            k[H] = arguments[N], H++;
          return m(k, H), H;
        }
      });
    }
  ),
  /***/
  4628: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(6043);
      l({ target: "Promise", stat: !0 }, {
        withResolvers: function() {
          var m = d.f(this);
          return {
            promise: m.promise,
            resolve: m.resolve,
            reject: m.reject
          };
        }
      });
    }
  ),
  /***/
  7642: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(3440), f = i(4916);
      l({ target: "Set", proto: !0, real: !0, forced: !f("difference") }, {
        difference: d
      });
    }
  ),
  /***/
  8004: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(9039), f = i(8750), m = i(4916), y = !m("intersection") || d(function() {
        return String(Array.from((/* @__PURE__ */ new Set([1, 2, 3])).intersection(/* @__PURE__ */ new Set([3, 2])))) !== "3,2";
      });
      l({ target: "Set", proto: !0, real: !0, forced: y }, {
        intersection: f
      });
    }
  ),
  /***/
  3853: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(4449), f = i(4916);
      l({ target: "Set", proto: !0, real: !0, forced: !f("isDisjointFrom") }, {
        isDisjointFrom: d
      });
    }
  ),
  /***/
  5876: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(3838), f = i(4916);
      l({ target: "Set", proto: !0, real: !0, forced: !f("isSubsetOf") }, {
        isSubsetOf: d
      });
    }
  ),
  /***/
  2475: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(8527), f = i(4916);
      l({ target: "Set", proto: !0, real: !0, forced: !f("isSupersetOf") }, {
        isSupersetOf: d
      });
    }
  ),
  /***/
  5024: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(3650), f = i(4916);
      l({ target: "Set", proto: !0, real: !0, forced: !f("symmetricDifference") }, {
        symmetricDifference: d
      });
    }
  ),
  /***/
  1698: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(4204), f = i(4916);
      l({ target: "Set", proto: !0, real: !0, forced: !f("union") }, {
        union: d
      });
    }
  ),
  /***/
  7467: (
    /***/
    (u, n, i) => {
      var l = i(7628), d = i(4644), f = d.aTypedArray, m = d.exportTypedArrayMethod, y = d.getTypedArrayConstructor;
      m("toReversed", function() {
        return l(f(this), y(this));
      });
    }
  ),
  /***/
  4732: (
    /***/
    (u, n, i) => {
      var l = i(4644), d = i(9504), f = i(9306), m = i(5370), y = l.aTypedArray, w = l.getTypedArrayConstructor, P = l.exportTypedArrayMethod, I = d(l.TypedArrayPrototype.sort);
      P("toSorted", function(_) {
        _ !== void 0 && f(_);
        var D = y(this), k = m(w(D), D);
        return I(k, _);
      });
    }
  ),
  /***/
  9577: (
    /***/
    (u, n, i) => {
      var l = i(9928), d = i(4644), f = i(1108), m = i(1291), y = i(5854), w = d.aTypedArray, P = d.getTypedArrayConstructor, I = d.exportTypedArrayMethod, L = !!function() {
        try {
          new Int8Array(1).with(2, { valueOf: function() {
            throw 8;
          } });
        } catch (_) {
          return _ === 8;
        }
      }();
      I("with", function(_, D) {
        var k = w(this), H = m(_), X = f(k) ? y(D) : +D;
        return l(k, P(k), H, X);
      }, !L);
    }
  ),
  /***/
  8992: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(4475), f = i(679), m = i(8551), y = i(4901), w = i(2787), P = i(2106), I = i(4659), L = i(9039), _ = i(9297), D = i(8227), k = i(7657).IteratorPrototype, H = i(3724), X = i(6395), N = "constructor", z = "Iterator", V = D("toStringTag"), Z = TypeError, K = d[z], $ = X || !y(K) || K.prototype !== k || !L(function() {
        K({});
      }), j = function() {
        if (f(this, k), w(this) === k)
          throw new Z("Abstract class Iterator not directly constructable");
      }, Q = function(B, G) {
        H ? P(k, B, {
          configurable: !0,
          get: function() {
            return G;
          },
          set: function(q) {
            if (m(this), this === k)
              throw new Z("You can't redefine this property");
            _(this, B) ? this[B] = q : I(this, B, q);
          }
        }) : k[B] = G;
      };
      _(k, V) || Q(V, z), ($ || !_(k, N) || k[N] === Object) && Q(N, j), j.prototype = k, l({ global: !0, constructor: !0, forced: $ }, {
        Iterator: j
      });
    }
  ),
  /***/
  3215: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(2652), f = i(9306), m = i(8551), y = i(1767);
      l({ target: "Iterator", proto: !0, real: !0 }, {
        every: function(P) {
          m(this), f(P);
          var I = y(this), L = 0;
          return !d(I, function(_, D) {
            if (!P(_, L++))
              return D();
          }, { IS_RECORD: !0, INTERRUPTED: !0 }).stopped;
        }
      });
    }
  ),
  /***/
  4520: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(9565), f = i(9306), m = i(8551), y = i(1767), w = i(9462), P = i(6319), I = i(6395), L = w(function() {
        for (var _ = this.iterator, D = this.predicate, k = this.next, H, X, N; ; ) {
          if (H = m(d(k, _)), X = this.done = !!H.done, X)
            return;
          if (N = H.value, P(_, D, [N, this.counter++], !0))
            return N;
        }
      });
      l({ target: "Iterator", proto: !0, real: !0, forced: I }, {
        filter: function(D) {
          return m(this), f(D), new L(y(this), {
            predicate: D
          });
        }
      });
    }
  ),
  /***/
  670: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(9565), f = i(9306), m = i(8551), y = i(1767), w = i(8646), P = i(9462), I = i(9539), L = i(6395), _ = P(function() {
        for (var D = this.iterator, k = this.mapper, H, X; ; ) {
          if (X = this.inner)
            try {
              if (H = m(d(X.next, X.iterator)), !H.done)
                return H.value;
              this.inner = null;
            } catch (N) {
              I(D, "throw", N);
            }
          if (H = m(d(this.next, D)), this.done = !!H.done)
            return;
          try {
            this.inner = w(k(H.value, this.counter++), !1);
          } catch (N) {
            I(D, "throw", N);
          }
        }
      });
      l({ target: "Iterator", proto: !0, real: !0, forced: L }, {
        flatMap: function(k) {
          return m(this), f(k), new _(y(this), {
            mapper: k,
            inner: null
          });
        }
      });
    }
  ),
  /***/
  1454: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(713), f = i(6395);
      l({ target: "Iterator", proto: !0, real: !0, forced: f }, {
        map: d
      });
    }
  ),
  /***/
  7550: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(2652), f = i(9306), m = i(8551), y = i(1767);
      l({ target: "Iterator", proto: !0, real: !0 }, {
        some: function(P) {
          m(this), f(P);
          var I = y(this), L = 0;
          return d(I, function(_, D) {
            if (P(_, L++))
              return D();
          }, { IS_RECORD: !0, INTERRUPTED: !0 }).stopped;
        }
      });
    }
  ),
  /***/
  8335: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(3724), f = i(4475), m = i(7751), y = i(9504), w = i(9565), P = i(4901), I = i(34), L = i(4376), _ = i(9297), D = i(655), k = i(6198), H = i(4659), X = i(9039), N = i(8235), z = i(4495), V = f.JSON, Z = f.Number, K = f.SyntaxError, $ = V && V.parse, j = m("Object", "keys"), Q = Object.getOwnPropertyDescriptor, B = y("".charAt), G = y("".slice), q = y(/./.exec), tt = y([].push), lt = /^\d$/, vt = /^[1-9]$/, dt = /^(?:-|\d)$/, W = /^[\t\n\r ]$/, Et = 0, Pt = 1, Ht = function(ht, nt) {
        ht = D(ht);
        var at = new Gs(ht, 0), et = at.parse(), Mt = et.value, ct = at.skip(W, et.end);
        if (ct < ht.length)
          throw new K('Unexpected extra character: "' + B(ht, ct) + '" after the parsed data at: ' + ct);
        return P(nt) ? Ft({ "": Mt }, "", nt, et) : Mt;
      }, Ft = function(ht, nt, at, et) {
        var Mt = ht[nt], ct = et && Mt === et.value, Bt = ct && typeof et.source == "string" ? { source: et.source } : {}, Vt, Ge, ne, Lt, is;
        if (I(Mt)) {
          var Hi = L(Mt), Xs = ct ? et.nodes : Hi ? [] : {};
          if (Hi)
            for (Vt = Xs.length, ne = k(Mt), Lt = 0; Lt < ne; Lt++)
              We(Mt, Lt, Ft(Mt, "" + Lt, at, Lt < Vt ? Xs[Lt] : void 0));
          else
            for (Ge = j(Mt), ne = k(Ge), Lt = 0; Lt < ne; Lt++)
              is = Ge[Lt], We(Mt, is, Ft(Mt, is, at, _(Xs, is) ? Xs[is] : void 0));
        }
        return w(at, ht, nt, Mt, Bt);
      }, We = function(ht, nt, at) {
        if (d) {
          var et = Q(ht, nt);
          if (et && !et.configurable)
            return;
        }
        at === void 0 ? delete ht[nt] : H(ht, nt, at);
      }, be = function(ht, nt, at, et) {
        this.value = ht, this.end = nt, this.source = at, this.nodes = et;
      }, Gs = function(ht, nt) {
        this.source = ht, this.index = nt;
      };
      Gs.prototype = {
        fork: function(ht) {
          return new Gs(this.source, ht);
        },
        parse: function() {
          var ht = this.source, nt = this.skip(W, this.index), at = this.fork(nt), et = B(ht, nt);
          if (q(dt, et))
            return at.number();
          switch (et) {
            case "{":
              return at.object();
            case "[":
              return at.array();
            case '"':
              return at.string();
            case "t":
              return at.keyword(!0);
            case "f":
              return at.keyword(!1);
            case "n":
              return at.keyword(null);
          }
          throw new K('Unexpected character: "' + et + '" at: ' + nt);
        },
        node: function(ht, nt, at, et, Mt) {
          return new be(nt, et, ht ? null : G(this.source, at, et), Mt);
        },
        object: function() {
          for (var ht = this.source, nt = this.index + 1, at = !1, et = {}, Mt = {}; nt < ht.length; ) {
            if (nt = this.until(['"', "}"], nt), B(ht, nt) === "}" && !at) {
              nt++;
              break;
            }
            var ct = this.fork(nt).string(), Bt = ct.value;
            nt = ct.end, nt = this.until([":"], nt) + 1, nt = this.skip(W, nt), ct = this.fork(nt).parse(), H(Mt, Bt, ct), H(et, Bt, ct.value), nt = this.until([",", "}"], ct.end);
            var Vt = B(ht, nt);
            if (Vt === ",")
              at = !0, nt++;
            else if (Vt === "}") {
              nt++;
              break;
            }
          }
          return this.node(Pt, et, this.index, nt, Mt);
        },
        array: function() {
          for (var ht = this.source, nt = this.index + 1, at = !1, et = [], Mt = []; nt < ht.length; ) {
            if (nt = this.skip(W, nt), B(ht, nt) === "]" && !at) {
              nt++;
              break;
            }
            var ct = this.fork(nt).parse();
            if (tt(Mt, ct), tt(et, ct.value), nt = this.until([",", "]"], ct.end), B(ht, nt) === ",")
              at = !0, nt++;
            else if (B(ht, nt) === "]") {
              nt++;
              break;
            }
          }
          return this.node(Pt, et, this.index, nt, Mt);
        },
        string: function() {
          var ht = this.index, nt = N(this.source, this.index + 1);
          return this.node(Et, nt.value, ht, nt.end);
        },
        number: function() {
          var ht = this.source, nt = this.index, at = nt;
          if (B(ht, at) === "-" && at++, B(ht, at) === "0")
            at++;
          else if (q(vt, B(ht, at)))
            at = this.skip(lt, ++at);
          else
            throw new K("Failed to parse number at: " + at);
          if (B(ht, at) === "." && (at = this.skip(lt, ++at)), B(ht, at) === "e" || B(ht, at) === "E") {
            at++, (B(ht, at) === "+" || B(ht, at) === "-") && at++;
            var et = at;
            if (at = this.skip(lt, at), et === at)
              throw new K("Failed to parse number's exponent value at: " + at);
          }
          return this.node(Et, Z(G(ht, nt, at)), nt, at);
        },
        keyword: function(ht) {
          var nt = "" + ht, at = this.index, et = at + nt.length;
          if (G(this.source, at, et) !== nt)
            throw new K("Failed to parse value at: " + at);
          return this.node(Et, ht, at, et);
        },
        skip: function(ht, nt) {
          for (var at = this.source; nt < at.length && q(ht, B(at, nt)); nt++)
            ;
          return nt;
        },
        until: function(ht, nt) {
          nt = this.skip(W, nt);
          for (var at = B(this.source, nt), et = 0; et < ht.length; et++)
            if (ht[et] === at)
              return nt;
          throw new K('Unexpected character: "' + at + '" at: ' + nt);
        }
      };
      var Bn = X(function() {
        var ht = "9007199254740993", nt;
        return $(ht, function(at, et, Mt) {
          nt = Mt.source;
        }), nt !== ht;
      }), Ta = z && !X(function() {
        return 1 / $("-0 	") !== -1 / 0;
      });
      l({ target: "JSON", stat: !0, forced: Bn }, {
        parse: function(nt, at) {
          return Ta && !P(at) ? $(nt) : Ht(nt, at);
        }
      });
    }
  ),
  /***/
  3375: (
    /***/
    (u, n, i) => {
      i(7642);
    }
  ),
  /***/
  9225: (
    /***/
    (u, n, i) => {
      i(8004);
    }
  ),
  /***/
  3972: (
    /***/
    (u, n, i) => {
      i(3853);
    }
  ),
  /***/
  9209: (
    /***/
    (u, n, i) => {
      i(5876);
    }
  ),
  /***/
  5714: (
    /***/
    (u, n, i) => {
      i(2475);
    }
  ),
  /***/
  7561: (
    /***/
    (u, n, i) => {
      i(5024);
    }
  ),
  /***/
  6197: (
    /***/
    (u, n, i) => {
      i(1698);
    }
  ),
  /***/
  4979: (
    /***/
    (u, n, i) => {
      var l = i(6518), d = i(4475), f = i(7751), m = i(6980), y = i(4913).f, w = i(9297), P = i(679), I = i(3167), L = i(2603), _ = i(5002), D = i(6193), k = i(3724), H = i(6395), X = "DOMException", N = f("Error"), z = f(X), V = function() {
        P(this, Z);
        var W = arguments.length, Et = L(W < 1 ? void 0 : arguments[0]), Pt = L(W < 2 ? void 0 : arguments[1], "Error"), Ht = new z(Et, Pt), Ft = new N(Et);
        return Ft.name = X, y(Ht, "stack", m(1, D(Ft.stack, 1))), I(Ht, this, V), Ht;
      }, Z = V.prototype = z.prototype, K = "stack" in new N(X), $ = "stack" in new z(1, 2), j = z && k && Object.getOwnPropertyDescriptor(d, X), Q = !!j && !(j.writable && j.configurable), B = K && !Q && !$;
      l({ global: !0, constructor: !0, forced: H || B }, {
        // TODO: fix export logic
        DOMException: B ? V : z
      });
      var G = f(X), q = G.prototype;
      if (q.constructor !== G) {
        H || y(q, "constructor", m(1, G));
        for (var tt in _)
          if (w(_, tt)) {
            var lt = _[tt], vt = lt.s;
            w(G, vt) || y(G, vt, m(6, lt.c));
          }
      }
    }
  ),
  /***/
  4603: (
    /***/
    (u, n, i) => {
      var l = i(6840), d = i(9504), f = i(655), m = i(2812), y = URLSearchParams, w = y.prototype, P = d(w.append), I = d(w.delete), L = d(w.forEach), _ = d([].push), D = new y("a=1&a=2&b=3");
      D.delete("a", 1), D.delete("b", void 0), D + "" != "a=2" && l(w, "delete", function(k) {
        var H = arguments.length, X = H < 2 ? void 0 : arguments[1];
        if (H && X === void 0)
          return I(this, k);
        var N = [];
        L(this, function(B, G) {
          _(N, { key: G, value: B });
        }), m(H, 1);
        for (var z = f(k), V = f(X), Z = 0, K = 0, $ = !1, j = N.length, Q; Z < j; )
          Q = N[Z++], $ || Q.key === z ? ($ = !0, I(this, Q.key)) : K++;
        for (; K < j; )
          Q = N[K++], Q.key === z && Q.value === V || P(this, Q.key, Q.value);
      }, { enumerable: !0, unsafe: !0 });
    }
  ),
  /***/
  7566: (
    /***/
    (u, n, i) => {
      var l = i(6840), d = i(9504), f = i(655), m = i(2812), y = URLSearchParams, w = y.prototype, P = d(w.getAll), I = d(w.has), L = new y("a=1");
      (L.has("a", 2) || !L.has("a", void 0)) && l(w, "has", function(D) {
        var k = arguments.length, H = k < 2 ? void 0 : arguments[1];
        if (k && H === void 0)
          return I(this, D);
        var X = P(this, D);
        m(k, 1);
        for (var N = f(H), z = 0; z < X.length; )
          if (X[z++] === N)
            return !0;
        return !1;
      }, { enumerable: !0, unsafe: !0 });
    }
  ),
  /***/
  8721: (
    /***/
    (u, n, i) => {
      var l = i(3724), d = i(9504), f = i(2106), m = URLSearchParams.prototype, y = d(m.forEach);
      l && !("size" in m) && f(m, "size", {
        get: function() {
          var P = 0;
          return y(this, function() {
            P++;
          }), P;
        },
        configurable: !0,
        enumerable: !0
      });
    }
  )
  /******/
}, uy = {};
function Ct(u) {
  var n = uy[u];
  if (n !== void 0)
    return n.exports;
  var i = uy[u] = {
    /******/
    // no module.id needed
    /******/
    // no module.loaded needed
    /******/
    exports: {}
    /******/
  };
  return nS[u].call(i.exports, i, i.exports, Ct), i.exports;
}
Ct.d = (u, n) => {
  for (var i in n)
    Ct.o(n, i) && !Ct.o(u, i) && Object.defineProperty(u, i, { enumerable: !0, get: n[i] });
};
Ct.o = (u, n) => Object.prototype.hasOwnProperty.call(u, n);
var pt = globalThis.pdfjsLib = {};
(() => {
  var La, Lp, Bl, zm, zn, ws, qs, Oe, Vu, Wn, re, Ae, Ui, Yo, zi, Qo, _a, _p, $u, Qy, jl, Wm, Wi, Zo, Gn, ud, Xn, fd, Hl, Gm, Kn, pd, Yn, Qn, Ss, Zn, Uu, Zy, zu, Jy, Wu, qy, Ma, Mp, Gu, tA, Vl, Xm, $l, Jn, Ul, Ku, eA, Yu, sA, Qu, iA, Zu, zl, Ju, Ke, Wl, Km, ae, Gi, Gl, oe, qu, nA, Fe, qt, le, Oa, ti, ka, ns, Da, qn, xs, ei, tr, Xl, Kl, Ps, Na, Xi, Ts, ef, Ki, Yl, er, Ql, Fa, he, It, si, sr, Zl, Jl, ql, th, eh, sh, ih, nh, rh, ah, oh, lh, hh, ch, Yi, Cs, ii, dh, Ba, Op, sf, rA, nf, aA, ja, kp, rf, oA, af, lA, of, hA, uh, Ym, fh, Qm, ph, Zm, gh, Jm, mh, qm, ce, Re, Rs, vn, lf, cA, hf, dA, vh, tv, cf, uA, ir, gd, bh, ev, ni, ri, rs, ai, as, Va, oi, yh, sv, os, xe, $a, nr, de, rr, Ua, za, ye, Ah, ar, Qi, Eh, or, hi, Is, Wa, Ga, Ye, wh, df, Sh, iv, xh, nv, Ph, rv, uf, fA, ff, pA, Th, av, Ch, ov, Rh, lv, pf, gA, gf, mA, mf, vA, vf, bA, Ih, hv, lr, md, hr, ue, bf, yA, Lh, Xa, _h, cv, Mh, dv, Oh, kh, Af, AA, Ef, EA, Ka, Dp, cr, Dh, Nh, Fh, Bh, Ya, Zi, _t, Qa, Za, jh, uv, ly, Ji, ke, Hh, Vh, dr, ci, $h, Uh, ur, Ja, qa, qi, to, zh, eo, fr, Wh, Gh, pr, gr, so, wf, wA, Sf, SA, Xh, fv, io, Np, xf, xA, Pf, tn, di, en, Jo, no, Fp, mr, Cf, vr, ro, Bp, ui, Ls, ao, oo, _s, br, vd, ls, Kh, pv, sn, yr, Er, lo, ho, Yh, gv, fi, qr, Rf, PA, If, TA, co, Lf, _f, uo, wr, Xt, pi, Sr, Qh, Zh, fo, gi, hs, mi, Jh, vi, qh, xr, Pr, po, jp, tc, mv, Mf, CA, Of, RA, kf, IA, Df, LA, go, Hp, mo, Vp, ec, vv, sc, ic, nc, rc, ac, oc, lc, bv, hc, Tr, vo, Nf, _A, cc, yv, dc, uc, fc, pc, gc, cs, je, mc, He, bo, Ff, MA, Bf, OA, jf, kA, yo, $p, Ao, Up, Eo, zp, Hf, DA, vc, Av, Vf, NA, bc, nn, ds, $f, FA, wo, Wp, Uf, BA, zf, jA, yc, Ev, Ac, So, Ms, bi, xo, Po, Os, wt, Cr, Rr, Ec, wc, To, Co, rn, Sc, Wf, Gf, xc, wv, Ro, Ir, Ai, Pc, Ve, Tc, Qt, Lr, bd, _r, yd, Xf, HA, Cc, Rc, us, Mr, Io, te, Ic, Lo, Lc, _c, an, _o, Mc, Sv, Oc, xv, Kf, VA, Ei, ta, Yf, $A, ks, bn, Mo, kc, on, Or, Oo, Ze, Dc, Nc, kr, fs, Pe, $e, Qf, ko, Dr, ee, Do, Ds, Fc, Bc, Pv, jc, Tv, Zf, UA, Jf, zA, qf, WA, Hc, Cv, Nr, Ad, ln, qo, tp, GA, No, Gp, Fr, Ed, ep, XA, sp, KA, ip, YA, np, QA, Br, jr, Vc, $c, Uc, Hr, Ns, Si, Je, Vr, $r, Ur, zr, Wr, hn, rp, ZA, ap, JA, op, qA, lp, tE, zc, Rv, hp, eE, Wc, Iv, cp, sE, dp, iE, up, nE, fp, rE, pp, aE, xi, ea, Gc, Lv, Fo, Xp, Bo, Kp, cn, tl, Xc, _v, jo, Yp, gp, oE, Kc, Mv, mp, lE, vp, hE, Yc, Ov, Ho, Qp, Gr, wd, fe, pe, dn, Pi, un, Vo, Fs, Xr, Bs, ps, Qc, Kr, Sd, Yr, xd, $o, Zp, Zc, kv, bp, cE, yp, dE, Jc, Dv, Uo, Jp, Ap, uE, Qr, zo, js, Zr, Ti, Ci, Ri, Ue, fn, Wo, Go, Te, ut, pn, Ep, fE, td, Nv, ed, Fv, sd, Bv, Xo, qp, Hs, id, se, gn, nd, jv, rd, Hv, wp, pE;
  Ct.d(pt, {
    AbortException: () => (
      /* reexport */
      Ft
    ),
    AnnotationEditorLayer: () => (
      /* reexport */
      Cm
    ),
    AnnotationEditorParamsType: () => (
      /* reexport */
      P
    ),
    AnnotationEditorType: () => (
      /* reexport */
      w
    ),
    AnnotationEditorUIManager: () => (
      /* reexport */
      Hn
    ),
    AnnotationLayer: () => (
      /* reexport */
      Ww
    ),
    AnnotationMode: () => (
      /* reexport */
      m
    ),
    CMapCompressionType: () => (
      /* reexport */
      X
    ),
    ColorPicker: () => (
      /* reexport */
      ju
    ),
    DOMSVGFactory: () => (
      /* reexport */
      em
    ),
    DrawLayer: () => (
      /* reexport */
      Rm
    ),
    FeatureTest: () => (
      /* reexport */
      nt
    ),
    GlobalWorkerOptions: () => (
      /* reexport */
      Qs
    ),
    ImageKind: () => (
      /* reexport */
      _
    ),
    InvalidPDFException: () => (
      /* reexport */
      W
    ),
    MissingPDFException: () => (
      /* reexport */
      Et
    ),
    OPS: () => (
      /* reexport */
      N
    ),
    Outliner: () => (
      /* reexport */
      Sm
    ),
    PDFDataRangeTransport: () => (
      /* reexport */
      Qb
    ),
    PDFDateString: () => (
      /* reexport */
      Tb
    ),
    PDFWorker: () => (
      /* reexport */
      Ia
    ),
    PasswordResponses: () => (
      /* reexport */
      z
    ),
    PermissionFlag: () => (
      /* reexport */
      I
    ),
    PixelsPerInch: () => (
      /* reexport */
      Vi
    ),
    RenderingCancelledException: () => (
      /* reexport */
      sm
    ),
    TextLayer: () => (
      /* reexport */
      Ra
    ),
    UnexpectedResponseException: () => (
      /* reexport */
      Pt
    ),
    Util: () => (
      /* reexport */
      et
    ),
    VerbosityLevel: () => (
      /* reexport */
      H
    ),
    XfaLayer: () => (
      /* reexport */
      ty
    ),
    build: () => (
      /* reexport */
      Pw
    ),
    createValidAbsoluteUrl: () => (
      /* reexport */
      q
    ),
    fetchData: () => (
      /* reexport */
      Ru
    ),
    getDocument: () => (
      /* reexport */
      mw
    ),
    getFilenameFromUrl: () => (
      /* reexport */
      d0
    ),
    getPdfFilenameFromUrl: () => (
      /* reexport */
      u0
    ),
    getXfaPageViewport: () => (
      /* reexport */
      f0
    ),
    isDataScheme: () => (
      /* reexport */
      im
    ),
    isPdfFile: () => (
      /* reexport */
      nm
    ),
    noContextMenu: () => (
      /* reexport */
      Le
    ),
    normalizeUnicode: () => (
      /* reexport */
      Vt
    ),
    renderTextLayer: () => (
      /* reexport */
      ow
    ),
    setLayerDimensions: () => (
      /* reexport */
      jn
    ),
    shadow: () => (
      /* reexport */
      tt
    ),
    updateTextLayer: () => (
      /* reexport */
      lw
    ),
    version: () => (
      /* reexport */
      xw
    )
  }), Ct(4114), Ct(6573), Ct(8100), Ct(7936), Ct(7467), Ct(4732), Ct(9577), Ct(4603), Ct(7566), Ct(8721);
  const u = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser"), n = [1, 0, 0, 1, 0, 0], i = [1e-3, 0, 0, 1e-3, 0, 0], l = 1e7, d = 1.35, f = {
    ANY: 1,
    DISPLAY: 2,
    PRINT: 4,
    SAVE: 8,
    ANNOTATIONS_FORMS: 16,
    ANNOTATIONS_STORAGE: 32,
    ANNOTATIONS_DISABLE: 64,
    OPLIST: 256
  }, m = {
    DISABLE: 0,
    ENABLE: 1,
    ENABLE_FORMS: 2,
    ENABLE_STORAGE: 3
  }, y = "pdfjs_internal_editor_", w = {
    DISABLE: -1,
    NONE: 0,
    FREETEXT: 3,
    HIGHLIGHT: 9,
    STAMP: 13,
    INK: 15
  }, P = {
    RESIZE: 1,
    CREATE: 2,
    FREETEXT_SIZE: 11,
    FREETEXT_COLOR: 12,
    FREETEXT_OPACITY: 13,
    INK_COLOR: 21,
    INK_THICKNESS: 22,
    INK_OPACITY: 23,
    HIGHLIGHT_COLOR: 31,
    HIGHLIGHT_DEFAULT_COLOR: 32,
    HIGHLIGHT_THICKNESS: 33,
    HIGHLIGHT_FREE: 34,
    HIGHLIGHT_SHOW_ALL: 35
  }, I = {
    PRINT: 4,
    MODIFY_CONTENTS: 8,
    COPY: 16,
    MODIFY_ANNOTATIONS: 32,
    FILL_INTERACTIVE_FORMS: 256,
    COPY_FOR_ACCESSIBILITY: 512,
    ASSEMBLE: 1024,
    PRINT_HIGH_QUALITY: 2048
  }, L = {
    FILL: 0,
    STROKE: 1,
    FILL_STROKE: 2,
    INVISIBLE: 3,
    FILL_ADD_TO_PATH: 4,
    STROKE_ADD_TO_PATH: 5,
    FILL_STROKE_ADD_TO_PATH: 6,
    ADD_TO_PATH: 7,
    FILL_STROKE_MASK: 3,
    ADD_TO_PATH_FLAG: 4
  }, _ = {
    GRAYSCALE_1BPP: 1,
    RGB_24BPP: 2,
    RGBA_32BPP: 3
  }, D = {
    TEXT: 1,
    LINK: 2,
    FREETEXT: 3,
    LINE: 4,
    SQUARE: 5,
    CIRCLE: 6,
    POLYGON: 7,
    POLYLINE: 8,
    HIGHLIGHT: 9,
    UNDERLINE: 10,
    SQUIGGLY: 11,
    STRIKEOUT: 12,
    STAMP: 13,
    CARET: 14,
    INK: 15,
    POPUP: 16,
    FILEATTACHMENT: 17,
    SOUND: 18,
    MOVIE: 19,
    WIDGET: 20,
    SCREEN: 21,
    PRINTERMARK: 22,
    TRAPNET: 23,
    WATERMARK: 24,
    THREED: 25,
    REDACT: 26
  }, k = {
    SOLID: 1,
    DASHED: 2,
    BEVELED: 3,
    INSET: 4,
    UNDERLINE: 5
  }, H = {
    ERRORS: 0,
    WARNINGS: 1,
    INFOS: 5
  }, X = {
    NONE: 0,
    BINARY: 1
  }, N = {
    dependency: 1,
    setLineWidth: 2,
    setLineCap: 3,
    setLineJoin: 4,
    setMiterLimit: 5,
    setDash: 6,
    setRenderingIntent: 7,
    setFlatness: 8,
    setGState: 9,
    save: 10,
    restore: 11,
    transform: 12,
    moveTo: 13,
    lineTo: 14,
    curveTo: 15,
    curveTo2: 16,
    curveTo3: 17,
    closePath: 18,
    rectangle: 19,
    stroke: 20,
    closeStroke: 21,
    fill: 22,
    eoFill: 23,
    fillStroke: 24,
    eoFillStroke: 25,
    closeFillStroke: 26,
    closeEOFillStroke: 27,
    endPath: 28,
    clip: 29,
    eoClip: 30,
    beginText: 31,
    endText: 32,
    setCharSpacing: 33,
    setWordSpacing: 34,
    setHScale: 35,
    setLeading: 36,
    setFont: 37,
    setTextRenderingMode: 38,
    setTextRise: 39,
    moveText: 40,
    setLeadingMoveText: 41,
    setTextMatrix: 42,
    nextLine: 43,
    showText: 44,
    showSpacedText: 45,
    nextLineShowText: 46,
    nextLineSetSpacingShowText: 47,
    setCharWidth: 48,
    setCharWidthAndBounds: 49,
    setStrokeColorSpace: 50,
    setFillColorSpace: 51,
    setStrokeColor: 52,
    setStrokeColorN: 53,
    setFillColor: 54,
    setFillColorN: 55,
    setStrokeGray: 56,
    setFillGray: 57,
    setStrokeRGBColor: 58,
    setFillRGBColor: 59,
    setStrokeCMYKColor: 60,
    setFillCMYKColor: 61,
    shadingFill: 62,
    beginInlineImage: 63,
    beginImageData: 64,
    endInlineImage: 65,
    paintXObject: 66,
    markPoint: 67,
    markPointProps: 68,
    beginMarkedContent: 69,
    beginMarkedContentProps: 70,
    endMarkedContent: 71,
    beginCompat: 72,
    endCompat: 73,
    paintFormXObjectBegin: 74,
    paintFormXObjectEnd: 75,
    beginGroup: 76,
    endGroup: 77,
    beginAnnotation: 80,
    endAnnotation: 81,
    paintImageMaskXObject: 83,
    paintImageMaskXObjectGroup: 84,
    paintImageXObject: 85,
    paintInlineImageXObject: 86,
    paintInlineImageXObjectGroup: 87,
    paintImageXObjectRepeat: 88,
    paintImageMaskXObjectRepeat: 89,
    paintSolidColorImageMask: 90,
    constructPath: 91
  }, z = {
    NEED_PASSWORD: 1,
    INCORRECT_PASSWORD: 2
  };
  let V = H.WARNINGS;
  function Z(A) {
    Number.isInteger(A) && (V = A);
  }
  function K() {
    return V;
  }
  function $(A) {
    V >= H.INFOS && console.log(`Info: ${A}`);
  }
  function j(A) {
    V >= H.WARNINGS && console.log(`Warning: ${A}`);
  }
  function Q(A) {
    throw new Error(A);
  }
  function B(A, t) {
    A || Q(t);
  }
  function G(A) {
    switch (A == null ? void 0 : A.protocol) {
      case "http:":
      case "https:":
      case "ftp:":
      case "mailto:":
      case "tel:":
        return !0;
      default:
        return !1;
    }
  }
  function q(A, t = null, e = null) {
    if (!A)
      return null;
    try {
      if (e && typeof A == "string") {
        if (e.addDefaultProtocol && A.startsWith("www.")) {
          const a = A.match(/\./g);
          (a == null ? void 0 : a.length) >= 2 && (A = `http://${A}`);
        }
        if (e.tryConvertEncoding)
          try {
            A = Mt(A);
          } catch {
          }
      }
      const s = t ? new URL(A, t) : new URL(A);
      if (G(s))
        return s;
    } catch {
    }
    return null;
  }
  function tt(A, t, e, s = !1) {
    return Object.defineProperty(A, t, {
      value: e,
      enumerable: !s,
      configurable: !0,
      writable: !1
    }), e;
  }
  const lt = function() {
    function t(e, s) {
      this.constructor === t && Q("Cannot initialize BaseException."), this.message = e, this.name = s;
    }
    return t.prototype = new Error(), t.constructor = t, t;
  }();
  class vt extends lt {
    constructor(t, e) {
      super(t, "PasswordException"), this.code = e;
    }
  }
  class dt extends lt {
    constructor(t, e) {
      super(t, "UnknownErrorException"), this.details = e;
    }
  }
  class W extends lt {
    constructor(t) {
      super(t, "InvalidPDFException");
    }
  }
  class Et extends lt {
    constructor(t) {
      super(t, "MissingPDFException");
    }
  }
  class Pt extends lt {
    constructor(t, e) {
      super(t, "UnexpectedResponseException"), this.status = e;
    }
  }
  class Ht extends lt {
    constructor(t) {
      super(t, "FormatError");
    }
  }
  class Ft extends lt {
    constructor(t) {
      super(t, "AbortException");
    }
  }
  function We(A) {
    (typeof A != "object" || (A == null ? void 0 : A.length) === void 0) && Q("Invalid argument for bytesToString");
    const t = A.length, e = 8192;
    if (t < e)
      return String.fromCharCode.apply(null, A);
    const s = [];
    for (let a = 0; a < t; a += e) {
      const o = Math.min(a + e, t), h = A.subarray(a, o);
      s.push(String.fromCharCode.apply(null, h));
    }
    return s.join("");
  }
  function be(A) {
    typeof A != "string" && Q("Invalid argument for stringToBytes");
    const t = A.length, e = new Uint8Array(t);
    for (let s = 0; s < t; ++s)
      e[s] = A.charCodeAt(s) & 255;
    return e;
  }
  function Gs(A) {
    return String.fromCharCode(A >> 24 & 255, A >> 16 & 255, A >> 8 & 255, A & 255);
  }
  function Bn(A) {
    const t = /* @__PURE__ */ Object.create(null);
    for (const [e, s] of A)
      t[e] = s;
    return t;
  }
  function Ta() {
    const A = new Uint8Array(4);
    return A[0] = 1, new Uint32Array(A.buffer, 0, 1)[0] === 1;
  }
  function ht() {
    try {
      return new Function(""), !0;
    } catch {
      return !1;
    }
  }
  class nt {
    static get isLittleEndian() {
      return tt(this, "isLittleEndian", Ta());
    }
    static get isEvalSupported() {
      return tt(this, "isEvalSupported", ht());
    }
    static get isOffscreenCanvasSupported() {
      return tt(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
    }
    static get platform() {
      return typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.platform) == "string" ? tt(this, "platform", {
        isMac: navigator.platform.includes("Mac")
      }) : tt(this, "platform", {
        isMac: !1
      });
    }
    static get isCSSRoundSupported() {
      var t, e;
      return tt(this, "isCSSRoundSupported", (e = (t = globalThis.CSS) == null ? void 0 : t.supports) == null ? void 0 : e.call(t, "width: round(1.5px, 1px)"));
    }
  }
  const at = Array.from(Array(256).keys(), (A) => A.toString(16).padStart(2, "0"));
  class et {
    static makeHexColor(t, e, s) {
      return `#${at[t]}${at[e]}${at[s]}`;
    }
    static scaleMinMax(t, e) {
      let s;
      t[0] ? (t[0] < 0 && (s = e[0], e[0] = e[2], e[2] = s), e[0] *= t[0], e[2] *= t[0], t[3] < 0 && (s = e[1], e[1] = e[3], e[3] = s), e[1] *= t[3], e[3] *= t[3]) : (s = e[0], e[0] = e[1], e[1] = s, s = e[2], e[2] = e[3], e[3] = s, t[1] < 0 && (s = e[1], e[1] = e[3], e[3] = s), e[1] *= t[1], e[3] *= t[1], t[2] < 0 && (s = e[0], e[0] = e[2], e[2] = s), e[0] *= t[2], e[2] *= t[2]), e[0] += t[4], e[1] += t[5], e[2] += t[4], e[3] += t[5];
    }
    static transform(t, e) {
      return [t[0] * e[0] + t[2] * e[1], t[1] * e[0] + t[3] * e[1], t[0] * e[2] + t[2] * e[3], t[1] * e[2] + t[3] * e[3], t[0] * e[4] + t[2] * e[5] + t[4], t[1] * e[4] + t[3] * e[5] + t[5]];
    }
    static applyTransform(t, e) {
      const s = t[0] * e[0] + t[1] * e[2] + e[4], a = t[0] * e[1] + t[1] * e[3] + e[5];
      return [s, a];
    }
    static applyInverseTransform(t, e) {
      const s = e[0] * e[3] - e[1] * e[2], a = (t[0] * e[3] - t[1] * e[2] + e[2] * e[5] - e[4] * e[3]) / s, o = (-t[0] * e[1] + t[1] * e[0] + e[4] * e[1] - e[5] * e[0]) / s;
      return [a, o];
    }
    static getAxialAlignedBoundingBox(t, e) {
      const s = this.applyTransform(t, e), a = this.applyTransform(t.slice(2, 4), e), o = this.applyTransform([t[0], t[3]], e), h = this.applyTransform([t[2], t[1]], e);
      return [Math.min(s[0], a[0], o[0], h[0]), Math.min(s[1], a[1], o[1], h[1]), Math.max(s[0], a[0], o[0], h[0]), Math.max(s[1], a[1], o[1], h[1])];
    }
    static inverseTransform(t) {
      const e = t[0] * t[3] - t[1] * t[2];
      return [t[3] / e, -t[1] / e, -t[2] / e, t[0] / e, (t[2] * t[5] - t[4] * t[3]) / e, (t[4] * t[1] - t[5] * t[0]) / e];
    }
    static singularValueDecompose2dScale(t) {
      const e = [t[0], t[2], t[1], t[3]], s = t[0] * e[0] + t[1] * e[2], a = t[0] * e[1] + t[1] * e[3], o = t[2] * e[0] + t[3] * e[2], h = t[2] * e[1] + t[3] * e[3], c = (s + h) / 2, p = Math.sqrt((s + h) ** 2 - 4 * (s * h - o * a)) / 2, g = c + p || 1, b = c - p || 1;
      return [Math.sqrt(g), Math.sqrt(b)];
    }
    static normalizeRect(t) {
      const e = t.slice(0);
      return t[0] > t[2] && (e[0] = t[2], e[2] = t[0]), t[1] > t[3] && (e[1] = t[3], e[3] = t[1]), e;
    }
    static intersect(t, e) {
      const s = Math.max(Math.min(t[0], t[2]), Math.min(e[0], e[2])), a = Math.min(Math.max(t[0], t[2]), Math.max(e[0], e[2]));
      if (s > a)
        return null;
      const o = Math.max(Math.min(t[1], t[3]), Math.min(e[1], e[3])), h = Math.min(Math.max(t[1], t[3]), Math.max(e[1], e[3]));
      return o > h ? null : [s, o, a, h];
    }
    static bezierBoundingBox(t, e, s, a, o, h, c, p, g) {
      return g ? (g[0] = Math.min(g[0], t, c), g[1] = Math.min(g[1], e, p), g[2] = Math.max(g[2], t, c), g[3] = Math.max(g[3], e, p)) : g = [Math.min(t, c), Math.min(e, p), Math.max(t, c), Math.max(e, p)], E(this, Bl, zm).call(this, t, s, o, c, e, a, h, p, 3 * (-t + 3 * (s - o) + c), 6 * (t - 2 * s + o), 3 * (s - t), g), E(this, Bl, zm).call(this, t, s, o, c, e, a, h, p, 3 * (-e + 3 * (a - h) + p), 6 * (e - 2 * a + h), 3 * (a - e), g), g;
    }
  }
  La = new WeakSet(), Lp = function(t, e, s, a, o, h, c, p, g, b) {
    if (g <= 0 || g >= 1)
      return;
    const S = 1 - g, T = g * g, C = T * g, R = S * (S * (S * t + 3 * g * e) + 3 * T * s) + C * a, M = S * (S * (S * o + 3 * g * h) + 3 * T * c) + C * p;
    b[0] = Math.min(b[0], R), b[1] = Math.min(b[1], M), b[2] = Math.max(b[2], R), b[3] = Math.max(b[3], M);
  }, Bl = new WeakSet(), zm = function(t, e, s, a, o, h, c, p, g, b, S, T) {
    if (Math.abs(g) < 1e-12) {
      Math.abs(b) >= 1e-12 && E(this, La, Lp).call(this, t, e, s, a, o, h, c, p, -S / b, T);
      return;
    }
    const C = b ** 2 - 4 * S * g;
    if (C < 0)
      return;
    const R = Math.sqrt(C), M = 2 * g;
    E(this, La, Lp).call(this, t, e, s, a, o, h, c, p, (-b + R) / M, T), E(this, La, Lp).call(this, t, e, s, a, o, h, c, p, (-b - R) / M, T);
  }, v(et, La), v(et, Bl);
  function Mt(A) {
    return decodeURIComponent(escape(A));
  }
  let ct = null, Bt = null;
  function Vt(A) {
    return ct || (ct = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, Bt = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), A.replaceAll(ct, (t, e, s) => e ? e.normalize("NFKC") : Bt.get(s));
  }
  function Ge() {
    if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.randomUUID) == "function")
      return crypto.randomUUID();
    const A = new Uint8Array(32);
    if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.getRandomValues) == "function")
      crypto.getRandomValues(A);
    else
      for (let t = 0; t < 32; t++)
        A[t] = Math.floor(Math.random() * 255);
    return We(A);
  }
  const ne = "pdfjs_internal_id_", Lt = {
    BEZIER_CURVE_TO: 0,
    MOVE_TO: 1,
    LINE_TO: 2,
    QUADRATIC_CURVE_TO: 3,
    RESTORE: 4,
    SAVE: 5,
    SCALE: 6,
    TRANSFORM: 7,
    TRANSLATE: 8
  };
  Ct(4628), Ct(1454), Ct(3375), Ct(9225), Ct(3972), Ct(9209), Ct(5714), Ct(7561), Ct(6197), Ct(4979), Ct(8992), Ct(3215), Ct(7550), Ct(8335), Ct(4520);
  class is {
    constructor() {
      this.constructor === is && Q("Cannot initialize BaseFilterFactory.");
    }
    addFilter(t) {
      return "none";
    }
    addHCMFilter(t, e) {
      return "none";
    }
    addAlphaFilter(t) {
      return "none";
    }
    addLuminosityFilter(t) {
      return "none";
    }
    addHighlightHCMFilter(t, e, s, a, o) {
      return "none";
    }
    destroy(t = !1) {
    }
  }
  class Hi {
    constructor() {
      this.constructor === Hi && Q("Cannot initialize BaseCanvasFactory.");
    }
    create(t, e) {
      if (t <= 0 || e <= 0)
        throw new Error("Invalid canvas size");
      const s = this._createCanvas(t, e);
      return {
        canvas: s,
        context: s.getContext("2d")
      };
    }
    reset(t, e, s) {
      if (!t.canvas)
        throw new Error("Canvas is not specified");
      if (e <= 0 || s <= 0)
        throw new Error("Invalid canvas size");
      t.canvas.width = e, t.canvas.height = s;
    }
    destroy(t) {
      if (!t.canvas)
        throw new Error("Canvas is not specified");
      t.canvas.width = 0, t.canvas.height = 0, t.canvas = null, t.context = null;
    }
    _createCanvas(t, e) {
      Q("Abstract method `_createCanvas` called.");
    }
  }
  class Xs {
    constructor({
      baseUrl: t = null,
      isCompressed: e = !0
    }) {
      this.constructor === Xs && Q("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = t, this.isCompressed = e;
    }
    async fetch({
      name: t
    }) {
      if (!this.baseUrl)
        throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
      if (!t)
        throw new Error("CMap name must be specified.");
      const e = this.baseUrl + t + (this.isCompressed ? ".bcmap" : ""), s = this.isCompressed ? X.BINARY : X.NONE;
      return this._fetchData(e, s).catch((a) => {
        throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${e}`);
      });
    }
    _fetchData(t, e) {
      Q("Abstract method `_fetchData` called.");
    }
  }
  class Cu {
    constructor({
      baseUrl: t = null
    }) {
      this.constructor === Cu && Q("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = t;
    }
    async fetch({
      filename: t
    }) {
      if (!this.baseUrl)
        throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
      if (!t)
        throw new Error("Font filename must be specified.");
      const e = `${this.baseUrl}${t}`;
      return this._fetchData(e).catch((s) => {
        throw new Error(`Unable to load font data at: ${e}`);
      });
    }
    _fetchData(t) {
      Q("Abstract method `_fetchData` called.");
    }
  }
  class tm {
    constructor() {
      this.constructor === tm && Q("Cannot initialize BaseSVGFactory.");
    }
    create(t, e, s = !1) {
      if (t <= 0 || e <= 0)
        throw new Error("Invalid SVG dimensions");
      const a = this._createSVG("svg:svg");
      return a.setAttribute("version", "1.1"), s || (a.setAttribute("width", `${t}px`), a.setAttribute("height", `${e}px`)), a.setAttribute("preserveAspectRatio", "none"), a.setAttribute("viewBox", `0 0 ${t} ${e}`), a;
    }
    createElement(t) {
      if (typeof t != "string")
        throw new Error("Invalid SVG element type");
      return this._createSVG(t);
    }
    _createSVG(t) {
      Q("Abstract method `_createSVG` called.");
    }
  }
  const Ks = "http://www.w3.org/2000/svg", Un = class Un {
  };
  bt(Un, "CSS", 96), bt(Un, "PDF", 72), bt(Un, "PDF_TO_CSS_UNITS", Un.CSS / Un.PDF);
  let Vi = Un;
  class h0 extends is {
    constructor({
      docId: e,
      ownerDocument: s = globalThis.document
    } = {}) {
      super();
      v(this, re);
      v(this, Ui);
      v(this, zi);
      v(this, _a);
      v(this, $u);
      v(this, jl);
      v(this, Wi);
      v(this, Gn);
      v(this, Xn);
      v(this, Hl);
      v(this, Kn);
      v(this, zn, void 0);
      v(this, ws, void 0);
      v(this, qs, void 0);
      v(this, Oe, void 0);
      v(this, Vu, void 0);
      v(this, Wn, 0);
      x(this, qs, e), x(this, Oe, s);
    }
    addFilter(e) {
      if (!e)
        return "none";
      let s = r(this, re, Ae).get(e);
      if (s)
        return s;
      const [a, o, h] = E(this, _a, _p).call(this, e), c = e.length === 1 ? a : `${a}${o}${h}`;
      if (s = r(this, re, Ae).get(c), s)
        return r(this, re, Ae).set(e, s), s;
      const p = `g_${r(this, qs)}_transfer_map_${De(this, Wn)._++}`, g = `url(#${p})`;
      r(this, re, Ae).set(e, g), r(this, re, Ae).set(c, g);
      const b = E(this, Wi, Zo).call(this, p);
      return E(this, Xn, fd).call(this, a, o, h, b), g;
    }
    addHCMFilter(e, s) {
      var R;
      const a = `${e}-${s}`, o = "base";
      let h = r(this, Ui, Yo).get(o);
      if ((h == null ? void 0 : h.key) === a || (h ? ((R = h.filter) == null || R.remove(), h.key = a, h.url = "none", h.filter = null) : (h = {
        key: a,
        url: "none",
        filter: null
      }, r(this, Ui, Yo).set(o, h)), !e || !s))
        return h.url;
      const c = E(this, Kn, pd).call(this, e);
      e = et.makeHexColor(...c);
      const p = E(this, Kn, pd).call(this, s);
      if (s = et.makeHexColor(...p), r(this, zi, Qo).style.color = "", e === "#000000" && s === "#ffffff" || e === s)
        return h.url;
      const g = new Array(256);
      for (let M = 0; M <= 255; M++) {
        const F = M / 255;
        g[M] = F <= 0.03928 ? F / 12.92 : ((F + 0.055) / 1.055) ** 2.4;
      }
      const b = g.join(","), S = `g_${r(this, qs)}_hcm_filter`, T = h.filter = E(this, Wi, Zo).call(this, S);
      E(this, Xn, fd).call(this, b, b, b, T), E(this, jl, Wm).call(this, T);
      const C = (M, F) => {
        const O = c[M] / 255, U = p[M] / 255, Y = new Array(F + 1);
        for (let J = 0; J <= F; J++)
          Y[J] = O + J / F * (U - O);
        return Y.join(",");
      };
      return E(this, Xn, fd).call(this, C(0, 5), C(1, 5), C(2, 5), T), h.url = `url(#${S})`, h.url;
    }
    addAlphaFilter(e) {
      let s = r(this, re, Ae).get(e);
      if (s)
        return s;
      const [a] = E(this, _a, _p).call(this, [e]), o = `alpha_${a}`;
      if (s = r(this, re, Ae).get(o), s)
        return r(this, re, Ae).set(e, s), s;
      const h = `g_${r(this, qs)}_alpha_map_${De(this, Wn)._++}`, c = `url(#${h})`;
      r(this, re, Ae).set(e, c), r(this, re, Ae).set(o, c);
      const p = E(this, Wi, Zo).call(this, h);
      return E(this, Hl, Gm).call(this, a, p), c;
    }
    addLuminosityFilter(e) {
      let s = r(this, re, Ae).get(e || "luminosity");
      if (s)
        return s;
      let a, o;
      if (e ? ([a] = E(this, _a, _p).call(this, [e]), o = `luminosity_${a}`) : o = "luminosity", s = r(this, re, Ae).get(o), s)
        return r(this, re, Ae).set(e, s), s;
      const h = `g_${r(this, qs)}_luminosity_map_${De(this, Wn)._++}`, c = `url(#${h})`;
      r(this, re, Ae).set(e, c), r(this, re, Ae).set(o, c);
      const p = E(this, Wi, Zo).call(this, h);
      return E(this, $u, Qy).call(this, p), e && E(this, Hl, Gm).call(this, a, p), c;
    }
    addHighlightHCMFilter(e, s, a, o, h) {
      var U;
      const c = `${s}-${a}-${o}-${h}`;
      let p = r(this, Ui, Yo).get(e);
      if ((p == null ? void 0 : p.key) === c || (p ? ((U = p.filter) == null || U.remove(), p.key = c, p.url = "none", p.filter = null) : (p = {
        key: c,
        url: "none",
        filter: null
      }, r(this, Ui, Yo).set(e, p)), !s || !a))
        return p.url;
      const [g, b] = [s, a].map(E(this, Kn, pd).bind(this));
      let S = Math.round(0.2126 * g[0] + 0.7152 * g[1] + 0.0722 * g[2]), T = Math.round(0.2126 * b[0] + 0.7152 * b[1] + 0.0722 * b[2]), [C, R] = [o, h].map(E(this, Kn, pd).bind(this));
      T < S && ([S, T, C, R] = [T, S, R, C]), r(this, zi, Qo).style.color = "";
      const M = (Y, J, rt) => {
        const st = new Array(256), ot = (T - S) / rt, ft = Y / 255, yt = (J - Y) / (255 * rt);
        let St = 0;
        for (let gt = 0; gt <= rt; gt++) {
          const Wt = Math.round(S + gt * ot), Dt = ft + gt * yt;
          for (let $t = St; $t <= Wt; $t++)
            st[$t] = Dt;
          St = Wt + 1;
        }
        for (let gt = St; gt < 256; gt++)
          st[gt] = st[St - 1];
        return st.join(",");
      }, F = `g_${r(this, qs)}_hcm_${e}_filter`, O = p.filter = E(this, Wi, Zo).call(this, F);
      return E(this, jl, Wm).call(this, O), E(this, Xn, fd).call(this, M(C[0], R[0], 5), M(C[1], R[1], 5), M(C[2], R[2], 5), O), p.url = `url(#${F})`, p.url;
    }
    destroy(e = !1) {
      e && r(this, Ui, Yo).size !== 0 || (r(this, ws) && (r(this, ws).parentNode.parentNode.remove(), x(this, ws, null)), r(this, zn) && (r(this, zn).clear(), x(this, zn, null)), x(this, Wn, 0));
    }
  }
  zn = new WeakMap(), ws = new WeakMap(), qs = new WeakMap(), Oe = new WeakMap(), Vu = new WeakMap(), Wn = new WeakMap(), re = new WeakSet(), Ae = function() {
    return r(this, zn) || x(this, zn, /* @__PURE__ */ new Map());
  }, Ui = new WeakSet(), Yo = function() {
    return r(this, Vu) || x(this, Vu, /* @__PURE__ */ new Map());
  }, zi = new WeakSet(), Qo = function() {
    if (!r(this, ws)) {
      const e = r(this, Oe).createElement("div"), {
        style: s
      } = e;
      s.visibility = "hidden", s.contain = "strict", s.width = s.height = 0, s.position = "absolute", s.top = s.left = 0, s.zIndex = -1;
      const a = r(this, Oe).createElementNS(Ks, "svg");
      a.setAttribute("width", 0), a.setAttribute("height", 0), x(this, ws, r(this, Oe).createElementNS(Ks, "defs")), e.append(a), a.append(r(this, ws)), r(this, Oe).body.append(e);
    }
    return r(this, ws);
  }, _a = new WeakSet(), _p = function(e) {
    if (e.length === 1) {
      const g = e[0], b = new Array(256);
      for (let T = 0; T < 256; T++)
        b[T] = g[T] / 255;
      const S = b.join(",");
      return [S, S, S];
    }
    const [s, a, o] = e, h = new Array(256), c = new Array(256), p = new Array(256);
    for (let g = 0; g < 256; g++)
      h[g] = s[g] / 255, c[g] = a[g] / 255, p[g] = o[g] / 255;
    return [h.join(","), c.join(","), p.join(",")];
  }, $u = new WeakSet(), Qy = function(e) {
    const s = r(this, Oe).createElementNS(Ks, "feColorMatrix");
    s.setAttribute("type", "matrix"), s.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0"), e.append(s);
  }, jl = new WeakSet(), Wm = function(e) {
    const s = r(this, Oe).createElementNS(Ks, "feColorMatrix");
    s.setAttribute("type", "matrix"), s.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), e.append(s);
  }, Wi = new WeakSet(), Zo = function(e) {
    const s = r(this, Oe).createElementNS(Ks, "filter");
    return s.setAttribute("color-interpolation-filters", "sRGB"), s.setAttribute("id", e), r(this, zi, Qo).append(s), s;
  }, Gn = new WeakSet(), ud = function(e, s, a) {
    const o = r(this, Oe).createElementNS(Ks, s);
    o.setAttribute("type", "discrete"), o.setAttribute("tableValues", a), e.append(o);
  }, Xn = new WeakSet(), fd = function(e, s, a, o) {
    const h = r(this, Oe).createElementNS(Ks, "feComponentTransfer");
    o.append(h), E(this, Gn, ud).call(this, h, "feFuncR", e), E(this, Gn, ud).call(this, h, "feFuncG", s), E(this, Gn, ud).call(this, h, "feFuncB", a);
  }, Hl = new WeakSet(), Gm = function(e, s) {
    const a = r(this, Oe).createElementNS(Ks, "feComponentTransfer");
    s.append(a), E(this, Gn, ud).call(this, a, "feFuncA", e);
  }, Kn = new WeakSet(), pd = function(e) {
    return r(this, zi, Qo).style.color = e, rm(getComputedStyle(r(this, zi, Qo)).getPropertyValue("color"));
  };
  class c0 extends Hi {
    constructor({
      ownerDocument: t = globalThis.document
    } = {}) {
      super(), this._document = t;
    }
    _createCanvas(t, e) {
      const s = this._document.createElement("canvas");
      return s.width = t, s.height = e, s;
    }
  }
  async function Ru(A, t = "text") {
    if (Il(A, document.baseURI)) {
      const e = await fetch(A);
      if (!e.ok)
        throw new Error(e.statusText);
      switch (t) {
        case "arraybuffer":
          return e.arrayBuffer();
        case "blob":
          return e.blob();
        case "json":
          return e.json();
      }
      return e.text();
    }
    return new Promise((e, s) => {
      const a = new XMLHttpRequest();
      a.open("GET", A, !0), a.responseType = t, a.onreadystatechange = () => {
        if (a.readyState === XMLHttpRequest.DONE) {
          if (a.status === 200 || a.status === 0) {
            switch (t) {
              case "arraybuffer":
              case "blob":
              case "json":
                e(a.response);
                return;
            }
            e(a.responseText);
            return;
          }
          s(new Error(a.statusText));
        }
      }, a.send(null);
    });
  }
  class Eb extends Xs {
    _fetchData(t, e) {
      return Ru(t, this.isCompressed ? "arraybuffer" : "text").then((s) => ({
        cMapData: s instanceof ArrayBuffer ? new Uint8Array(s) : be(s),
        compressionType: e
      }));
    }
  }
  class wb extends Cu {
    _fetchData(t) {
      return Ru(t, "arraybuffer").then((e) => new Uint8Array(e));
    }
  }
  class em extends tm {
    _createSVG(t) {
      return document.createElementNS(Ks, t);
    }
  }
  class Rl {
    constructor({
      viewBox: t,
      scale: e,
      rotation: s,
      offsetX: a = 0,
      offsetY: o = 0,
      dontFlip: h = !1
    }) {
      this.viewBox = t, this.scale = e, this.rotation = s, this.offsetX = a, this.offsetY = o;
      const c = (t[2] + t[0]) / 2, p = (t[3] + t[1]) / 2;
      let g, b, S, T;
      switch (s %= 360, s < 0 && (s += 360), s) {
        case 180:
          g = -1, b = 0, S = 0, T = 1;
          break;
        case 90:
          g = 0, b = 1, S = 1, T = 0;
          break;
        case 270:
          g = 0, b = -1, S = -1, T = 0;
          break;
        case 0:
          g = 1, b = 0, S = 0, T = -1;
          break;
        default:
          throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
      }
      h && (S = -S, T = -T);
      let C, R, M, F;
      g === 0 ? (C = Math.abs(p - t[1]) * e + a, R = Math.abs(c - t[0]) * e + o, M = (t[3] - t[1]) * e, F = (t[2] - t[0]) * e) : (C = Math.abs(c - t[0]) * e + a, R = Math.abs(p - t[1]) * e + o, M = (t[2] - t[0]) * e, F = (t[3] - t[1]) * e), this.transform = [g * e, b * e, S * e, T * e, C - g * e * c - S * e * p, R - b * e * c - T * e * p], this.width = M, this.height = F;
    }
    get rawDims() {
      const {
        viewBox: t
      } = this;
      return tt(this, "rawDims", {
        pageWidth: t[2] - t[0],
        pageHeight: t[3] - t[1],
        pageX: t[0],
        pageY: t[1]
      });
    }
    clone({
      scale: t = this.scale,
      rotation: e = this.rotation,
      offsetX: s = this.offsetX,
      offsetY: a = this.offsetY,
      dontFlip: o = !1
    } = {}) {
      return new Rl({
        viewBox: this.viewBox.slice(),
        scale: t,
        rotation: e,
        offsetX: s,
        offsetY: a,
        dontFlip: o
      });
    }
    convertToViewportPoint(t, e) {
      return et.applyTransform([t, e], this.transform);
    }
    convertToViewportRectangle(t) {
      const e = et.applyTransform([t[0], t[1]], this.transform), s = et.applyTransform([t[2], t[3]], this.transform);
      return [e[0], e[1], s[0], s[1]];
    }
    convertToPdfPoint(t, e) {
      return et.applyInverseTransform([t, e], this.transform);
    }
  }
  class sm extends lt {
    constructor(t, e = 0) {
      super(t, "RenderingCancelledException"), this.extraDelay = e;
    }
  }
  function im(A) {
    const t = A.length;
    let e = 0;
    for (; e < t && A[e].trim() === ""; )
      e++;
    return A.substring(e, e + 5).toLowerCase() === "data:";
  }
  function nm(A) {
    return typeof A == "string" && /\.pdf$/i.test(A);
  }
  function d0(A) {
    return [A] = A.split(/[#?]/, 1), A.substring(A.lastIndexOf("/") + 1);
  }
  function u0(A, t = "document.pdf") {
    if (typeof A != "string")
      return t;
    if (im(A))
      return j('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), t;
    const e = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, s = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, a = e.exec(A);
    let o = s.exec(a[1]) || s.exec(a[2]) || s.exec(a[3]);
    if (o && (o = o[0], o.includes("%")))
      try {
        o = s.exec(decodeURIComponent(o))[0];
      } catch {
      }
    return o || t;
  }
  class Sb {
    constructor() {
      bt(this, "started", /* @__PURE__ */ Object.create(null));
      bt(this, "times", []);
    }
    time(t) {
      t in this.started && j(`Timer is already running for ${t}`), this.started[t] = Date.now();
    }
    timeEnd(t) {
      t in this.started || j(`Timer has not been started for ${t}`), this.times.push({
        name: t,
        start: this.started[t],
        end: Date.now()
      }), delete this.started[t];
    }
    toString() {
      const t = [];
      let e = 0;
      for (const {
        name: s
      } of this.times)
        e = Math.max(s.length, e);
      for (const {
        name: s,
        start: a,
        end: o
      } of this.times)
        t.push(`${s.padEnd(e)} ${o - a}ms
`);
      return t.join("");
    }
  }
  function Il(A, t) {
    try {
      const {
        protocol: e
      } = t ? new URL(A, t) : new URL(A);
      return e === "http:" || e === "https:";
    } catch {
      return !1;
    }
  }
  function Le(A) {
    A.preventDefault();
  }
  function xb(A) {
    console.log("Deprecated API usage: " + A);
  }
  let Pb;
  class Tb {
    static toDateObject(t) {
      if (!t || typeof t != "string")
        return null;
      Pb || (Pb = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
      const e = Pb.exec(t);
      if (!e)
        return null;
      const s = parseInt(e[1], 10);
      let a = parseInt(e[2], 10);
      a = a >= 1 && a <= 12 ? a - 1 : 0;
      let o = parseInt(e[3], 10);
      o = o >= 1 && o <= 31 ? o : 1;
      let h = parseInt(e[4], 10);
      h = h >= 0 && h <= 23 ? h : 0;
      let c = parseInt(e[5], 10);
      c = c >= 0 && c <= 59 ? c : 0;
      let p = parseInt(e[6], 10);
      p = p >= 0 && p <= 59 ? p : 0;
      const g = e[7] || "Z";
      let b = parseInt(e[8], 10);
      b = b >= 0 && b <= 23 ? b : 0;
      let S = parseInt(e[9], 10) || 0;
      return S = S >= 0 && S <= 59 ? S : 0, g === "-" ? (h += b, c += S) : g === "+" && (h -= b, c -= S), new Date(Date.UTC(s, a, o, h, c, p));
    }
  }
  function f0(A, {
    scale: t = 1,
    rotation: e = 0
  }) {
    const {
      width: s,
      height: a
    } = A.attributes.style, o = [0, 0, parseInt(s), parseInt(a)];
    return new Rl({
      viewBox: o,
      scale: t,
      rotation: e
    });
  }
  function rm(A) {
    if (A.startsWith("#")) {
      const t = parseInt(A.slice(1), 16);
      return [(t & 16711680) >> 16, (t & 65280) >> 8, t & 255];
    }
    return A.startsWith("rgb(") ? A.slice(4, -1).split(",").map((t) => parseInt(t)) : A.startsWith("rgba(") ? A.slice(5, -1).split(",").map((t) => parseInt(t)).slice(0, 3) : (j(`Not a valid color format: "${A}"`), [0, 0, 0]);
  }
  function p0(A) {
    const t = document.createElement("span");
    t.style.visibility = "hidden", document.body.append(t);
    for (const e of A.keys()) {
      t.style.color = e;
      const s = window.getComputedStyle(t).color;
      A.set(e, rm(s));
    }
    t.remove();
  }
  function zt(A) {
    const {
      a: t,
      b: e,
      c: s,
      d: a,
      e: o,
      f: h
    } = A.getTransform();
    return [t, e, s, a, o, h];
  }
  function Ys(A) {
    const {
      a: t,
      b: e,
      c: s,
      d: a,
      e: o,
      f: h
    } = A.getTransform().invertSelf();
    return [t, e, s, a, o, h];
  }
  function jn(A, t, e = !1, s = !0) {
    if (t instanceof Rl) {
      const {
        pageWidth: a,
        pageHeight: o
      } = t.rawDims, {
        style: h
      } = A, c = nt.isCSSRoundSupported, p = `var(--scale-factor) * ${a}px`, g = `var(--scale-factor) * ${o}px`, b = c ? `round(${p}, 1px)` : `calc(${p})`, S = c ? `round(${g}, 1px)` : `calc(${g})`;
      !e || t.rotation % 180 === 0 ? (h.width = b, h.height = S) : (h.width = S, h.height = b);
    }
    s && A.setAttribute("data-main-rotation", t.rotation);
  }
  const Xu = class Xu {
    constructor(t) {
      v(this, zu);
      v(this, Wu);
      v(this, Ma);
      v(this, Gu);
      v(this, Vl);
      v(this, Yn, null);
      v(this, Qn, null);
      v(this, Ss, void 0);
      v(this, Zn, null);
      x(this, Ss, t);
    }
    render() {
      const t = x(this, Yn, document.createElement("div"));
      t.className = "editToolbar", t.setAttribute("role", "toolbar"), t.addEventListener("contextmenu", Le), t.addEventListener("pointerdown", E(Xu, Uu, Zy));
      const e = x(this, Zn, document.createElement("div"));
      e.className = "buttons", t.append(e);
      const s = r(this, Ss).toolbarPosition;
      if (s) {
        const {
          style: a
        } = t, o = r(this, Ss)._uiManager.direction === "ltr" ? 1 - s[0] : s[0];
        a.insetInlineEnd = `${100 * o}%`, a.top = `calc(${100 * s[1]}% + var(--editor-toolbar-vert-offset))`;
      }
      return E(this, Gu, tA).call(this), t;
    }
    hide() {
      var t;
      r(this, Yn).classList.add("hidden"), (t = r(this, Qn)) == null || t.hideDropdown();
    }
    show() {
      r(this, Yn).classList.remove("hidden");
    }
    addAltTextButton(t) {
      E(this, Ma, Mp).call(this, t), r(this, Zn).prepend(t, r(this, Vl, Xm));
    }
    addColorPicker(t) {
      x(this, Qn, t);
      const e = t.renderButton();
      E(this, Ma, Mp).call(this, e), r(this, Zn).prepend(e, r(this, Vl, Xm));
    }
    remove() {
      var t;
      r(this, Yn).remove(), (t = r(this, Qn)) == null || t.destroy(), x(this, Qn, null);
    }
  };
  Yn = new WeakMap(), Qn = new WeakMap(), Ss = new WeakMap(), Zn = new WeakMap(), Uu = new WeakSet(), Zy = function(t) {
    t.stopPropagation();
  }, zu = new WeakSet(), Jy = function(t) {
    r(this, Ss)._focusEventsAllowed = !1, t.preventDefault(), t.stopPropagation();
  }, Wu = new WeakSet(), qy = function(t) {
    r(this, Ss)._focusEventsAllowed = !0, t.preventDefault(), t.stopPropagation();
  }, Ma = new WeakSet(), Mp = function(t) {
    t.addEventListener("focusin", E(this, zu, Jy).bind(this), {
      capture: !0
    }), t.addEventListener("focusout", E(this, Wu, qy).bind(this), {
      capture: !0
    }), t.addEventListener("contextmenu", Le);
  }, Gu = new WeakSet(), tA = function() {
    const t = document.createElement("button");
    t.className = "delete", t.tabIndex = 0, t.setAttribute("data-l10n-id", `pdfjs-editor-remove-${r(this, Ss).editorType}-button`), E(this, Ma, Mp).call(this, t), t.addEventListener("click", (e) => {
      r(this, Ss)._uiManager.delete();
    }), r(this, Zn).append(t);
  }, Vl = new WeakSet(), Xm = function() {
    const t = document.createElement("div");
    return t.className = "divider", t;
  }, v(Xu, Uu);
  let am = Xu;
  class g0 {
    constructor(t) {
      v(this, Ku);
      v(this, Yu);
      v(this, Qu);
      v(this, $l, null);
      v(this, Jn, null);
      v(this, Ul, void 0);
      x(this, Ul, t);
    }
    show(t, e, s) {
      const [a, o] = E(this, Yu, sA).call(this, e, s), {
        style: h
      } = r(this, Jn) || x(this, Jn, E(this, Ku, eA).call(this));
      t.append(r(this, Jn)), h.insetInlineEnd = `${100 * a}%`, h.top = `calc(${100 * o}% + var(--editor-toolbar-vert-offset))`;
    }
    hide() {
      r(this, Jn).remove();
    }
  }
  $l = new WeakMap(), Jn = new WeakMap(), Ul = new WeakMap(), Ku = new WeakSet(), eA = function() {
    const t = x(this, Jn, document.createElement("div"));
    t.className = "editToolbar", t.setAttribute("role", "toolbar"), t.addEventListener("contextmenu", Le);
    const e = x(this, $l, document.createElement("div"));
    return e.className = "buttons", t.append(e), E(this, Qu, iA).call(this), t;
  }, Yu = new WeakSet(), sA = function(t, e) {
    let s = 0, a = 0;
    for (const o of t) {
      const h = o.y + o.height;
      if (h < s)
        continue;
      const c = o.x + (e ? o.width : 0);
      if (h > s) {
        a = c, s = h;
        continue;
      }
      e ? c > a && (a = c) : c < a && (a = c);
    }
    return [e ? 1 - a : a, s];
  }, Qu = new WeakSet(), iA = function() {
    const t = document.createElement("button");
    t.className = "highlightButton", t.tabIndex = 0, t.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button1");
    const e = document.createElement("span");
    t.append(e), e.className = "visuallyHidden", e.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label"), t.addEventListener("contextmenu", Le), t.addEventListener("click", () => {
      r(this, Ul).highlightSelection("floating_button");
    }), r(this, $l).append(t);
  };
  function Iu(A, t, e) {
    for (const s of e)
      t.addEventListener(s, A[s].bind(A));
  }
  function m0(A) {
    return Math.round(Math.min(255, Math.max(1, 255 * A))).toString(16).padStart(2, "0");
  }
  class v0 {
    constructor() {
      v(this, Zu, 0);
    }
    get id() {
      return `${y}${De(this, Zu)._++}`;
    }
  }
  Zu = new WeakMap();
  const Im = class Im {
    constructor() {
      v(this, Wl);
      v(this, zl, Ge());
      v(this, Ju, 0);
      v(this, Ke, null);
    }
    static get _isSVGFittingCanvas() {
      const t = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', s = new OffscreenCanvas(1, 3).getContext("2d"), a = new Image();
      a.src = t;
      const o = a.decode().then(() => (s.drawImage(a, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(s.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
      return tt(this, "_isSVGFittingCanvas", o);
    }
    async getFromFile(t) {
      const {
        lastModified: e,
        name: s,
        size: a,
        type: o
      } = t;
      return E(this, Wl, Km).call(this, `${e}_${s}_${a}_${o}`, t);
    }
    async getFromUrl(t) {
      return E(this, Wl, Km).call(this, t, t);
    }
    async getFromId(t) {
      r(this, Ke) || x(this, Ke, /* @__PURE__ */ new Map());
      const e = r(this, Ke).get(t);
      return e ? e.bitmap ? (e.refCounter += 1, e) : e.file ? this.getFromFile(e.file) : this.getFromUrl(e.url) : null;
    }
    getSvgUrl(t) {
      const e = r(this, Ke).get(t);
      return e != null && e.isSvg ? e.svgUrl : null;
    }
    deleteId(t) {
      r(this, Ke) || x(this, Ke, /* @__PURE__ */ new Map());
      const e = r(this, Ke).get(t);
      e && (e.refCounter -= 1, e.refCounter === 0 && (e.bitmap = null));
    }
    isValidId(t) {
      return t.startsWith(`image_${r(this, zl)}_`);
    }
  };
  zl = new WeakMap(), Ju = new WeakMap(), Ke = new WeakMap(), Wl = new WeakSet(), Km = async function(t, e) {
    r(this, Ke) || x(this, Ke, /* @__PURE__ */ new Map());
    let s = r(this, Ke).get(t);
    if (s === null)
      return null;
    if (s != null && s.bitmap)
      return s.refCounter += 1, s;
    try {
      s || (s = {
        bitmap: null,
        id: `image_${r(this, zl)}_${De(this, Ju)._++}`,
        refCounter: 0,
        isSvg: !1
      });
      let a;
      if (typeof e == "string" ? (s.url = e, a = await Ru(e, "blob")) : a = s.file = e, a.type === "image/svg+xml") {
        const o = Im._isSVGFittingCanvas, h = new FileReader(), c = new Image(), p = new Promise((g, b) => {
          c.onload = () => {
            s.bitmap = c, s.isSvg = !0, g();
          }, h.onload = async () => {
            const S = s.svgUrl = h.result;
            c.src = await o ? `${S}#svgView(preserveAspectRatio(none))` : S;
          }, c.onerror = h.onerror = b;
        });
        h.readAsDataURL(a), await p;
      } else
        s.bitmap = await createImageBitmap(a);
      s.refCounter = 1;
    } catch (a) {
      console.error(a), s = null;
    }
    return r(this, Ke).set(t, s), s && r(this, Ke).set(s.id, s), s;
  };
  let om = Im;
  class b0 {
    constructor(t = 128) {
      v(this, ae, []);
      v(this, Gi, !1);
      v(this, Gl, void 0);
      v(this, oe, -1);
      x(this, Gl, t);
    }
    add({
      cmd: t,
      undo: e,
      post: s,
      mustExec: a,
      type: o = NaN,
      overwriteIfSameType: h = !1,
      keepUndo: c = !1
    }) {
      if (a && t(), r(this, Gi))
        return;
      const p = {
        cmd: t,
        undo: e,
        post: s,
        type: o
      };
      if (r(this, oe) === -1) {
        r(this, ae).length > 0 && (r(this, ae).length = 0), x(this, oe, 0), r(this, ae).push(p);
        return;
      }
      if (h && r(this, ae)[r(this, oe)].type === o) {
        c && (p.undo = r(this, ae)[r(this, oe)].undo), r(this, ae)[r(this, oe)] = p;
        return;
      }
      const g = r(this, oe) + 1;
      g === r(this, Gl) ? r(this, ae).splice(0, 1) : (x(this, oe, g), g < r(this, ae).length && r(this, ae).splice(g)), r(this, ae).push(p);
    }
    undo() {
      if (r(this, oe) === -1)
        return;
      x(this, Gi, !0);
      const {
        undo: t,
        post: e
      } = r(this, ae)[r(this, oe)];
      t(), e == null || e(), x(this, Gi, !1), x(this, oe, r(this, oe) - 1);
    }
    redo() {
      if (r(this, oe) < r(this, ae).length - 1) {
        x(this, oe, r(this, oe) + 1), x(this, Gi, !0);
        const {
          cmd: t,
          post: e
        } = r(this, ae)[r(this, oe)];
        t(), e == null || e(), x(this, Gi, !1);
      }
    }
    hasSomethingToUndo() {
      return r(this, oe) !== -1;
    }
    hasSomethingToRedo() {
      return r(this, oe) < r(this, ae).length - 1;
    }
    destroy() {
      x(this, ae, null);
    }
  }
  ae = new WeakMap(), Gi = new WeakMap(), Gl = new WeakMap(), oe = new WeakMap();
  class Ll {
    constructor(t) {
      v(this, qu);
      this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
      const {
        isMac: e
      } = nt.platform;
      for (const [s, a, o = {}] of t)
        for (const h of s) {
          const c = h.startsWith("mac+");
          e && c ? (this.callbacks.set(h.slice(4), {
            callback: a,
            options: o
          }), this.allKeys.add(h.split("+").at(-1))) : !e && !c && (this.callbacks.set(h, {
            callback: a,
            options: o
          }), this.allKeys.add(h.split("+").at(-1)));
        }
    }
    exec(t, e) {
      if (!this.allKeys.has(e.key))
        return;
      const s = this.callbacks.get(E(this, qu, nA).call(this, e));
      if (!s)
        return;
      const {
        callback: a,
        options: {
          bubbles: o = !1,
          args: h = [],
          checker: c = null
        }
      } = s;
      c && !c(t, e) || (a.bind(t, ...h, e)(), o || (e.stopPropagation(), e.preventDefault()));
    }
  }
  qu = new WeakSet(), nA = function(t) {
    t.altKey && this.buffer.push("alt"), t.ctrlKey && this.buffer.push("ctrl"), t.metaKey && this.buffer.push("meta"), t.shiftKey && this.buffer.push("shift"), this.buffer.push(t.key);
    const e = this.buffer.join("+");
    return this.buffer.length = 0, e;
  };
  const tf = class tf {
    get _colors() {
      const t = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
      return p0(t), tt(this, "_colors", t);
    }
    convert(t) {
      const e = rm(t);
      if (!window.matchMedia("(forced-colors: active)").matches)
        return e;
      for (const [s, a] of this._colors)
        if (a.every((o, h) => o === e[h]))
          return tf._colorsMapping.get(s);
      return e;
    }
    getHexCode(t) {
      const e = this._colors.get(t);
      return e ? et.makeHexColor(...e) : t;
    }
  };
  bt(tf, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
  let lm = tf;
  const Ha = class Ha {
    constructor(t, e, s, a, o, h, c, p, g) {
      v(this, Ba);
      v(this, sf);
      v(this, nf);
      v(this, ja);
      v(this, rf);
      v(this, af);
      v(this, of);
      v(this, uh);
      v(this, fh);
      v(this, ph);
      v(this, gh);
      v(this, mh);
      v(this, ce);
      v(this, Rs);
      v(this, lf);
      v(this, hf);
      v(this, vh);
      v(this, cf);
      v(this, ir);
      v(this, bh);
      v(this, Fe, null);
      v(this, qt, /* @__PURE__ */ new Map());
      v(this, le, /* @__PURE__ */ new Map());
      v(this, Oa, null);
      v(this, ti, null);
      v(this, ka, null);
      v(this, ns, new b0());
      v(this, Da, 0);
      v(this, qn, /* @__PURE__ */ new Set());
      v(this, xs, null);
      v(this, ei, null);
      v(this, tr, /* @__PURE__ */ new Set());
      v(this, Xl, !1);
      v(this, Kl, null);
      v(this, Ps, null);
      v(this, Na, null);
      v(this, Xi, !1);
      v(this, Ts, null);
      v(this, ef, new v0());
      v(this, Ki, !1);
      v(this, Yl, !1);
      v(this, er, null);
      v(this, Ql, null);
      v(this, Fa, null);
      v(this, he, w.NONE);
      v(this, It, /* @__PURE__ */ new Set());
      v(this, si, null);
      v(this, sr, null);
      v(this, Zl, null);
      v(this, Jl, this.blur.bind(this));
      v(this, ql, this.focus.bind(this));
      v(this, th, this.copy.bind(this));
      v(this, eh, this.cut.bind(this));
      v(this, sh, this.paste.bind(this));
      v(this, ih, this.keydown.bind(this));
      v(this, nh, this.keyup.bind(this));
      v(this, rh, this.onEditingAction.bind(this));
      v(this, ah, this.onPageChanging.bind(this));
      v(this, oh, this.onScaleChanging.bind(this));
      v(this, lh, E(this, nf, aA).bind(this));
      v(this, hh, this.onRotationChanging.bind(this));
      v(this, ch, {
        isEditing: !1,
        isEmpty: !0,
        hasSomethingToUndo: !1,
        hasSomethingToRedo: !1,
        hasSelectedEditor: !1,
        hasSelectedText: !1
      });
      v(this, Yi, [0, 0]);
      v(this, Cs, null);
      v(this, ii, null);
      v(this, dh, null);
      x(this, ii, t), x(this, dh, e), x(this, Oa, s), this._eventBus = a, this._eventBus._on("editingaction", r(this, rh)), this._eventBus._on("pagechanging", r(this, ah)), this._eventBus._on("scalechanging", r(this, oh)), this._eventBus._on("rotationchanging", r(this, hh)), E(this, rf, oA).call(this), E(this, fh, Qm).call(this), x(this, ti, o.annotationStorage), x(this, Kl, o.filterFactory), x(this, sr, h), x(this, Na, c || null), x(this, Xl, p), x(this, Fa, g || null), this.viewParameters = {
        realScale: Vi.PDF_TO_CSS_UNITS,
        rotation: 0
      }, this.isShiftKeyDown = !1;
    }
    static get _keyboardManager() {
      const t = Ha.prototype, e = (h) => r(h, ii).contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && h.hasSomethingToControl(), s = (h, {
        target: c
      }) => {
        if (c instanceof HTMLInputElement) {
          const {
            type: p
          } = c;
          return p !== "text" && p !== "number";
        }
        return !0;
      }, a = this.TRANSLATE_SMALL, o = this.TRANSLATE_BIG;
      return tt(this, "_keyboardManager", new Ll([[["ctrl+a", "mac+meta+a"], t.selectAll, {
        checker: s
      }], [["ctrl+z", "mac+meta+z"], t.undo, {
        checker: s
      }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], t.redo, {
        checker: s
      }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], t.delete, {
        checker: s
      }], [["Enter", "mac+Enter"], t.addNewEditorFromKeyboard, {
        checker: (h, {
          target: c
        }) => !(c instanceof HTMLButtonElement) && r(h, ii).contains(c) && !h.isEnterHandled
      }], [[" ", "mac+ "], t.addNewEditorFromKeyboard, {
        checker: (h, {
          target: c
        }) => !(c instanceof HTMLButtonElement) && r(h, ii).contains(document.activeElement)
      }], [["Escape", "mac+Escape"], t.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], t.translateSelectedEditors, {
        args: [-a, 0],
        checker: e
      }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], t.translateSelectedEditors, {
        args: [-o, 0],
        checker: e
      }], [["ArrowRight", "mac+ArrowRight"], t.translateSelectedEditors, {
        args: [a, 0],
        checker: e
      }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], t.translateSelectedEditors, {
        args: [o, 0],
        checker: e
      }], [["ArrowUp", "mac+ArrowUp"], t.translateSelectedEditors, {
        args: [0, -a],
        checker: e
      }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], t.translateSelectedEditors, {
        args: [0, -o],
        checker: e
      }], [["ArrowDown", "mac+ArrowDown"], t.translateSelectedEditors, {
        args: [0, a],
        checker: e
      }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], t.translateSelectedEditors, {
        args: [0, o],
        checker: e
      }]]));
    }
    destroy() {
      var t, e;
      E(this, ph, Zm).call(this), E(this, uh, Ym).call(this), this._eventBus._off("editingaction", r(this, rh)), this._eventBus._off("pagechanging", r(this, ah)), this._eventBus._off("scalechanging", r(this, oh)), this._eventBus._off("rotationchanging", r(this, hh));
      for (const s of r(this, le).values())
        s.destroy();
      r(this, le).clear(), r(this, qt).clear(), r(this, tr).clear(), x(this, Fe, null), r(this, It).clear(), r(this, ns).destroy(), (t = r(this, Oa)) == null || t.destroy(), (e = r(this, Ts)) == null || e.hide(), x(this, Ts, null), r(this, Ps) && (clearTimeout(r(this, Ps)), x(this, Ps, null)), r(this, Cs) && (clearTimeout(r(this, Cs)), x(this, Cs, null)), E(this, af, lA).call(this);
    }
    async mlGuess(t) {
      var e;
      return ((e = r(this, Fa)) == null ? void 0 : e.guess(t)) || null;
    }
    get hasMLManager() {
      return !!r(this, Fa);
    }
    get hcmFilter() {
      return tt(this, "hcmFilter", r(this, sr) ? r(this, Kl).addHCMFilter(r(this, sr).foreground, r(this, sr).background) : "none");
    }
    get direction() {
      return tt(this, "direction", getComputedStyle(r(this, ii)).direction);
    }
    get highlightColors() {
      return tt(this, "highlightColors", r(this, Na) ? new Map(r(this, Na).split(",").map((t) => t.split("=").map((e) => e.trim()))) : null);
    }
    get highlightColorNames() {
      return tt(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (t) => t.reverse())) : null);
    }
    setMainHighlightColorPicker(t) {
      x(this, Ql, t);
    }
    editAltText(t) {
      var e;
      (e = r(this, Oa)) == null || e.editAltText(this, t);
    }
    onPageChanging({
      pageNumber: t
    }) {
      x(this, Da, t - 1);
    }
    focusMainContainer() {
      r(this, ii).focus();
    }
    findParent(t, e) {
      for (const s of r(this, le).values()) {
        const {
          x: a,
          y: o,
          width: h,
          height: c
        } = s.div.getBoundingClientRect();
        if (t >= a && t <= a + h && e >= o && e <= o + c)
          return s;
      }
      return null;
    }
    disableUserSelect(t = !1) {
      r(this, dh).classList.toggle("noUserSelect", t);
    }
    addShouldRescale(t) {
      r(this, tr).add(t);
    }
    removeShouldRescale(t) {
      r(this, tr).delete(t);
    }
    onScaleChanging({
      scale: t
    }) {
      this.commitOrRemove(), this.viewParameters.realScale = t * Vi.PDF_TO_CSS_UNITS;
      for (const e of r(this, tr))
        e.onScaleChanging();
    }
    onRotationChanging({
      pagesRotation: t
    }) {
      this.commitOrRemove(), this.viewParameters.rotation = t;
    }
    highlightSelection(t = "") {
      const e = document.getSelection();
      if (!e || e.isCollapsed)
        return;
      const {
        anchorNode: s,
        anchorOffset: a,
        focusNode: o,
        focusOffset: h
      } = e, c = e.toString(), g = E(this, Ba, Op).call(this, e).closest(".textLayer"), b = this.getSelectionBoxes(g);
      if (b) {
        e.empty(), r(this, he) === w.NONE && (this._eventBus.dispatch("showannotationeditorui", {
          source: this,
          mode: w.HIGHLIGHT
        }), this.showAllEditors("highlight", !0, !0));
        for (const S of r(this, le).values())
          if (S.hasTextLayer(g)) {
            S.createAndAddNewEditor({
              x: 0,
              y: 0
            }, !1, {
              methodOfCreation: t,
              boxes: b,
              anchorNode: s,
              anchorOffset: a,
              focusNode: o,
              focusOffset: h,
              text: c
            });
            break;
          }
      }
    }
    addToAnnotationStorage(t) {
      !t.isEmpty() && r(this, ti) && !r(this, ti).has(t.id) && r(this, ti).setValue(t.id, t);
    }
    blur() {
      if (this.isShiftKeyDown = !1, r(this, Xi) && (x(this, Xi, !1), E(this, ja, kp).call(this, "main_toolbar")), !this.hasSelection)
        return;
      const {
        activeElement: t
      } = document;
      for (const e of r(this, It))
        if (e.div.contains(t)) {
          x(this, er, [e, t]), e._focusEventsAllowed = !1;
          break;
        }
    }
    focus() {
      if (!r(this, er))
        return;
      const [t, e] = r(this, er);
      x(this, er, null), e.addEventListener("focusin", () => {
        t._focusEventsAllowed = !0;
      }, {
        once: !0
      }), e.focus();
    }
    addEditListeners() {
      E(this, fh, Qm).call(this), E(this, gh, Jm).call(this);
    }
    removeEditListeners() {
      E(this, ph, Zm).call(this), E(this, mh, qm).call(this);
    }
    copy(t) {
      var s;
      if (t.preventDefault(), (s = r(this, Fe)) == null || s.commitOrRemove(), !this.hasSelection)
        return;
      const e = [];
      for (const a of r(this, It)) {
        const o = a.serialize(!0);
        o && e.push(o);
      }
      e.length !== 0 && t.clipboardData.setData("application/pdfjs", JSON.stringify(e));
    }
    cut(t) {
      this.copy(t), this.delete();
    }
    paste(t) {
      t.preventDefault();
      const {
        clipboardData: e
      } = t;
      for (const o of e.items)
        for (const h of r(this, ei))
          if (h.isHandlingMimeForPasting(o.type)) {
            h.paste(o, this.currentLayer);
            return;
          }
      let s = e.getData("application/pdfjs");
      if (!s)
        return;
      try {
        s = JSON.parse(s);
      } catch (o) {
        j(`paste: "${o.message}".`);
        return;
      }
      if (!Array.isArray(s))
        return;
      this.unselectAll();
      const a = this.currentLayer;
      try {
        const o = [];
        for (const p of s) {
          const g = a.deserialize(p);
          if (!g)
            return;
          o.push(g);
        }
        const h = () => {
          for (const p of o)
            E(this, vh, tv).call(this, p);
          E(this, bh, ev).call(this, o);
        }, c = () => {
          for (const p of o)
            p.remove();
        };
        this.addCommands({
          cmd: h,
          undo: c,
          mustExec: !0
        });
      } catch (o) {
        j(`paste: "${o.message}".`);
      }
    }
    keydown(t) {
      !this.isShiftKeyDown && t.key === "Shift" && (this.isShiftKeyDown = !0), r(this, he) !== w.NONE && !this.isEditorHandlingKeyboard && Ha._keyboardManager.exec(this, t);
    }
    keyup(t) {
      this.isShiftKeyDown && t.key === "Shift" && (this.isShiftKeyDown = !1, r(this, Xi) && (x(this, Xi, !1), E(this, ja, kp).call(this, "main_toolbar")));
    }
    onEditingAction({
      name: t
    }) {
      switch (t) {
        case "undo":
        case "redo":
        case "delete":
        case "selectAll":
          this[t]();
          break;
        case "highlightSelection":
          this.highlightSelection("context_menu");
          break;
      }
    }
    setEditingState(t) {
      t ? (E(this, of, hA).call(this), E(this, gh, Jm).call(this), E(this, ce, Re).call(this, {
        isEditing: r(this, he) !== w.NONE,
        isEmpty: E(this, ir, gd).call(this),
        hasSomethingToUndo: r(this, ns).hasSomethingToUndo(),
        hasSomethingToRedo: r(this, ns).hasSomethingToRedo(),
        hasSelectedEditor: !1
      })) : (E(this, uh, Ym).call(this), E(this, mh, qm).call(this), E(this, ce, Re).call(this, {
        isEditing: !1
      }), this.disableUserSelect(!1));
    }
    registerEditorTypes(t) {
      if (!r(this, ei)) {
        x(this, ei, t);
        for (const e of r(this, ei))
          E(this, Rs, vn).call(this, e.defaultPropertiesToUpdate);
      }
    }
    getId() {
      return r(this, ef).id;
    }
    get currentLayer() {
      return r(this, le).get(r(this, Da));
    }
    getLayer(t) {
      return r(this, le).get(t);
    }
    get currentPageIndex() {
      return r(this, Da);
    }
    addLayer(t) {
      r(this, le).set(t.pageIndex, t), r(this, Ki) ? t.enable() : t.disable();
    }
    removeLayer(t) {
      r(this, le).delete(t.pageIndex);
    }
    updateMode(t, e = null, s = !1) {
      if (r(this, he) !== t) {
        if (x(this, he, t), t === w.NONE) {
          this.setEditingState(!1), E(this, hf, dA).call(this);
          return;
        }
        this.setEditingState(!0), E(this, lf, cA).call(this), this.unselectAll();
        for (const a of r(this, le).values())
          a.updateMode(t);
        if (!e && s) {
          this.addNewEditorFromKeyboard();
          return;
        }
        if (e) {
          for (const a of r(this, qt).values())
            if (a.annotationElementId === e) {
              this.setSelected(a), a.enterInEditMode();
              break;
            }
        }
      }
    }
    addNewEditorFromKeyboard() {
      this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor();
    }
    updateToolbar(t) {
      t !== r(this, he) && this._eventBus.dispatch("switchannotationeditormode", {
        source: this,
        mode: t
      });
    }
    updateParams(t, e) {
      var s;
      if (r(this, ei)) {
        switch (t) {
          case P.CREATE:
            this.currentLayer.addNewEditor();
            return;
          case P.HIGHLIGHT_DEFAULT_COLOR:
            (s = r(this, Ql)) == null || s.updateColor(e);
            break;
          case P.HIGHLIGHT_SHOW_ALL:
            this._eventBus.dispatch("reporttelemetry", {
              source: this,
              details: {
                type: "editing",
                data: {
                  type: "highlight",
                  action: "toggle_visibility"
                }
              }
            }), (r(this, Zl) || x(this, Zl, /* @__PURE__ */ new Map())).set(t, e), this.showAllEditors("highlight", e);
            break;
        }
        for (const a of r(this, It))
          a.updateParams(t, e);
        for (const a of r(this, ei))
          a.updateDefaultParams(t, e);
      }
    }
    showAllEditors(t, e, s = !1) {
      var o;
      for (const h of r(this, qt).values())
        h.editorType === t && h.show(e);
      (((o = r(this, Zl)) == null ? void 0 : o.get(P.HIGHLIGHT_SHOW_ALL)) ?? !0) !== e && E(this, Rs, vn).call(this, [[P.HIGHLIGHT_SHOW_ALL, e]]);
    }
    enableWaiting(t = !1) {
      if (r(this, Yl) !== t) {
        x(this, Yl, t);
        for (const e of r(this, le).values())
          t ? e.disableClick() : e.enableClick(), e.div.classList.toggle("waiting", t);
      }
    }
    getEditors(t) {
      const e = [];
      for (const s of r(this, qt).values())
        s.pageIndex === t && e.push(s);
      return e;
    }
    getEditor(t) {
      return r(this, qt).get(t);
    }
    addEditor(t) {
      r(this, qt).set(t.id, t);
    }
    removeEditor(t) {
      var e;
      t.div.contains(document.activeElement) && (r(this, Ps) && clearTimeout(r(this, Ps)), x(this, Ps, setTimeout(() => {
        this.focusMainContainer(), x(this, Ps, null);
      }, 0))), r(this, qt).delete(t.id), this.unselect(t), (!t.annotationElementId || !r(this, qn).has(t.annotationElementId)) && ((e = r(this, ti)) == null || e.remove(t.id));
    }
    addDeletedAnnotationElement(t) {
      r(this, qn).add(t.annotationElementId), this.addChangedExistingAnnotation(t), t.deleted = !0;
    }
    isDeletedAnnotationElement(t) {
      return r(this, qn).has(t);
    }
    removeDeletedAnnotationElement(t) {
      r(this, qn).delete(t.annotationElementId), this.removeChangedExistingAnnotation(t), t.deleted = !1;
    }
    setActiveEditor(t) {
      r(this, Fe) !== t && (x(this, Fe, t), t && E(this, Rs, vn).call(this, t.propertiesToUpdate));
    }
    updateUI(t) {
      r(this, cf, uA) === t && E(this, Rs, vn).call(this, t.propertiesToUpdate);
    }
    toggleSelected(t) {
      if (r(this, It).has(t)) {
        r(this, It).delete(t), t.unselect(), E(this, ce, Re).call(this, {
          hasSelectedEditor: this.hasSelection
        });
        return;
      }
      r(this, It).add(t), t.select(), E(this, Rs, vn).call(this, t.propertiesToUpdate), E(this, ce, Re).call(this, {
        hasSelectedEditor: !0
      });
    }
    setSelected(t) {
      for (const e of r(this, It))
        e !== t && e.unselect();
      r(this, It).clear(), r(this, It).add(t), t.select(), E(this, Rs, vn).call(this, t.propertiesToUpdate), E(this, ce, Re).call(this, {
        hasSelectedEditor: !0
      });
    }
    isSelected(t) {
      return r(this, It).has(t);
    }
    get firstSelectedEditor() {
      return r(this, It).values().next().value;
    }
    unselect(t) {
      t.unselect(), r(this, It).delete(t), E(this, ce, Re).call(this, {
        hasSelectedEditor: this.hasSelection
      });
    }
    get hasSelection() {
      return r(this, It).size !== 0;
    }
    get isEnterHandled() {
      return r(this, It).size === 1 && this.firstSelectedEditor.isEnterHandled;
    }
    undo() {
      r(this, ns).undo(), E(this, ce, Re).call(this, {
        hasSomethingToUndo: r(this, ns).hasSomethingToUndo(),
        hasSomethingToRedo: !0,
        isEmpty: E(this, ir, gd).call(this)
      });
    }
    redo() {
      r(this, ns).redo(), E(this, ce, Re).call(this, {
        hasSomethingToUndo: !0,
        hasSomethingToRedo: r(this, ns).hasSomethingToRedo(),
        isEmpty: E(this, ir, gd).call(this)
      });
    }
    addCommands(t) {
      r(this, ns).add(t), E(this, ce, Re).call(this, {
        hasSomethingToUndo: !0,
        hasSomethingToRedo: !1,
        isEmpty: E(this, ir, gd).call(this)
      });
    }
    delete() {
      if (this.commitOrRemove(), !this.hasSelection)
        return;
      const t = [...r(this, It)], e = () => {
        for (const a of t)
          a.remove();
      }, s = () => {
        for (const a of t)
          E(this, vh, tv).call(this, a);
      };
      this.addCommands({
        cmd: e,
        undo: s,
        mustExec: !0
      });
    }
    commitOrRemove() {
      var t;
      (t = r(this, Fe)) == null || t.commitOrRemove();
    }
    hasSomethingToControl() {
      return r(this, Fe) || this.hasSelection;
    }
    selectAll() {
      for (const t of r(this, It))
        t.commit();
      E(this, bh, ev).call(this, r(this, qt).values());
    }
    unselectAll() {
      if (!(r(this, Fe) && (r(this, Fe).commitOrRemove(), r(this, he) !== w.NONE)) && this.hasSelection) {
        for (const t of r(this, It))
          t.unselect();
        r(this, It).clear(), E(this, ce, Re).call(this, {
          hasSelectedEditor: !1
        });
      }
    }
    translateSelectedEditors(t, e, s = !1) {
      if (s || this.commitOrRemove(), !this.hasSelection)
        return;
      r(this, Yi)[0] += t, r(this, Yi)[1] += e;
      const [a, o] = r(this, Yi), h = [...r(this, It)], c = 1e3;
      r(this, Cs) && clearTimeout(r(this, Cs)), x(this, Cs, setTimeout(() => {
        x(this, Cs, null), r(this, Yi)[0] = r(this, Yi)[1] = 0, this.addCommands({
          cmd: () => {
            for (const p of h)
              r(this, qt).has(p.id) && p.translateInPage(a, o);
          },
          undo: () => {
            for (const p of h)
              r(this, qt).has(p.id) && p.translateInPage(-a, -o);
          },
          mustExec: !1
        });
      }, c));
      for (const p of h)
        p.translateInPage(t, e);
    }
    setUpDragSession() {
      if (this.hasSelection) {
        this.disableUserSelect(!0), x(this, xs, /* @__PURE__ */ new Map());
        for (const t of r(this, It))
          r(this, xs).set(t, {
            savedX: t.x,
            savedY: t.y,
            savedPageIndex: t.pageIndex,
            newX: 0,
            newY: 0,
            newPageIndex: -1
          });
      }
    }
    endDragSession() {
      if (!r(this, xs))
        return !1;
      this.disableUserSelect(!1);
      const t = r(this, xs);
      x(this, xs, null);
      let e = !1;
      for (const [{
        x: a,
        y: o,
        pageIndex: h
      }, c] of t)
        c.newX = a, c.newY = o, c.newPageIndex = h, e || (e = a !== c.savedX || o !== c.savedY || h !== c.savedPageIndex);
      if (!e)
        return !1;
      const s = (a, o, h, c) => {
        if (r(this, qt).has(a.id)) {
          const p = r(this, le).get(c);
          p ? a._setParentAndPosition(p, o, h) : (a.pageIndex = c, a.x = o, a.y = h);
        }
      };
      return this.addCommands({
        cmd: () => {
          for (const [a, {
            newX: o,
            newY: h,
            newPageIndex: c
          }] of t)
            s(a, o, h, c);
        },
        undo: () => {
          for (const [a, {
            savedX: o,
            savedY: h,
            savedPageIndex: c
          }] of t)
            s(a, o, h, c);
        },
        mustExec: !0
      }), !0;
    }
    dragSelectedEditors(t, e) {
      if (r(this, xs))
        for (const s of r(this, xs).keys())
          s.drag(t, e);
    }
    rebuild(t) {
      if (t.parent === null) {
        const e = this.getLayer(t.pageIndex);
        e ? (e.changeParent(t), e.addOrRebuild(t)) : (this.addEditor(t), this.addToAnnotationStorage(t), t.rebuild());
      } else
        t.parent.addOrRebuild(t);
    }
    get isEditorHandlingKeyboard() {
      var t;
      return ((t = this.getActive()) == null ? void 0 : t.shouldGetKeyboardEvents()) || r(this, It).size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
    }
    isActive(t) {
      return r(this, Fe) === t;
    }
    getActive() {
      return r(this, Fe);
    }
    getMode() {
      return r(this, he);
    }
    get imageManager() {
      return tt(this, "imageManager", new om());
    }
    getSelectionBoxes(t) {
      if (!t)
        return null;
      const e = document.getSelection();
      for (let g = 0, b = e.rangeCount; g < b; g++)
        if (!t.contains(e.getRangeAt(g).commonAncestorContainer))
          return null;
      const {
        x: s,
        y: a,
        width: o,
        height: h
      } = t.getBoundingClientRect();
      let c;
      switch (t.getAttribute("data-main-rotation")) {
        case "90":
          c = (g, b, S, T) => ({
            x: (b - a) / h,
            y: 1 - (g + S - s) / o,
            width: T / h,
            height: S / o
          });
          break;
        case "180":
          c = (g, b, S, T) => ({
            x: 1 - (g + S - s) / o,
            y: 1 - (b + T - a) / h,
            width: S / o,
            height: T / h
          });
          break;
        case "270":
          c = (g, b, S, T) => ({
            x: 1 - (b + T - a) / h,
            y: (g - s) / o,
            width: T / h,
            height: S / o
          });
          break;
        default:
          c = (g, b, S, T) => ({
            x: (g - s) / o,
            y: (b - a) / h,
            width: S / o,
            height: T / h
          });
          break;
      }
      const p = [];
      for (let g = 0, b = e.rangeCount; g < b; g++) {
        const S = e.getRangeAt(g);
        if (!S.collapsed)
          for (const {
            x: T,
            y: C,
            width: R,
            height: M
          } of S.getClientRects())
            R === 0 || M === 0 || p.push(c(T, C, R, M));
      }
      return p.length === 0 ? null : p;
    }
    addChangedExistingAnnotation({
      annotationElementId: t,
      id: e
    }) {
      (r(this, ka) || x(this, ka, /* @__PURE__ */ new Map())).set(t, e);
    }
    removeChangedExistingAnnotation({
      annotationElementId: t
    }) {
      var e;
      (e = r(this, ka)) == null || e.delete(t);
    }
    renderAnnotationElement(t) {
      var a;
      const e = (a = r(this, ka)) == null ? void 0 : a.get(t.data.id);
      if (!e)
        return;
      const s = r(this, ti).getRawValue(e);
      s && (r(this, he) === w.NONE && !s.hasBeenModified || s.renderAnnotationElement(t));
    }
  };
  Fe = new WeakMap(), qt = new WeakMap(), le = new WeakMap(), Oa = new WeakMap(), ti = new WeakMap(), ka = new WeakMap(), ns = new WeakMap(), Da = new WeakMap(), qn = new WeakMap(), xs = new WeakMap(), ei = new WeakMap(), tr = new WeakMap(), Xl = new WeakMap(), Kl = new WeakMap(), Ps = new WeakMap(), Na = new WeakMap(), Xi = new WeakMap(), Ts = new WeakMap(), ef = new WeakMap(), Ki = new WeakMap(), Yl = new WeakMap(), er = new WeakMap(), Ql = new WeakMap(), Fa = new WeakMap(), he = new WeakMap(), It = new WeakMap(), si = new WeakMap(), sr = new WeakMap(), Zl = new WeakMap(), Jl = new WeakMap(), ql = new WeakMap(), th = new WeakMap(), eh = new WeakMap(), sh = new WeakMap(), ih = new WeakMap(), nh = new WeakMap(), rh = new WeakMap(), ah = new WeakMap(), oh = new WeakMap(), lh = new WeakMap(), hh = new WeakMap(), ch = new WeakMap(), Yi = new WeakMap(), Cs = new WeakMap(), ii = new WeakMap(), dh = new WeakMap(), Ba = new WeakSet(), Op = function({
    anchorNode: t
  }) {
    return t.nodeType === Node.TEXT_NODE ? t.parentElement : t;
  }, sf = new WeakSet(), rA = function() {
    const t = document.getSelection();
    if (!t || t.isCollapsed)
      return;
    const s = E(this, Ba, Op).call(this, t).closest(".textLayer"), a = this.getSelectionBoxes(s);
    a && (r(this, Ts) || x(this, Ts, new g0(this)), r(this, Ts).show(s, a, this.direction === "ltr"));
  }, nf = new WeakSet(), aA = function() {
    var o, h, c;
    const t = document.getSelection();
    if (!t || t.isCollapsed) {
      r(this, si) && ((o = r(this, Ts)) == null || o.hide(), x(this, si, null), E(this, ce, Re).call(this, {
        hasSelectedText: !1
      }));
      return;
    }
    const {
      anchorNode: e
    } = t;
    if (e === r(this, si))
      return;
    if (!E(this, Ba, Op).call(this, t).closest(".textLayer")) {
      r(this, si) && ((h = r(this, Ts)) == null || h.hide(), x(this, si, null), E(this, ce, Re).call(this, {
        hasSelectedText: !1
      }));
      return;
    }
    if ((c = r(this, Ts)) == null || c.hide(), x(this, si, e), E(this, ce, Re).call(this, {
      hasSelectedText: !0
    }), !(r(this, he) !== w.HIGHLIGHT && r(this, he) !== w.NONE) && (r(this, he) === w.HIGHLIGHT && this.showAllEditors("highlight", !0, !0), x(this, Xi, this.isShiftKeyDown), !this.isShiftKeyDown)) {
      const p = (g) => {
        g.type === "pointerup" && g.button !== 0 || (window.removeEventListener("pointerup", p), window.removeEventListener("blur", p), g.type === "pointerup" && E(this, ja, kp).call(this, "main_toolbar"));
      };
      window.addEventListener("pointerup", p), window.addEventListener("blur", p);
    }
  }, ja = new WeakSet(), kp = function(t = "") {
    r(this, he) === w.HIGHLIGHT ? this.highlightSelection(t) : r(this, Xl) && E(this, sf, rA).call(this);
  }, rf = new WeakSet(), oA = function() {
    document.addEventListener("selectionchange", r(this, lh));
  }, af = new WeakSet(), lA = function() {
    document.removeEventListener("selectionchange", r(this, lh));
  }, of = new WeakSet(), hA = function() {
    window.addEventListener("focus", r(this, ql)), window.addEventListener("blur", r(this, Jl));
  }, uh = new WeakSet(), Ym = function() {
    window.removeEventListener("focus", r(this, ql)), window.removeEventListener("blur", r(this, Jl));
  }, fh = new WeakSet(), Qm = function() {
    window.addEventListener("keydown", r(this, ih)), window.addEventListener("keyup", r(this, nh));
  }, ph = new WeakSet(), Zm = function() {
    window.removeEventListener("keydown", r(this, ih)), window.removeEventListener("keyup", r(this, nh));
  }, gh = new WeakSet(), Jm = function() {
    document.addEventListener("copy", r(this, th)), document.addEventListener("cut", r(this, eh)), document.addEventListener("paste", r(this, sh));
  }, mh = new WeakSet(), qm = function() {
    document.removeEventListener("copy", r(this, th)), document.removeEventListener("cut", r(this, eh)), document.removeEventListener("paste", r(this, sh));
  }, ce = new WeakSet(), Re = function(t) {
    Object.entries(t).some(([s, a]) => r(this, ch)[s] !== a) && (this._eventBus.dispatch("annotationeditorstateschanged", {
      source: this,
      details: Object.assign(r(this, ch), t)
    }), r(this, he) === w.HIGHLIGHT && t.hasSelectedEditor === !1 && E(this, Rs, vn).call(this, [[P.HIGHLIGHT_FREE, !0]]));
  }, Rs = new WeakSet(), vn = function(t) {
    this._eventBus.dispatch("annotationeditorparamschanged", {
      source: this,
      details: t
    });
  }, lf = new WeakSet(), cA = function() {
    if (!r(this, Ki)) {
      x(this, Ki, !0);
      for (const t of r(this, le).values())
        t.enable();
      for (const t of r(this, qt).values())
        t.enable();
    }
  }, hf = new WeakSet(), dA = function() {
    if (this.unselectAll(), r(this, Ki)) {
      x(this, Ki, !1);
      for (const t of r(this, le).values())
        t.disable();
      for (const t of r(this, qt).values())
        t.disable();
    }
  }, vh = new WeakSet(), tv = function(t) {
    const e = r(this, le).get(t.pageIndex);
    e ? e.addOrRebuild(t) : (this.addEditor(t), this.addToAnnotationStorage(t));
  }, cf = new WeakSet(), uA = function() {
    let t = null;
    for (t of r(this, It))
      ;
    return t;
  }, ir = new WeakSet(), gd = function() {
    if (r(this, qt).size === 0)
      return !0;
    if (r(this, qt).size === 1)
      for (const t of r(this, qt).values())
        return t.isEmpty();
    return !1;
  }, bh = new WeakSet(), ev = function(t) {
    for (const e of r(this, It))
      e.unselect();
    r(this, It).clear();
    for (const e of t)
      e.isEmpty() || (r(this, It).add(e), e.select());
    E(this, ce, Re).call(this, {
      hasSelectedEditor: this.hasSelection
    });
  }, bt(Ha, "TRANSLATE_SMALL", 1), bt(Ha, "TRANSLATE_BIG", 10);
  let Hn = Ha;
  const li = class li {
    constructor(t) {
      v(this, yh);
      v(this, ni, "");
      v(this, ri, !1);
      v(this, rs, null);
      v(this, ai, null);
      v(this, as, null);
      v(this, Va, !1);
      v(this, oi, null);
      x(this, oi, t);
    }
    static initialize(t) {
      li._l10nPromise || (li._l10nPromise = t);
    }
    async render() {
      const t = x(this, rs, document.createElement("button"));
      t.className = "altText";
      const e = await li._l10nPromise.get("pdfjs-editor-alt-text-button-label");
      t.textContent = e, t.setAttribute("aria-label", e), t.tabIndex = "0", t.addEventListener("contextmenu", Le), t.addEventListener("pointerdown", (a) => a.stopPropagation());
      const s = (a) => {
        a.preventDefault(), r(this, oi)._uiManager.editAltText(r(this, oi));
      };
      return t.addEventListener("click", s, {
        capture: !0
      }), t.addEventListener("keydown", (a) => {
        a.target === t && a.key === "Enter" && (x(this, Va, !0), s(a));
      }), await E(this, yh, sv).call(this), t;
    }
    finish() {
      r(this, rs) && (r(this, rs).focus({
        focusVisible: r(this, Va)
      }), x(this, Va, !1));
    }
    isEmpty() {
      return !r(this, ni) && !r(this, ri);
    }
    get data() {
      return {
        altText: r(this, ni),
        decorative: r(this, ri)
      };
    }
    set data({
      altText: t,
      decorative: e
    }) {
      r(this, ni) === t && r(this, ri) === e || (x(this, ni, t), x(this, ri, e), E(this, yh, sv).call(this));
    }
    toggle(t = !1) {
      r(this, rs) && (!t && r(this, as) && (clearTimeout(r(this, as)), x(this, as, null)), r(this, rs).disabled = !t);
    }
    destroy() {
      var t;
      (t = r(this, rs)) == null || t.remove(), x(this, rs, null), x(this, ai, null);
    }
  };
  ni = new WeakMap(), ri = new WeakMap(), rs = new WeakMap(), ai = new WeakMap(), as = new WeakMap(), Va = new WeakMap(), oi = new WeakMap(), yh = new WeakSet(), sv = async function() {
    var a;
    const t = r(this, rs);
    if (!t)
      return;
    if (!r(this, ni) && !r(this, ri)) {
      t.classList.remove("done"), (a = r(this, ai)) == null || a.remove();
      return;
    }
    t.classList.add("done"), li._l10nPromise.get("pdfjs-editor-alt-text-edit-button-label").then((o) => {
      t.setAttribute("aria-label", o);
    });
    let e = r(this, ai);
    if (!e) {
      x(this, ai, e = document.createElement("span")), e.className = "tooltip", e.setAttribute("role", "tooltip");
      const o = e.id = `alt-text-tooltip-${r(this, oi).id}`;
      t.setAttribute("aria-describedby", o);
      const h = 100;
      t.addEventListener("mouseenter", () => {
        x(this, as, setTimeout(() => {
          x(this, as, null), r(this, ai).classList.add("show"), r(this, oi)._reportTelemetry({
            action: "alt_text_tooltip"
          });
        }, h));
      }), t.addEventListener("mouseleave", () => {
        var c;
        r(this, as) && (clearTimeout(r(this, as)), x(this, as, null)), (c = r(this, ai)) == null || c.classList.remove("show");
      });
    }
    e.innerText = r(this, ri) ? await li._l10nPromise.get("pdfjs-editor-alt-text-decorative-tooltip") : r(this, ni), e.parentNode || t.append(e);
    const s = r(this, oi).getImageForAltText();
    s == null || s.setAttribute("aria-describedby", e.id);
  }, bt(li, "_l10nPromise", null);
  let Lu = li;
  const Ot = class Ot {
    constructor(t) {
      v(this, Sh);
      v(this, Ph);
      v(this, uf);
      v(this, ff);
      v(this, Th);
      v(this, Ch);
      v(this, Rh);
      v(this, pf);
      v(this, gf);
      v(this, mf);
      v(this, vf);
      v(this, Ih);
      v(this, lr);
      v(this, os, null);
      v(this, xe, null);
      v(this, $a, !1);
      v(this, nr, !1);
      v(this, de, null);
      v(this, rr, null);
      v(this, Ua, this.focusin.bind(this));
      v(this, za, this.focusout.bind(this));
      v(this, ye, null);
      v(this, Ah, "");
      v(this, ar, !1);
      v(this, Qi, null);
      v(this, Eh, !1);
      v(this, or, !1);
      v(this, hi, !1);
      v(this, Is, null);
      v(this, Wa, 0);
      v(this, Ga, 0);
      v(this, Ye, null);
      bt(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
      bt(this, "_isVisible", !0);
      bt(this, "_uiManager", null);
      bt(this, "_focusEventsAllowed", !0);
      bt(this, "_l10nPromise", null);
      v(this, wh, !1);
      v(this, df, Ot._zIndex++);
      this.constructor === Ot && Q("Cannot initialize AnnotationEditor."), this.parent = t.parent, this.id = t.id, this.width = this.height = null, this.pageIndex = t.parent.pageIndex, this.name = t.name, this.div = null, this._uiManager = t.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = t.isCentered, this._structTreeParentId = null;
      const {
        rotation: e,
        rawDims: {
          pageWidth: s,
          pageHeight: a,
          pageX: o,
          pageY: h
        }
      } = this.parent.viewport;
      this.rotation = e, this.pageRotation = (360 + e - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [s, a], this.pageTranslation = [o, h];
      const [c, p] = this.parentDimensions;
      this.x = t.x / c, this.y = t.y / p, this.isAttachedToDOM = !1, this.deleted = !1;
    }
    static get _resizerKeyboardManager() {
      const t = Ot.prototype._resizeWithKeyboard, e = Hn.TRANSLATE_SMALL, s = Hn.TRANSLATE_BIG;
      return tt(this, "_resizerKeyboardManager", new Ll([[["ArrowLeft", "mac+ArrowLeft"], t, {
        args: [-e, 0]
      }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], t, {
        args: [-s, 0]
      }], [["ArrowRight", "mac+ArrowRight"], t, {
        args: [e, 0]
      }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], t, {
        args: [s, 0]
      }], [["ArrowUp", "mac+ArrowUp"], t, {
        args: [0, -e]
      }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], t, {
        args: [0, -s]
      }], [["ArrowDown", "mac+ArrowDown"], t, {
        args: [0, e]
      }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], t, {
        args: [0, s]
      }], [["Escape", "mac+Escape"], Ot.prototype._stopResizingWithKeyboard]]));
    }
    get editorType() {
      return Object.getPrototypeOf(this).constructor._type;
    }
    static get _defaultLineColor() {
      return tt(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
    }
    static deleteAnnotationElement(t) {
      const e = new y0({
        id: t.parent.getNextId(),
        parent: t.parent,
        uiManager: t._uiManager
      });
      e.annotationElementId = t.annotationElementId, e.deleted = !0, e._uiManager.addToAnnotationStorage(e);
    }
    static initialize(t, e, s) {
      if (Ot._l10nPromise || (Ot._l10nPromise = new Map(["pdfjs-editor-alt-text-button-label", "pdfjs-editor-alt-text-edit-button-label", "pdfjs-editor-alt-text-decorative-tooltip", "pdfjs-editor-resizer-label-topLeft", "pdfjs-editor-resizer-label-topMiddle", "pdfjs-editor-resizer-label-topRight", "pdfjs-editor-resizer-label-middleRight", "pdfjs-editor-resizer-label-bottomRight", "pdfjs-editor-resizer-label-bottomMiddle", "pdfjs-editor-resizer-label-bottomLeft", "pdfjs-editor-resizer-label-middleLeft"].map((o) => [o, t.get(o.replaceAll(/([A-Z])/g, (h) => `-${h.toLowerCase()}`))]))), s != null && s.strings)
        for (const o of s.strings)
          Ot._l10nPromise.set(o, t.get(o));
      if (Ot._borderLineWidth !== -1)
        return;
      const a = getComputedStyle(document.documentElement);
      Ot._borderLineWidth = parseFloat(a.getPropertyValue("--outline-width")) || 0;
    }
    static updateDefaultParams(t, e) {
    }
    static get defaultPropertiesToUpdate() {
      return [];
    }
    static isHandlingMimeForPasting(t) {
      return !1;
    }
    static paste(t, e) {
      Q("Not implemented");
    }
    get propertiesToUpdate() {
      return [];
    }
    get _isDraggable() {
      return r(this, wh);
    }
    set _isDraggable(t) {
      var e;
      x(this, wh, t), (e = this.div) == null || e.classList.toggle("draggable", t);
    }
    get isEnterHandled() {
      return !0;
    }
    center() {
      const [t, e] = this.pageDimensions;
      switch (this.parentRotation) {
        case 90:
          this.x -= this.height * e / (t * 2), this.y += this.width * t / (e * 2);
          break;
        case 180:
          this.x += this.width / 2, this.y += this.height / 2;
          break;
        case 270:
          this.x += this.height * e / (t * 2), this.y -= this.width * t / (e * 2);
          break;
        default:
          this.x -= this.width / 2, this.y -= this.height / 2;
          break;
      }
      this.fixAndSetPosition();
    }
    addCommands(t) {
      this._uiManager.addCommands(t);
    }
    get currentLayer() {
      return this._uiManager.currentLayer;
    }
    setInBackground() {
      this.div.style.zIndex = 0;
    }
    setInForeground() {
      this.div.style.zIndex = r(this, df);
    }
    setParent(t) {
      t !== null ? (this.pageIndex = t.pageIndex, this.pageDimensions = t.pageDimensions) : E(this, lr, md).call(this), this.parent = t;
    }
    focusin(t) {
      this._focusEventsAllowed && (r(this, ar) ? x(this, ar, !1) : this.parent.setSelected(this));
    }
    focusout(t) {
      var s;
      if (!this._focusEventsAllowed || !this.isAttachedToDOM)
        return;
      const e = t.relatedTarget;
      e != null && e.closest(`#${this.id}`) || (t.preventDefault(), (s = this.parent) != null && s.isMultipleSelection || this.commitOrRemove());
    }
    commitOrRemove() {
      this.isEmpty() ? this.remove() : this.commit();
    }
    commit() {
      this.addToAnnotationStorage();
    }
    addToAnnotationStorage() {
      this._uiManager.addToAnnotationStorage(this);
    }
    setAt(t, e, s, a) {
      const [o, h] = this.parentDimensions;
      [s, a] = this.screenToPageTranslation(s, a), this.x = (t + s) / o, this.y = (e + a) / h, this.fixAndSetPosition();
    }
    translate(t, e) {
      E(this, Sh, iv).call(this, this.parentDimensions, t, e);
    }
    translateInPage(t, e) {
      r(this, Qi) || x(this, Qi, [this.x, this.y]), E(this, Sh, iv).call(this, this.pageDimensions, t, e), this.div.scrollIntoView({
        block: "nearest"
      });
    }
    drag(t, e) {
      r(this, Qi) || x(this, Qi, [this.x, this.y]);
      const [s, a] = this.parentDimensions;
      if (this.x += t / s, this.y += e / a, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
        const {
          x: g,
          y: b
        } = this.div.getBoundingClientRect();
        this.parent.findNewParent(this, g, b) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
      }
      let {
        x: o,
        y: h
      } = this;
      const [c, p] = this.getBaseTranslation();
      o += c, h += p, this.div.style.left = `${(100 * o).toFixed(2)}%`, this.div.style.top = `${(100 * h).toFixed(2)}%`, this.div.scrollIntoView({
        block: "nearest"
      });
    }
    get _hasBeenMoved() {
      return !!r(this, Qi) && (r(this, Qi)[0] !== this.x || r(this, Qi)[1] !== this.y);
    }
    getBaseTranslation() {
      const [t, e] = this.parentDimensions, {
        _borderLineWidth: s
      } = Ot, a = s / t, o = s / e;
      switch (this.rotation) {
        case 90:
          return [-a, o];
        case 180:
          return [a, o];
        case 270:
          return [a, -o];
        default:
          return [-a, -o];
      }
    }
    get _mustFixPosition() {
      return !0;
    }
    fixAndSetPosition(t = this.rotation) {
      const [e, s] = this.pageDimensions;
      let {
        x: a,
        y: o,
        width: h,
        height: c
      } = this;
      if (h *= e, c *= s, a *= e, o *= s, this._mustFixPosition)
        switch (t) {
          case 0:
            a = Math.max(0, Math.min(e - h, a)), o = Math.max(0, Math.min(s - c, o));
            break;
          case 90:
            a = Math.max(0, Math.min(e - c, a)), o = Math.min(s, Math.max(h, o));
            break;
          case 180:
            a = Math.min(e, Math.max(h, a)), o = Math.min(s, Math.max(c, o));
            break;
          case 270:
            a = Math.min(e, Math.max(c, a)), o = Math.max(0, Math.min(s - h, o));
            break;
        }
      this.x = a /= e, this.y = o /= s;
      const [p, g] = this.getBaseTranslation();
      a += p, o += g;
      const {
        style: b
      } = this.div;
      b.left = `${(100 * a).toFixed(2)}%`, b.top = `${(100 * o).toFixed(2)}%`, this.moveInDOM();
    }
    screenToPageTranslation(t, e) {
      var s;
      return E(s = Ot, xh, nv).call(s, t, e, this.parentRotation);
    }
    pageTranslationToScreen(t, e) {
      var s;
      return E(s = Ot, xh, nv).call(s, t, e, 360 - this.parentRotation);
    }
    get parentScale() {
      return this._uiManager.viewParameters.realScale;
    }
    get parentRotation() {
      return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
    }
    get parentDimensions() {
      const {
        parentScale: t,
        pageDimensions: [e, s]
      } = this, a = e * t, o = s * t;
      return nt.isCSSRoundSupported ? [Math.round(a), Math.round(o)] : [a, o];
    }
    setDims(t, e) {
      const [s, a] = this.parentDimensions;
      this.div.style.width = `${(100 * t / s).toFixed(2)}%`, r(this, nr) || (this.div.style.height = `${(100 * e / a).toFixed(2)}%`);
    }
    fixDims() {
      const {
        style: t
      } = this.div, {
        height: e,
        width: s
      } = t, a = s.endsWith("%"), o = !r(this, nr) && e.endsWith("%");
      if (a && o)
        return;
      const [h, c] = this.parentDimensions;
      a || (t.width = `${(100 * parseFloat(s) / h).toFixed(2)}%`), !r(this, nr) && !o && (t.height = `${(100 * parseFloat(e) / c).toFixed(2)}%`);
    }
    getInitialTranslation() {
      return [0, 0];
    }
    altTextFinish() {
      var t;
      (t = r(this, xe)) == null || t.finish();
    }
    async addEditToolbar() {
      return r(this, ye) || r(this, or) ? r(this, ye) : (x(this, ye, new am(this)), this.div.append(r(this, ye).render()), r(this, xe) && r(this, ye).addAltTextButton(await r(this, xe).render()), r(this, ye));
    }
    removeEditToolbar() {
      var t;
      r(this, ye) && (r(this, ye).remove(), x(this, ye, null), (t = r(this, xe)) == null || t.destroy());
    }
    getClientDimensions() {
      return this.div.getBoundingClientRect();
    }
    async addAltTextButton() {
      r(this, xe) || (Lu.initialize(Ot._l10nPromise), x(this, xe, new Lu(this)), await this.addEditToolbar());
    }
    get altTextData() {
      var t;
      return (t = r(this, xe)) == null ? void 0 : t.data;
    }
    set altTextData(t) {
      r(this, xe) && (r(this, xe).data = t);
    }
    hasAltText() {
      var t;
      return !((t = r(this, xe)) != null && t.isEmpty());
    }
    render() {
      this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.tabIndex = r(this, $a) ? -1 : 0, this._isVisible || this.div.classList.add("hidden"), this.setInForeground(), this.div.addEventListener("focusin", r(this, Ua)), this.div.addEventListener("focusout", r(this, za));
      const [t, e] = this.parentDimensions;
      this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * e / t).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * t / e).toFixed(2)}%`);
      const [s, a] = this.getInitialTranslation();
      return this.translate(s, a), Iu(this, this.div, ["pointerdown"]), this.div;
    }
    pointerdown(t) {
      const {
        isMac: e
      } = nt.platform;
      if (t.button !== 0 || t.ctrlKey && e) {
        t.preventDefault();
        return;
      }
      if (x(this, ar, !0), this._isDraggable) {
        E(this, pf, gA).call(this, t);
        return;
      }
      E(this, Rh, lv).call(this, t);
    }
    moveInDOM() {
      r(this, Is) && clearTimeout(r(this, Is)), x(this, Is, setTimeout(() => {
        var t;
        x(this, Is, null), (t = this.parent) == null || t.moveEditorInDOM(this);
      }, 0));
    }
    _setParentAndPosition(t, e, s) {
      t.changeParent(this), this.x = e, this.y = s, this.fixAndSetPosition();
    }
    getRect(t, e, s = this.rotation) {
      const a = this.parentScale, [o, h] = this.pageDimensions, [c, p] = this.pageTranslation, g = t / a, b = e / a, S = this.x * o, T = this.y * h, C = this.width * o, R = this.height * h;
      switch (s) {
        case 0:
          return [S + g + c, h - T - b - R + p, S + g + C + c, h - T - b + p];
        case 90:
          return [S + b + c, h - T + g + p, S + b + R + c, h - T + g + C + p];
        case 180:
          return [S - g - C + c, h - T + b + p, S - g + c, h - T + b + R + p];
        case 270:
          return [S - b - R + c, h - T - g - C + p, S - b + c, h - T - g + p];
        default:
          throw new Error("Invalid rotation");
      }
    }
    getRectInCurrentCoords(t, e) {
      const [s, a, o, h] = t, c = o - s, p = h - a;
      switch (this.rotation) {
        case 0:
          return [s, e - h, c, p];
        case 90:
          return [s, e - a, p, c];
        case 180:
          return [o, e - a, c, p];
        case 270:
          return [o, e - h, p, c];
        default:
          throw new Error("Invalid rotation");
      }
    }
    onceAdded() {
    }
    isEmpty() {
      return !1;
    }
    enableEditMode() {
      x(this, or, !0);
    }
    disableEditMode() {
      x(this, or, !1);
    }
    isInEditMode() {
      return r(this, or);
    }
    shouldGetKeyboardEvents() {
      return r(this, hi);
    }
    needsToBeRebuilt() {
      return this.div && !this.isAttachedToDOM;
    }
    rebuild() {
      var t, e;
      (t = this.div) == null || t.addEventListener("focusin", r(this, Ua)), (e = this.div) == null || e.addEventListener("focusout", r(this, za));
    }
    rotate(t) {
    }
    serialize(t = !1, e = null) {
      Q("An editor must be serializable");
    }
    static deserialize(t, e, s) {
      const a = new this.prototype.constructor({
        parent: e,
        id: e.getNextId(),
        uiManager: s
      });
      a.rotation = t.rotation;
      const [o, h] = a.pageDimensions, [c, p, g, b] = a.getRectInCurrentCoords(t.rect, h);
      return a.x = c / o, a.y = p / h, a.width = g / o, a.height = b / h, a;
    }
    get hasBeenModified() {
      return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
    }
    remove() {
      if (this.div.removeEventListener("focusin", r(this, Ua)), this.div.removeEventListener("focusout", r(this, za)), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), r(this, Is) && (clearTimeout(r(this, Is)), x(this, Is, null)), E(this, lr, md).call(this), this.removeEditToolbar(), r(this, Ye)) {
        for (const t of r(this, Ye).values())
          clearTimeout(t);
        x(this, Ye, null);
      }
      this.parent = null;
    }
    get isResizable() {
      return !1;
    }
    makeResizable() {
      this.isResizable && (E(this, uf, fA).call(this), r(this, de).classList.remove("hidden"), Iu(this, this.div, ["keydown"]));
    }
    get toolbarPosition() {
      return null;
    }
    keydown(t) {
      if (!this.isResizable || t.target !== this.div || t.key !== "Enter")
        return;
      this._uiManager.setSelected(this), x(this, rr, {
        savedX: this.x,
        savedY: this.y,
        savedWidth: this.width,
        savedHeight: this.height
      });
      const e = r(this, de).children;
      if (!r(this, os)) {
        x(this, os, Array.from(e));
        const h = E(this, gf, mA).bind(this), c = E(this, mf, vA).bind(this);
        for (const p of r(this, os)) {
          const g = p.getAttribute("data-resizer-name");
          p.setAttribute("role", "spinbutton"), p.addEventListener("keydown", h), p.addEventListener("blur", c), p.addEventListener("focus", E(this, vf, bA).bind(this, g)), Ot._l10nPromise.get(`pdfjs-editor-resizer-label-${g}`).then((b) => p.setAttribute("aria-label", b));
        }
      }
      const s = r(this, os)[0];
      let a = 0;
      for (const h of e) {
        if (h === s)
          break;
        a++;
      }
      const o = (360 - this.rotation + this.parentRotation) % 360 / 90 * (r(this, os).length / 4);
      if (o !== a) {
        if (o < a)
          for (let c = 0; c < a - o; c++)
            r(this, de).append(r(this, de).firstChild);
        else if (o > a)
          for (let c = 0; c < o - a; c++)
            r(this, de).firstChild.before(r(this, de).lastChild);
        let h = 0;
        for (const c of e) {
          const g = r(this, os)[h++].getAttribute("data-resizer-name");
          Ot._l10nPromise.get(`pdfjs-editor-resizer-label-${g}`).then((b) => c.setAttribute("aria-label", b));
        }
      }
      E(this, Ih, hv).call(this, 0), x(this, hi, !0), r(this, de).firstChild.focus({
        focusVisible: !0
      }), t.preventDefault(), t.stopImmediatePropagation();
    }
    _resizeWithKeyboard(t, e) {
      r(this, hi) && E(this, Ch, ov).call(this, r(this, Ah), {
        movementX: t,
        movementY: e
      });
    }
    _stopResizingWithKeyboard() {
      E(this, lr, md).call(this), this.div.focus();
    }
    select() {
      var t, e;
      if (this.makeResizable(), (t = this.div) == null || t.classList.add("selectedEditor"), !r(this, ye)) {
        this.addEditToolbar().then(() => {
          var s, a;
          (s = this.div) != null && s.classList.contains("selectedEditor") && ((a = r(this, ye)) == null || a.show());
        });
        return;
      }
      (e = r(this, ye)) == null || e.show();
    }
    unselect() {
      var t, e, s, a;
      (t = r(this, de)) == null || t.classList.add("hidden"), (e = this.div) == null || e.classList.remove("selectedEditor"), (s = this.div) != null && s.contains(document.activeElement) && this._uiManager.currentLayer.div.focus({
        preventScroll: !0
      }), (a = r(this, ye)) == null || a.hide();
    }
    updateParams(t, e) {
    }
    disableEditing() {
    }
    enableEditing() {
    }
    enterInEditMode() {
    }
    getImageForAltText() {
      return null;
    }
    get contentDiv() {
      return this.div;
    }
    get isEditing() {
      return r(this, Eh);
    }
    set isEditing(t) {
      x(this, Eh, t), this.parent && (t ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
    }
    setAspectRatio(t, e) {
      x(this, nr, !0);
      const s = t / e, {
        style: a
      } = this.div;
      a.aspectRatio = s, a.height = "auto";
    }
    static get MIN_SIZE() {
      return 16;
    }
    static canCreateNewEmptyEditor() {
      return !0;
    }
    get telemetryInitialData() {
      return {
        action: "added"
      };
    }
    get telemetryFinalData() {
      return null;
    }
    _reportTelemetry(t, e = !1) {
      if (e) {
        r(this, Ye) || x(this, Ye, /* @__PURE__ */ new Map());
        const {
          action: s
        } = t;
        let a = r(this, Ye).get(s);
        a && clearTimeout(a), a = setTimeout(() => {
          this._reportTelemetry(t), r(this, Ye).delete(s), r(this, Ye).size === 0 && x(this, Ye, null);
        }, Ot._telemetryTimeout), r(this, Ye).set(s, a);
        return;
      }
      t.type || (t.type = this.editorType), this._uiManager._eventBus.dispatch("reporttelemetry", {
        source: this,
        details: {
          type: "editing",
          data: t
        }
      });
    }
    show(t = this._isVisible) {
      this.div.classList.toggle("hidden", !t), this._isVisible = t;
    }
    enable() {
      this.div && (this.div.tabIndex = 0), x(this, $a, !1);
    }
    disable() {
      this.div && (this.div.tabIndex = -1), x(this, $a, !0);
    }
    renderAnnotationElement(t) {
      let e = t.container.querySelector(".annotationContent");
      if (!e)
        e = document.createElement("div"), e.classList.add("annotationContent", this.editorType), t.container.prepend(e);
      else if (e.nodeName === "CANVAS") {
        const s = e;
        e = document.createElement("div"), e.classList.add("annotationContent", this.editorType), s.before(e);
      }
      return e;
    }
    resetAnnotationElement(t) {
      const {
        firstChild: e
      } = t.container;
      e.nodeName === "DIV" && e.classList.contains("annotationContent") && e.remove();
    }
  };
  os = new WeakMap(), xe = new WeakMap(), $a = new WeakMap(), nr = new WeakMap(), de = new WeakMap(), rr = new WeakMap(), Ua = new WeakMap(), za = new WeakMap(), ye = new WeakMap(), Ah = new WeakMap(), ar = new WeakMap(), Qi = new WeakMap(), Eh = new WeakMap(), or = new WeakMap(), hi = new WeakMap(), Is = new WeakMap(), Wa = new WeakMap(), Ga = new WeakMap(), Ye = new WeakMap(), wh = new WeakMap(), df = new WeakMap(), Sh = new WeakSet(), iv = function([t, e], s, a) {
    [s, a] = this.screenToPageTranslation(s, a), this.x += s / t, this.y += a / e, this.fixAndSetPosition();
  }, xh = new WeakSet(), nv = function(t, e, s) {
    switch (s) {
      case 90:
        return [e, -t];
      case 180:
        return [-t, -e];
      case 270:
        return [-e, t];
      default:
        return [t, e];
    }
  }, Ph = new WeakSet(), rv = function(t) {
    switch (t) {
      case 90: {
        const [e, s] = this.pageDimensions;
        return [0, -e / s, s / e, 0];
      }
      case 180:
        return [-1, 0, 0, -1];
      case 270: {
        const [e, s] = this.pageDimensions;
        return [0, e / s, -s / e, 0];
      }
      default:
        return [1, 0, 0, 1];
    }
  }, uf = new WeakSet(), fA = function() {
    if (r(this, de))
      return;
    x(this, de, document.createElement("div")), r(this, de).classList.add("resizers");
    const t = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"];
    for (const e of t) {
      const s = document.createElement("div");
      r(this, de).append(s), s.classList.add("resizer", e), s.setAttribute("data-resizer-name", e), s.addEventListener("pointerdown", E(this, ff, pA).bind(this, e)), s.addEventListener("contextmenu", Le), s.tabIndex = -1;
    }
    this.div.prepend(r(this, de));
  }, ff = new WeakSet(), pA = function(t, e) {
    var R;
    e.preventDefault();
    const {
      isMac: s
    } = nt.platform;
    if (e.button !== 0 || e.ctrlKey && s)
      return;
    (R = r(this, xe)) == null || R.toggle(!1);
    const a = E(this, Ch, ov).bind(this, t), o = this._isDraggable;
    this._isDraggable = !1;
    const h = {
      passive: !0,
      capture: !0
    };
    this.parent.togglePointerEvents(!1), window.addEventListener("pointermove", a, h), window.addEventListener("contextmenu", Le);
    const c = this.x, p = this.y, g = this.width, b = this.height, S = this.parent.div.style.cursor, T = this.div.style.cursor;
    this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(e.target).cursor;
    const C = () => {
      var M;
      this.parent.togglePointerEvents(!0), (M = r(this, xe)) == null || M.toggle(!0), this._isDraggable = o, window.removeEventListener("pointerup", C), window.removeEventListener("blur", C), window.removeEventListener("pointermove", a, h), window.removeEventListener("contextmenu", Le), this.parent.div.style.cursor = S, this.div.style.cursor = T, E(this, Th, av).call(this, c, p, g, b);
    };
    window.addEventListener("pointerup", C), window.addEventListener("blur", C);
  }, Th = new WeakSet(), av = function(t, e, s, a) {
    const o = this.x, h = this.y, c = this.width, p = this.height;
    o === t && h === e && c === s && p === a || this.addCommands({
      cmd: () => {
        this.width = c, this.height = p, this.x = o, this.y = h;
        const [g, b] = this.parentDimensions;
        this.setDims(g * c, b * p), this.fixAndSetPosition();
      },
      undo: () => {
        this.width = s, this.height = a, this.x = t, this.y = e;
        const [g, b] = this.parentDimensions;
        this.setDims(g * s, b * a), this.fixAndSetPosition();
      },
      mustExec: !0
    });
  }, Ch = new WeakSet(), ov = function(t, e) {
    const [s, a] = this.parentDimensions, o = this.x, h = this.y, c = this.width, p = this.height, g = Ot.MIN_SIZE / s, b = Ot.MIN_SIZE / a, S = (mt) => Math.round(mt * 1e4) / 1e4, T = E(this, Ph, rv).call(this, this.rotation), C = (mt, At) => [T[0] * mt + T[2] * At, T[1] * mt + T[3] * At], R = E(this, Ph, rv).call(this, 360 - this.rotation), M = (mt, At) => [R[0] * mt + R[2] * At, R[1] * mt + R[3] * At];
    let F, O, U = !1, Y = !1;
    switch (t) {
      case "topLeft":
        U = !0, F = (mt, At) => [0, 0], O = (mt, At) => [mt, At];
        break;
      case "topMiddle":
        F = (mt, At) => [mt / 2, 0], O = (mt, At) => [mt / 2, At];
        break;
      case "topRight":
        U = !0, F = (mt, At) => [mt, 0], O = (mt, At) => [0, At];
        break;
      case "middleRight":
        Y = !0, F = (mt, At) => [mt, At / 2], O = (mt, At) => [0, At / 2];
        break;
      case "bottomRight":
        U = !0, F = (mt, At) => [mt, At], O = (mt, At) => [0, 0];
        break;
      case "bottomMiddle":
        F = (mt, At) => [mt / 2, At], O = (mt, At) => [mt / 2, 0];
        break;
      case "bottomLeft":
        U = !0, F = (mt, At) => [0, At], O = (mt, At) => [mt, 0];
        break;
      case "middleLeft":
        Y = !0, F = (mt, At) => [0, At / 2], O = (mt, At) => [mt, At / 2];
        break;
    }
    const J = F(c, p), rt = O(c, p);
    let st = C(...rt);
    const ot = S(o + st[0]), ft = S(h + st[1]);
    let yt = 1, St = 1, [gt, Wt] = this.screenToPageTranslation(e.movementX, e.movementY);
    if ([gt, Wt] = M(gt / s, Wt / a), U) {
      const mt = Math.hypot(c, p);
      yt = St = Math.max(Math.min(Math.hypot(rt[0] - J[0] - gt, rt[1] - J[1] - Wt) / mt, 1 / c, 1 / p), g / c, b / p);
    } else
      Y ? yt = Math.max(g, Math.min(1, Math.abs(rt[0] - J[0] - gt))) / c : St = Math.max(b, Math.min(1, Math.abs(rt[1] - J[1] - Wt))) / p;
    const Dt = S(c * yt), $t = S(p * St);
    st = C(...O(Dt, $t));
    const Ut = ot - st[0], Ce = ft - st[1];
    this.width = Dt, this.height = $t, this.x = Ut, this.y = Ce, this.setDims(s * Dt, a * $t), this.fixAndSetPosition();
  }, Rh = new WeakSet(), lv = function(t) {
    const {
      isMac: e
    } = nt.platform;
    t.ctrlKey && !e || t.shiftKey || t.metaKey && e ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
  }, pf = new WeakSet(), gA = function(t) {
    const e = this._uiManager.isSelected(this);
    this._uiManager.setUpDragSession();
    let s, a;
    e && (this.div.classList.add("moving"), s = {
      passive: !0,
      capture: !0
    }, x(this, Wa, t.clientX), x(this, Ga, t.clientY), a = (h) => {
      const {
        clientX: c,
        clientY: p
      } = h, [g, b] = this.screenToPageTranslation(c - r(this, Wa), p - r(this, Ga));
      x(this, Wa, c), x(this, Ga, p), this._uiManager.dragSelectedEditors(g, b);
    }, window.addEventListener("pointermove", a, s));
    const o = () => {
      window.removeEventListener("pointerup", o), window.removeEventListener("blur", o), e && (this.div.classList.remove("moving"), window.removeEventListener("pointermove", a, s)), x(this, ar, !1), this._uiManager.endDragSession() || E(this, Rh, lv).call(this, t);
    };
    window.addEventListener("pointerup", o), window.addEventListener("blur", o);
  }, gf = new WeakSet(), mA = function(t) {
    Ot._resizerKeyboardManager.exec(this, t);
  }, mf = new WeakSet(), vA = function(t) {
    var e;
    r(this, hi) && ((e = t.relatedTarget) == null ? void 0 : e.parentNode) !== r(this, de) && E(this, lr, md).call(this);
  }, vf = new WeakSet(), bA = function(t) {
    x(this, Ah, r(this, hi) ? t : "");
  }, Ih = new WeakSet(), hv = function(t) {
    if (r(this, os))
      for (const e of r(this, os))
        e.tabIndex = t;
  }, lr = new WeakSet(), md = function() {
    if (x(this, hi, !1), E(this, Ih, hv).call(this, -1), r(this, rr)) {
      const {
        savedX: t,
        savedY: e,
        savedWidth: s,
        savedHeight: a
      } = r(this, rr);
      E(this, Th, av).call(this, t, e, s, a), x(this, rr, null);
    }
  }, v(Ot, xh), bt(Ot, "_borderLineWidth", -1), bt(Ot, "_colorManager", new lm()), bt(Ot, "_zIndex", 1), bt(Ot, "_telemetryTimeout", 1e3);
  let Rt = Ot;
  class y0 extends Rt {
    constructor(t) {
      super(t), this.annotationElementId = t.annotationElementId, this.deleted = !0;
    }
    serialize() {
      return {
        id: this.annotationElementId,
        deleted: !0,
        pageIndex: this.pageIndex
      };
    }
  }
  const Cb = 3285377520, Xe = 4294901760, As = 65535;
  class Rb {
    constructor(t) {
      this.h1 = t ? t & 4294967295 : Cb, this.h2 = t ? t & 4294967295 : Cb;
    }
    update(t) {
      let e, s;
      if (typeof t == "string") {
        e = new Uint8Array(t.length * 2), s = 0;
        for (let M = 0, F = t.length; M < F; M++) {
          const O = t.charCodeAt(M);
          O <= 255 ? e[s++] = O : (e[s++] = O >>> 8, e[s++] = O & 255);
        }
      } else if (ArrayBuffer.isView(t))
        e = t.slice(), s = e.byteLength;
      else
        throw new Error("Invalid data format, must be a string or TypedArray.");
      const a = s >> 2, o = s - a * 4, h = new Uint32Array(e.buffer, 0, a);
      let c = 0, p = 0, g = this.h1, b = this.h2;
      const S = 3432918353, T = 461845907, C = S & As, R = T & As;
      for (let M = 0; M < a; M++)
        M & 1 ? (c = h[M], c = c * S & Xe | c * C & As, c = c << 15 | c >>> 17, c = c * T & Xe | c * R & As, g ^= c, g = g << 13 | g >>> 19, g = g * 5 + 3864292196) : (p = h[M], p = p * S & Xe | p * C & As, p = p << 15 | p >>> 17, p = p * T & Xe | p * R & As, b ^= p, b = b << 13 | b >>> 19, b = b * 5 + 3864292196);
      switch (c = 0, o) {
        case 3:
          c ^= e[a * 4 + 2] << 16;
        case 2:
          c ^= e[a * 4 + 1] << 8;
        case 1:
          c ^= e[a * 4], c = c * S & Xe | c * C & As, c = c << 15 | c >>> 17, c = c * T & Xe | c * R & As, a & 1 ? g ^= c : b ^= c;
      }
      this.h1 = g, this.h2 = b;
    }
    hexdigest() {
      let t = this.h1, e = this.h2;
      return t ^= e >>> 1, t = t * 3981806797 & Xe | t * 36045 & As, e = e * 4283543511 & Xe | ((e << 16 | t >>> 16) * 2950163797 & Xe) >>> 16, t ^= e >>> 1, t = t * 444984403 & Xe | t * 60499 & As, e = e * 3301882366 & Xe | ((e << 16 | t >>> 16) * 3120437893 & Xe) >>> 16, t ^= e >>> 1, (t >>> 0).toString(16).padStart(8, "0") + (e >>> 0).toString(16).padStart(8, "0");
    }
  }
  const hm = Object.freeze({
    map: null,
    hash: "",
    transfer: void 0
  });
  class cm {
    constructor() {
      v(this, bf);
      v(this, hr, !1);
      v(this, ue, /* @__PURE__ */ new Map());
      this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
    }
    getValue(t, e) {
      const s = r(this, ue).get(t);
      return s === void 0 ? e : Object.assign(e, s);
    }
    getRawValue(t) {
      return r(this, ue).get(t);
    }
    remove(t) {
      if (r(this, ue).delete(t), r(this, ue).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
        for (const e of r(this, ue).values())
          if (e instanceof Rt)
            return;
        this.onAnnotationEditor(null);
      }
    }
    setValue(t, e) {
      const s = r(this, ue).get(t);
      let a = !1;
      if (s !== void 0)
        for (const [o, h] of Object.entries(e))
          s[o] !== h && (a = !0, s[o] = h);
      else
        a = !0, r(this, ue).set(t, e);
      a && E(this, bf, yA).call(this), e instanceof Rt && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(e.constructor._type);
    }
    has(t) {
      return r(this, ue).has(t);
    }
    getAll() {
      return r(this, ue).size > 0 ? Bn(r(this, ue)) : null;
    }
    setAll(t) {
      for (const [e, s] of Object.entries(t))
        this.setValue(e, s);
    }
    get size() {
      return r(this, ue).size;
    }
    resetModified() {
      r(this, hr) && (x(this, hr, !1), typeof this.onResetModified == "function" && this.onResetModified());
    }
    get print() {
      return new Ib(this);
    }
    get serializable() {
      if (r(this, ue).size === 0)
        return hm;
      const t = /* @__PURE__ */ new Map(), e = new Rb(), s = [], a = /* @__PURE__ */ Object.create(null);
      let o = !1;
      for (const [h, c] of r(this, ue)) {
        const p = c instanceof Rt ? c.serialize(!1, a) : c;
        p && (t.set(h, p), e.update(`${h}:${JSON.stringify(p)}`), o || (o = !!p.bitmap));
      }
      if (o)
        for (const h of t.values())
          h.bitmap && s.push(h.bitmap);
      return t.size > 0 ? {
        map: t,
        hash: e.hexdigest(),
        transfer: s
      } : hm;
    }
    get editorStats() {
      let t = null;
      const e = /* @__PURE__ */ new Map();
      for (const s of r(this, ue).values()) {
        if (!(s instanceof Rt))
          continue;
        const a = s.telemetryFinalData;
        if (!a)
          continue;
        const {
          type: o
        } = a;
        e.has(o) || e.set(o, Object.getPrototypeOf(s).constructor), t || (t = /* @__PURE__ */ Object.create(null));
        const h = t[o] || (t[o] = /* @__PURE__ */ new Map());
        for (const [c, p] of Object.entries(a)) {
          if (c === "type")
            continue;
          let g = h.get(c);
          g || (g = /* @__PURE__ */ new Map(), h.set(c, g));
          const b = g.get(p) ?? 0;
          g.set(p, b + 1);
        }
      }
      for (const [s, a] of e)
        t[s] = a.computeTelemetryFinalData(t[s]);
      return t;
    }
  }
  hr = new WeakMap(), ue = new WeakMap(), bf = new WeakSet(), yA = function() {
    r(this, hr) || (x(this, hr, !0), typeof this.onSetModified == "function" && this.onSetModified());
  };
  class Ib extends cm {
    constructor(e) {
      super();
      v(this, Lh, void 0);
      const {
        map: s,
        hash: a,
        transfer: o
      } = e.serializable, h = structuredClone(s, o ? {
        transfer: o
      } : null);
      x(this, Lh, {
        map: h,
        hash: a,
        transfer: o
      });
    }
    get print() {
      Q("Should not call PrintAnnotationStorage.print");
    }
    get serializable() {
      return r(this, Lh);
    }
  }
  Lh = new WeakMap();
  class A0 {
    constructor({
      ownerDocument: t = globalThis.document,
      styleElement: e = null
    }) {
      v(this, Xa, /* @__PURE__ */ new Set());
      this._document = t, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
    }
    addNativeFontFace(t) {
      this.nativeFontFaces.add(t), this._document.fonts.add(t);
    }
    removeNativeFontFace(t) {
      this.nativeFontFaces.delete(t), this._document.fonts.delete(t);
    }
    insertRule(t) {
      this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
      const e = this.styleElement.sheet;
      e.insertRule(t, e.cssRules.length);
    }
    clear() {
      for (const t of this.nativeFontFaces)
        this._document.fonts.delete(t);
      this.nativeFontFaces.clear(), r(this, Xa).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
    }
    async loadSystemFont({
      systemFontInfo: t,
      _inspectFont: e
    }) {
      if (!(!t || r(this, Xa).has(t.loadedName))) {
        if (B(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
          const {
            loadedName: s,
            src: a,
            style: o
          } = t, h = new FontFace(s, a, o);
          this.addNativeFontFace(h);
          try {
            await h.load(), r(this, Xa).add(s), e == null || e(t);
          } catch {
            j(`Cannot load system font: ${t.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(h);
          }
          return;
        }
        Q("Not implemented: loadSystemFont without the Font Loading API.");
      }
    }
    async bind(t) {
      if (t.attached || t.missingFile && !t.systemFontInfo)
        return;
      if (t.attached = !0, t.systemFontInfo) {
        await this.loadSystemFont(t);
        return;
      }
      if (this.isFontLoadingAPISupported) {
        const s = t.createNativeFontFace();
        if (s) {
          this.addNativeFontFace(s);
          try {
            await s.loaded;
          } catch (a) {
            throw j(`Failed to load font '${s.family}': '${a}'.`), t.disableFontFace = !0, a;
          }
        }
        return;
      }
      const e = t.createFontFaceRule();
      if (e) {
        if (this.insertRule(e), this.isSyncFontLoadingSupported)
          return;
        await new Promise((s) => {
          const a = this._queueLoadingCallback(s);
          this._prepareFontLoadEvent(t, a);
        });
      }
    }
    get isFontLoadingAPISupported() {
      var e;
      const t = !!((e = this._document) != null && e.fonts);
      return tt(this, "isFontLoadingAPISupported", t);
    }
    get isSyncFontLoadingSupported() {
      let t = !1;
      return (u || typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.userAgent) == "string" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (t = !0), tt(this, "isSyncFontLoadingSupported", t);
    }
    _queueLoadingCallback(t) {
      function e() {
        for (B(!a.done, "completeRequest() cannot be called twice."), a.done = !0; s.length > 0 && s[0].done; ) {
          const o = s.shift();
          setTimeout(o.callback, 0);
        }
      }
      const {
        loadingRequests: s
      } = this, a = {
        done: !1,
        complete: e,
        callback: t
      };
      return s.push(a), a;
    }
    get _loadTestFont() {
      const t = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
      return tt(this, "_loadTestFont", t);
    }
    _prepareFontLoadEvent(t, e) {
      function s(J, rt) {
        return J.charCodeAt(rt) << 24 | J.charCodeAt(rt + 1) << 16 | J.charCodeAt(rt + 2) << 8 | J.charCodeAt(rt + 3) & 255;
      }
      function a(J, rt, st, ot) {
        const ft = J.substring(0, rt), yt = J.substring(rt + st);
        return ft + ot + yt;
      }
      let o, h;
      const c = this._document.createElement("canvas");
      c.width = 1, c.height = 1;
      const p = c.getContext("2d");
      let g = 0;
      function b(J, rt) {
        if (++g > 30) {
          j("Load test font never loaded."), rt();
          return;
        }
        if (p.font = "30px " + J, p.fillText(".", 0, 20), p.getImageData(0, 0, 1, 1).data[3] > 0) {
          rt();
          return;
        }
        setTimeout(b.bind(null, J, rt));
      }
      const S = `lt${Date.now()}${this.loadTestFontId++}`;
      let T = this._loadTestFont;
      T = a(T, 976, S.length, S);
      const R = 16, M = 1482184792;
      let F = s(T, R);
      for (o = 0, h = S.length - 3; o < h; o += 4)
        F = F - M + s(S, o) | 0;
      o < S.length && (F = F - M + s(S + "XXX", o) | 0), T = a(T, R, 4, Gs(F));
      const O = `url(data:font/opentype;base64,${btoa(T)});`, U = `@font-face {font-family:"${S}";src:${O}}`;
      this.insertRule(U);
      const Y = this._document.createElement("div");
      Y.style.visibility = "hidden", Y.style.width = Y.style.height = "10px", Y.style.position = "absolute", Y.style.top = Y.style.left = "0px";
      for (const J of [t.loadedName, S]) {
        const rt = this._document.createElement("span");
        rt.textContent = "Hi", rt.style.fontFamily = J, Y.append(rt);
      }
      this._document.body.append(Y), b(S, () => {
        Y.remove(), e.complete();
      });
    }
  }
  Xa = new WeakMap();
  class E0 {
    constructor(t, {
      disableFontFace: e = !1,
      inspectFont: s = null
    }) {
      this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
      for (const a in t)
        this[a] = t[a];
      this.disableFontFace = e === !0, this._inspectFont = s;
    }
    createNativeFontFace() {
      var e;
      if (!this.data || this.disableFontFace)
        return null;
      let t;
      if (!this.cssFontInfo)
        t = new FontFace(this.loadedName, this.data, {});
      else {
        const s = {
          weight: this.cssFontInfo.fontWeight
        };
        this.cssFontInfo.italicAngle && (s.style = `oblique ${this.cssFontInfo.italicAngle}deg`), t = new FontFace(this.cssFontInfo.fontFamily, this.data, s);
      }
      return (e = this._inspectFont) == null || e.call(this, this), t;
    }
    createFontFaceRule() {
      var a;
      if (!this.data || this.disableFontFace)
        return null;
      const t = We(this.data), e = `url(data:${this.mimetype};base64,${btoa(t)});`;
      let s;
      if (!this.cssFontInfo)
        s = `@font-face {font-family:"${this.loadedName}";src:${e}}`;
      else {
        let o = `font-weight: ${this.cssFontInfo.fontWeight};`;
        this.cssFontInfo.italicAngle && (o += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), s = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${o}src:${e}}`;
      }
      return (a = this._inspectFont) == null || a.call(this, this, e), s;
    }
    getPathGenerator(t, e) {
      if (this.compiledGlyphs[e] !== void 0)
        return this.compiledGlyphs[e];
      let s;
      try {
        s = t.get(this.loadedName + "_path_" + e);
      } catch (o) {
        j(`getPathGenerator - ignoring character: "${o}".`);
      }
      if (!Array.isArray(s) || s.length === 0)
        return this.compiledGlyphs[e] = function(o, h) {
        };
      const a = [];
      for (let o = 0, h = s.length; o < h; )
        switch (s[o++]) {
          case Lt.BEZIER_CURVE_TO:
            {
              const [c, p, g, b, S, T] = s.slice(o, o + 6);
              a.push((C) => C.bezierCurveTo(c, p, g, b, S, T)), o += 6;
            }
            break;
          case Lt.MOVE_TO:
            {
              const [c, p] = s.slice(o, o + 2);
              a.push((g) => g.moveTo(c, p)), o += 2;
            }
            break;
          case Lt.LINE_TO:
            {
              const [c, p] = s.slice(o, o + 2);
              a.push((g) => g.lineTo(c, p)), o += 2;
            }
            break;
          case Lt.QUADRATIC_CURVE_TO:
            {
              const [c, p, g, b] = s.slice(o, o + 4);
              a.push((S) => S.quadraticCurveTo(c, p, g, b)), o += 4;
            }
            break;
          case Lt.RESTORE:
            a.push((c) => c.restore());
            break;
          case Lt.SAVE:
            a.push((c) => c.save());
            break;
          case Lt.SCALE:
            B(a.length === 2, "Scale command is only valid at the third position.");
            break;
          case Lt.TRANSFORM:
            {
              const [c, p, g, b, S, T] = s.slice(o, o + 6);
              a.push((C) => C.transform(c, p, g, b, S, T)), o += 6;
            }
            break;
          case Lt.TRANSLATE:
            {
              const [c, p] = s.slice(o, o + 2);
              a.push((g) => g.translate(c, p)), o += 2;
            }
            break;
        }
      return this.compiledGlyphs[e] = function(h, c) {
        a[0](h), a[1](h), h.scale(c, -c);
        for (let p = 2, g = a.length; p < g; p++)
          a[p](h);
      };
    }
  }
  if (u) {
    var dm = Promise.withResolvers(), _l = null;
    (async () => {
      const t = await Promise.resolve().then(() => cd), e = await Promise.resolve().then(() => cd), s = await Promise.resolve().then(() => cd), a = await Promise.resolve().then(() => cd);
      let o, h;
      try {
        o = await Promise.resolve().then(() => cd);
      } catch {
      }
      try {
        h = await Promise.resolve().then(() => NP);
      } catch {
      }
      return new Map(Object.entries({
        fs: t,
        http: e,
        https: s,
        url: a,
        canvas: o,
        path2d: h
      }));
    })().then((t) => {
      var e, s, a, o;
      if (_l = t, dm.resolve(), !globalThis.DOMMatrix) {
        const h = (e = t.get("canvas")) == null ? void 0 : e.DOMMatrix;
        h ? globalThis.DOMMatrix = h : j("Cannot polyfill `DOMMatrix`, rendering may be broken.");
      }
      if (!globalThis.Path2D) {
        const h = (s = t.get("canvas")) == null ? void 0 : s.CanvasRenderingContext2D, c = (a = t.get("path2d")) == null ? void 0 : a.applyPath2DToCanvasRenderingContext, p = (o = t.get("path2d")) == null ? void 0 : o.Path2D;
        h && c && p ? (c(h), globalThis.Path2D = p) : j("Cannot polyfill `Path2D`, rendering may be broken.");
      }
    }, (t) => {
      j(`loadPackages: ${t}`), _l = /* @__PURE__ */ new Map(), dm.resolve();
    });
  }
  class Es {
    static get promise() {
      return dm.promise;
    }
    static get(t) {
      return _l == null ? void 0 : _l.get(t);
    }
  }
  const Lb = function(A) {
    return Es.get("fs").promises.readFile(A).then((e) => new Uint8Array(e));
  };
  class w0 extends is {
  }
  class S0 extends Hi {
    _createCanvas(t, e) {
      return Es.get("canvas").createCanvas(t, e);
    }
  }
  class x0 extends Xs {
    _fetchData(t, e) {
      return Lb(t).then((s) => ({
        cMapData: s,
        compressionType: e
      }));
    }
  }
  class P0 extends Cu {
    _fetchData(t) {
      return Lb(t);
    }
  }
  const Se = {
    FILL: "Fill",
    STROKE: "Stroke",
    SHADING: "Shading"
  };
  function um(A, t) {
    if (!t)
      return;
    const e = t[2] - t[0], s = t[3] - t[1], a = new Path2D();
    a.rect(t[0], t[1], e, s), A.clip(a);
  }
  class Ml {
    constructor() {
      this.constructor === Ml && Q("Cannot initialize BaseShadingPattern.");
    }
    getPattern() {
      Q("Abstract method `getPattern` called.");
    }
  }
  class T0 extends Ml {
    constructor(t) {
      super(), this._type = t[1], this._bbox = t[2], this._colorStops = t[3], this._p0 = t[4], this._p1 = t[5], this._r0 = t[6], this._r1 = t[7], this.matrix = null;
    }
    _createGradient(t) {
      let e;
      this._type === "axial" ? e = t.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (e = t.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
      for (const s of this._colorStops)
        e.addColorStop(s[0], s[1]);
      return e;
    }
    getPattern(t, e, s, a) {
      let o;
      if (a === Se.STROKE || a === Se.FILL) {
        const h = e.current.getClippedPathBoundingBox(a, zt(t)) || [0, 0, 0, 0], c = Math.ceil(h[2] - h[0]) || 1, p = Math.ceil(h[3] - h[1]) || 1, g = e.cachedCanvases.getCanvas("pattern", c, p, !0), b = g.context;
        b.clearRect(0, 0, b.canvas.width, b.canvas.height), b.beginPath(), b.rect(0, 0, b.canvas.width, b.canvas.height), b.translate(-h[0], -h[1]), s = et.transform(s, [1, 0, 0, 1, h[0], h[1]]), b.transform(...e.baseTransform), this.matrix && b.transform(...this.matrix), um(b, this._bbox), b.fillStyle = this._createGradient(b), b.fill(), o = t.createPattern(g.canvas, "no-repeat");
        const S = new DOMMatrix(s);
        o.setTransform(S);
      } else
        um(t, this._bbox), o = this._createGradient(t);
      return o;
    }
  }
  function fm(A, t, e, s, a, o, h, c) {
    const p = t.coords, g = t.colors, b = A.data, S = A.width * 4;
    let T;
    p[e + 1] > p[s + 1] && (T = e, e = s, s = T, T = o, o = h, h = T), p[s + 1] > p[a + 1] && (T = s, s = a, a = T, T = h, h = c, c = T), p[e + 1] > p[s + 1] && (T = e, e = s, s = T, T = o, o = h, h = T);
    const C = (p[e] + t.offsetX) * t.scaleX, R = (p[e + 1] + t.offsetY) * t.scaleY, M = (p[s] + t.offsetX) * t.scaleX, F = (p[s + 1] + t.offsetY) * t.scaleY, O = (p[a] + t.offsetX) * t.scaleX, U = (p[a + 1] + t.offsetY) * t.scaleY;
    if (R >= U)
      return;
    const Y = g[o], J = g[o + 1], rt = g[o + 2], st = g[h], ot = g[h + 1], ft = g[h + 2], yt = g[c], St = g[c + 1], gt = g[c + 2], Wt = Math.round(R), Dt = Math.round(U);
    let $t, Ut, Ce, mt, At, Sp, xp, Ko;
    for (let ze = Wt; ze <= Dt; ze++) {
      if (ze < F) {
        const Nt = ze < R ? 0 : (R - ze) / (R - F);
        $t = C - (C - M) * Nt, Ut = Y - (Y - st) * Nt, Ce = J - (J - ot) * Nt, mt = rt - (rt - ft) * Nt;
      } else {
        let Nt;
        ze > U ? Nt = 1 : F === U ? Nt = 0 : Nt = (F - ze) / (F - U), $t = M - (M - O) * Nt, Ut = st - (st - yt) * Nt, Ce = ot - (ot - St) * Nt, mt = ft - (ft - gt) * Nt;
      }
      let me;
      ze < R ? me = 0 : ze > U ? me = 1 : me = (R - ze) / (R - U), At = C - (C - O) * me, Sp = Y - (Y - yt) * me, xp = J - (J - St) * me, Ko = rt - (rt - gt) * me;
      const mn = Math.round(Math.min($t, At)), ad = Math.round(Math.max($t, At));
      let Jr = S * ze + mn * 4;
      for (let Nt = mn; Nt <= ad; Nt++)
        me = ($t - Nt) / ($t - At), me < 0 ? me = 0 : me > 1 && (me = 1), b[Jr++] = Ut - (Ut - Sp) * me | 0, b[Jr++] = Ce - (Ce - xp) * me | 0, b[Jr++] = mt - (mt - Ko) * me | 0, b[Jr++] = 255;
    }
  }
  function C0(A, t, e) {
    const s = t.coords, a = t.colors;
    let o, h;
    switch (t.type) {
      case "lattice":
        const c = t.verticesPerRow, p = Math.floor(s.length / c) - 1, g = c - 1;
        for (o = 0; o < p; o++) {
          let b = o * c;
          for (let S = 0; S < g; S++, b++)
            fm(A, e, s[b], s[b + 1], s[b + c], a[b], a[b + 1], a[b + c]), fm(A, e, s[b + c + 1], s[b + 1], s[b + c], a[b + c + 1], a[b + 1], a[b + c]);
        }
        break;
      case "triangles":
        for (o = 0, h = s.length; o < h; o += 3)
          fm(A, e, s[o], s[o + 1], s[o + 2], a[o], a[o + 1], a[o + 2]);
        break;
      default:
        throw new Error("illegal figure");
    }
  }
  class R0 extends Ml {
    constructor(t) {
      super(), this._coords = t[2], this._colors = t[3], this._figures = t[4], this._bounds = t[5], this._bbox = t[7], this._background = t[8], this.matrix = null;
    }
    _createMeshCanvas(t, e, s) {
      const c = Math.floor(this._bounds[0]), p = Math.floor(this._bounds[1]), g = Math.ceil(this._bounds[2]) - c, b = Math.ceil(this._bounds[3]) - p, S = Math.min(Math.ceil(Math.abs(g * t[0] * 1.1)), 3e3), T = Math.min(Math.ceil(Math.abs(b * t[1] * 1.1)), 3e3), C = g / S, R = b / T, M = {
        coords: this._coords,
        colors: this._colors,
        offsetX: -c,
        offsetY: -p,
        scaleX: 1 / C,
        scaleY: 1 / R
      }, F = S + 2 * 2, O = T + 2 * 2, U = s.getCanvas("mesh", F, O, !1), Y = U.context, J = Y.createImageData(S, T);
      if (e) {
        const st = J.data;
        for (let ot = 0, ft = st.length; ot < ft; ot += 4)
          st[ot] = e[0], st[ot + 1] = e[1], st[ot + 2] = e[2], st[ot + 3] = 255;
      }
      for (const st of this._figures)
        C0(J, st, M);
      return Y.putImageData(J, 2, 2), {
        canvas: U.canvas,
        offsetX: c - 2 * C,
        offsetY: p - 2 * R,
        scaleX: C,
        scaleY: R
      };
    }
    getPattern(t, e, s, a) {
      um(t, this._bbox);
      let o;
      if (a === Se.SHADING)
        o = et.singularValueDecompose2dScale(zt(t));
      else if (o = et.singularValueDecompose2dScale(e.baseTransform), this.matrix) {
        const c = et.singularValueDecompose2dScale(this.matrix);
        o = [o[0] * c[0], o[1] * c[1]];
      }
      const h = this._createMeshCanvas(o, a === Se.SHADING ? null : this._background, e.cachedCanvases);
      return a !== Se.SHADING && (t.setTransform(...e.baseTransform), this.matrix && t.transform(...this.matrix)), t.translate(h.offsetX, h.offsetY), t.scale(h.scaleX, h.scaleY), t.createPattern(h.canvas, "no-repeat");
    }
  }
  class I0 extends Ml {
    getPattern() {
      return "hotpink";
    }
  }
  function L0(A) {
    switch (A[0]) {
      case "RadialAxial":
        return new T0(A);
      case "Mesh":
        return new R0(A);
      case "Dummy":
        return new I0();
    }
    throw new Error(`Unknown IR type: ${A[0]}`);
  }
  const _b = {
    COLORED: 1,
    UNCOLORED: 2
  }, yf = class yf {
    constructor(t, e, s, a, o) {
      this.operatorList = t[2], this.matrix = t[3], this.bbox = t[4], this.xstep = t[5], this.ystep = t[6], this.paintType = t[7], this.tilingType = t[8], this.color = e, this.ctx = s, this.canvasGraphicsFactory = a, this.baseTransform = o;
    }
    createPatternCanvas(t) {
      const e = this.operatorList, s = this.bbox, a = this.xstep, o = this.ystep, h = this.paintType, c = this.tilingType, p = this.color, g = this.canvasGraphicsFactory;
      $("TilingType: " + c);
      const b = s[0], S = s[1], T = s[2], C = s[3], R = et.singularValueDecompose2dScale(this.matrix), M = et.singularValueDecompose2dScale(this.baseTransform), F = [R[0] * M[0], R[1] * M[1]], O = this.getSizeAndScale(a, this.ctx.canvas.width, F[0]), U = this.getSizeAndScale(o, this.ctx.canvas.height, F[1]), Y = t.cachedCanvases.getCanvas("pattern", O.size, U.size, !0), J = Y.context, rt = g.createCanvasGraphics(J);
      rt.groupLevel = t.groupLevel, this.setFillAndStrokeStyleToContext(rt, h, p);
      let st = b, ot = S, ft = T, yt = C;
      return b < 0 && (st = 0, ft += Math.abs(b)), S < 0 && (ot = 0, yt += Math.abs(S)), J.translate(-(O.scale * st), -(U.scale * ot)), rt.transform(O.scale, 0, 0, U.scale, 0, 0), J.save(), this.clipBbox(rt, st, ot, ft, yt), rt.baseTransform = zt(rt.ctx), rt.executeOperatorList(e), rt.endDrawing(), {
        canvas: Y.canvas,
        scaleX: O.scale,
        scaleY: U.scale,
        offsetX: st,
        offsetY: ot
      };
    }
    getSizeAndScale(t, e, s) {
      t = Math.abs(t);
      const a = Math.max(yf.MAX_PATTERN_SIZE, e);
      let o = Math.ceil(t * s);
      return o >= a ? o = a : s = o / t, {
        scale: s,
        size: o
      };
    }
    clipBbox(t, e, s, a, o) {
      const h = a - e, c = o - s;
      t.ctx.rect(e, s, h, c), t.current.updateRectMinMax(zt(t.ctx), [e, s, a, o]), t.clip(), t.endPath();
    }
    setFillAndStrokeStyleToContext(t, e, s) {
      const a = t.ctx, o = t.current;
      switch (e) {
        case _b.COLORED:
          const h = this.ctx;
          a.fillStyle = h.fillStyle, a.strokeStyle = h.strokeStyle, o.fillColor = h.fillStyle, o.strokeColor = h.strokeStyle;
          break;
        case _b.UNCOLORED:
          const c = et.makeHexColor(s[0], s[1], s[2]);
          a.fillStyle = c, a.strokeStyle = c, o.fillColor = c, o.strokeColor = c;
          break;
        default:
          throw new Ht(`Unsupported paint type: ${e}`);
      }
    }
    getPattern(t, e, s, a) {
      let o = s;
      a !== Se.SHADING && (o = et.transform(o, e.baseTransform), this.matrix && (o = et.transform(o, this.matrix)));
      const h = this.createPatternCanvas(e);
      let c = new DOMMatrix(o);
      c = c.translate(h.offsetX, h.offsetY), c = c.scale(1 / h.scaleX, 1 / h.scaleY);
      const p = t.createPattern(h.canvas, "repeat");
      return p.setTransform(c), p;
    }
  };
  bt(yf, "MAX_PATTERN_SIZE", 3e3);
  let pm = yf;
  function _0({
    src: A,
    srcPos: t = 0,
    dest: e,
    width: s,
    height: a,
    nonBlackColor: o = 4294967295,
    inverseDecode: h = !1
  }) {
    const c = nt.isLittleEndian ? 4278190080 : 255, [p, g] = h ? [o, c] : [c, o], b = s >> 3, S = s & 7, T = A.length;
    e = new Uint32Array(e.buffer);
    let C = 0;
    for (let R = 0; R < a; R++) {
      for (const F = t + b; t < F; t++) {
        const O = t < T ? A[t] : 255;
        e[C++] = O & 128 ? g : p, e[C++] = O & 64 ? g : p, e[C++] = O & 32 ? g : p, e[C++] = O & 16 ? g : p, e[C++] = O & 8 ? g : p, e[C++] = O & 4 ? g : p, e[C++] = O & 2 ? g : p, e[C++] = O & 1 ? g : p;
      }
      if (S === 0)
        continue;
      const M = t < T ? A[t++] : 255;
      for (let F = 0; F < S; F++)
        e[C++] = M & 1 << 7 - F ? g : p;
    }
    return {
      srcPos: t,
      destPos: C
    };
  }
  const Mb = 16, Ob = 100, M0 = 15, kb = 10, Db = 1e3, _e = 16;
  function O0(A, t) {
    if (A._removeMirroring)
      throw new Error("Context is already forwarding operations.");
    A.__originalSave = A.save, A.__originalRestore = A.restore, A.__originalRotate = A.rotate, A.__originalScale = A.scale, A.__originalTranslate = A.translate, A.__originalTransform = A.transform, A.__originalSetTransform = A.setTransform, A.__originalResetTransform = A.resetTransform, A.__originalClip = A.clip, A.__originalMoveTo = A.moveTo, A.__originalLineTo = A.lineTo, A.__originalBezierCurveTo = A.bezierCurveTo, A.__originalRect = A.rect, A.__originalClosePath = A.closePath, A.__originalBeginPath = A.beginPath, A._removeMirroring = () => {
      A.save = A.__originalSave, A.restore = A.__originalRestore, A.rotate = A.__originalRotate, A.scale = A.__originalScale, A.translate = A.__originalTranslate, A.transform = A.__originalTransform, A.setTransform = A.__originalSetTransform, A.resetTransform = A.__originalResetTransform, A.clip = A.__originalClip, A.moveTo = A.__originalMoveTo, A.lineTo = A.__originalLineTo, A.bezierCurveTo = A.__originalBezierCurveTo, A.rect = A.__originalRect, A.closePath = A.__originalClosePath, A.beginPath = A.__originalBeginPath, delete A._removeMirroring;
    }, A.save = function() {
      t.save(), this.__originalSave();
    }, A.restore = function() {
      t.restore(), this.__originalRestore();
    }, A.translate = function(s, a) {
      t.translate(s, a), this.__originalTranslate(s, a);
    }, A.scale = function(s, a) {
      t.scale(s, a), this.__originalScale(s, a);
    }, A.transform = function(s, a, o, h, c, p) {
      t.transform(s, a, o, h, c, p), this.__originalTransform(s, a, o, h, c, p);
    }, A.setTransform = function(s, a, o, h, c, p) {
      t.setTransform(s, a, o, h, c, p), this.__originalSetTransform(s, a, o, h, c, p);
    }, A.resetTransform = function() {
      t.resetTransform(), this.__originalResetTransform();
    }, A.rotate = function(s) {
      t.rotate(s), this.__originalRotate(s);
    }, A.clip = function(s) {
      t.clip(s), this.__originalClip(s);
    }, A.moveTo = function(e, s) {
      t.moveTo(e, s), this.__originalMoveTo(e, s);
    }, A.lineTo = function(e, s) {
      t.lineTo(e, s), this.__originalLineTo(e, s);
    }, A.bezierCurveTo = function(e, s, a, o, h, c) {
      t.bezierCurveTo(e, s, a, o, h, c), this.__originalBezierCurveTo(e, s, a, o, h, c);
    }, A.rect = function(e, s, a, o) {
      t.rect(e, s, a, o), this.__originalRect(e, s, a, o);
    }, A.closePath = function() {
      t.closePath(), this.__originalClosePath();
    }, A.beginPath = function() {
      t.beginPath(), this.__originalBeginPath();
    };
  }
  class k0 {
    constructor(t) {
      this.canvasFactory = t, this.cache = /* @__PURE__ */ Object.create(null);
    }
    getCanvas(t, e, s) {
      let a;
      return this.cache[t] !== void 0 ? (a = this.cache[t], this.canvasFactory.reset(a, e, s)) : (a = this.canvasFactory.create(e, s), this.cache[t] = a), a;
    }
    delete(t) {
      delete this.cache[t];
    }
    clear() {
      for (const t in this.cache) {
        const e = this.cache[t];
        this.canvasFactory.destroy(e), delete this.cache[t];
      }
    }
  }
  function _u(A, t, e, s, a, o, h, c, p, g) {
    const [b, S, T, C, R, M] = zt(A);
    if (S === 0 && T === 0) {
      const U = h * b + R, Y = Math.round(U), J = c * C + M, rt = Math.round(J), st = (h + p) * b + R, ot = Math.abs(Math.round(st) - Y) || 1, ft = (c + g) * C + M, yt = Math.abs(Math.round(ft) - rt) || 1;
      return A.setTransform(Math.sign(b), 0, 0, Math.sign(C), Y, rt), A.drawImage(t, e, s, a, o, 0, 0, ot, yt), A.setTransform(b, S, T, C, R, M), [ot, yt];
    }
    if (b === 0 && C === 0) {
      const U = c * T + R, Y = Math.round(U), J = h * S + M, rt = Math.round(J), st = (c + g) * T + R, ot = Math.abs(Math.round(st) - Y) || 1, ft = (h + p) * S + M, yt = Math.abs(Math.round(ft) - rt) || 1;
      return A.setTransform(0, Math.sign(S), Math.sign(T), 0, Y, rt), A.drawImage(t, e, s, a, o, 0, 0, yt, ot), A.setTransform(b, S, T, C, R, M), [yt, ot];
    }
    A.drawImage(t, e, s, a, o, h, c, p, g);
    const F = Math.hypot(b, S), O = Math.hypot(T, C);
    return [F * p, O * g];
  }
  function D0(A) {
    const {
      width: t,
      height: e
    } = A;
    if (t > Db || e > Db)
      return null;
    const s = 1e3, a = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), o = t + 1;
    let h = new Uint8Array(o * (e + 1)), c, p, g;
    const b = t + 7 & -8;
    let S = new Uint8Array(b * e), T = 0;
    for (const O of A.data) {
      let U = 128;
      for (; U > 0; )
        S[T++] = O & U ? 0 : 255, U >>= 1;
    }
    let C = 0;
    for (T = 0, S[T] !== 0 && (h[0] = 1, ++C), p = 1; p < t; p++)
      S[T] !== S[T + 1] && (h[p] = S[T] ? 2 : 1, ++C), T++;
    for (S[T] !== 0 && (h[p] = 2, ++C), c = 1; c < e; c++) {
      T = c * b, g = c * o, S[T - b] !== S[T] && (h[g] = S[T] ? 1 : 8, ++C);
      let O = (S[T] ? 4 : 0) + (S[T - b] ? 8 : 0);
      for (p = 1; p < t; p++)
        O = (O >> 2) + (S[T + 1] ? 4 : 0) + (S[T - b + 1] ? 8 : 0), a[O] && (h[g + p] = a[O], ++C), T++;
      if (S[T - b] !== S[T] && (h[g + p] = S[T] ? 2 : 4, ++C), C > s)
        return null;
    }
    for (T = b * (e - 1), g = c * o, S[T] !== 0 && (h[g] = 8, ++C), p = 1; p < t; p++)
      S[T] !== S[T + 1] && (h[g + p] = S[T] ? 4 : 8, ++C), T++;
    if (S[T] !== 0 && (h[g + p] = 4, ++C), C > s)
      return null;
    const R = new Int32Array([0, o, -1, 0, -o, 0, 0, 0, 1]), M = new Path2D();
    for (c = 0; C && c <= e; c++) {
      let O = c * o;
      const U = O + t;
      for (; O < U && !h[O]; )
        O++;
      if (O === U)
        continue;
      M.moveTo(O % o, c);
      const Y = O;
      let J = h[O];
      do {
        const rt = R[J];
        do
          O += rt;
        while (!h[O]);
        const st = h[O];
        st !== 5 && st !== 10 ? (J = st, h[O] = 0) : (J = st & 51 * J >> 4, h[O] &= J >> 2 | J << 2), M.lineTo(O % o, O / o | 0), h[O] || --C;
      } while (Y !== O);
      --c;
    }
    return S = null, h = null, function(O) {
      O.save(), O.scale(1 / t, -1 / e), O.translate(0, -e), O.fill(M), O.beginPath(), O.restore();
    };
  }
  class Nb {
    constructor(t, e) {
      this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = n, this.textMatrixScale = 1, this.fontMatrix = i, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = L.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, t, e]);
    }
    clone() {
      const t = Object.create(this);
      return t.clipBox = this.clipBox.slice(), t;
    }
    setCurrentPoint(t, e) {
      this.x = t, this.y = e;
    }
    updatePathMinMax(t, e, s) {
      [e, s] = et.applyTransform([e, s], t), this.minX = Math.min(this.minX, e), this.minY = Math.min(this.minY, s), this.maxX = Math.max(this.maxX, e), this.maxY = Math.max(this.maxY, s);
    }
    updateRectMinMax(t, e) {
      const s = et.applyTransform(e, t), a = et.applyTransform(e.slice(2), t), o = et.applyTransform([e[0], e[3]], t), h = et.applyTransform([e[2], e[1]], t);
      this.minX = Math.min(this.minX, s[0], a[0], o[0], h[0]), this.minY = Math.min(this.minY, s[1], a[1], o[1], h[1]), this.maxX = Math.max(this.maxX, s[0], a[0], o[0], h[0]), this.maxY = Math.max(this.maxY, s[1], a[1], o[1], h[1]);
    }
    updateScalingPathMinMax(t, e) {
      et.scaleMinMax(t, e), this.minX = Math.min(this.minX, e[0]), this.minY = Math.min(this.minY, e[1]), this.maxX = Math.max(this.maxX, e[2]), this.maxY = Math.max(this.maxY, e[3]);
    }
    updateCurvePathMinMax(t, e, s, a, o, h, c, p, g, b) {
      const S = et.bezierBoundingBox(e, s, a, o, h, c, p, g, b);
      b || this.updateRectMinMax(t, S);
    }
    getPathBoundingBox(t = Se.FILL, e = null) {
      const s = [this.minX, this.minY, this.maxX, this.maxY];
      if (t === Se.STROKE) {
        e || Q("Stroke bounding box must include transform.");
        const a = et.singularValueDecompose2dScale(e), o = a[0] * this.lineWidth / 2, h = a[1] * this.lineWidth / 2;
        s[0] -= o, s[1] -= h, s[2] += o, s[3] += h;
      }
      return s;
    }
    updateClipFromPath() {
      const t = et.intersect(this.clipBox, this.getPathBoundingBox());
      this.startNewPathAndClipBox(t || [0, 0, 0, 0]);
    }
    isEmptyClip() {
      return this.minX === 1 / 0;
    }
    startNewPathAndClipBox(t) {
      this.clipBox = t, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
    }
    getClippedPathBoundingBox(t = Se.FILL, e = null) {
      return et.intersect(this.clipBox, this.getPathBoundingBox(t, e));
    }
  }
  function Fb(A, t) {
    if (typeof ImageData < "u" && t instanceof ImageData) {
      A.putImageData(t, 0, 0);
      return;
    }
    const e = t.height, s = t.width, a = e % _e, o = (e - a) / _e, h = a === 0 ? o : o + 1, c = A.createImageData(s, _e);
    let p = 0, g;
    const b = t.data, S = c.data;
    let T, C, R, M;
    if (t.kind === _.GRAYSCALE_1BPP) {
      const F = b.byteLength, O = new Uint32Array(S.buffer, 0, S.byteLength >> 2), U = O.length, Y = s + 7 >> 3, J = 4294967295, rt = nt.isLittleEndian ? 4278190080 : 255;
      for (T = 0; T < h; T++) {
        for (R = T < o ? _e : a, g = 0, C = 0; C < R; C++) {
          const st = F - p;
          let ot = 0;
          const ft = st > Y ? s : st * 8 - 7, yt = ft & -8;
          let St = 0, gt = 0;
          for (; ot < yt; ot += 8)
            gt = b[p++], O[g++] = gt & 128 ? J : rt, O[g++] = gt & 64 ? J : rt, O[g++] = gt & 32 ? J : rt, O[g++] = gt & 16 ? J : rt, O[g++] = gt & 8 ? J : rt, O[g++] = gt & 4 ? J : rt, O[g++] = gt & 2 ? J : rt, O[g++] = gt & 1 ? J : rt;
          for (; ot < ft; ot++)
            St === 0 && (gt = b[p++], St = 128), O[g++] = gt & St ? J : rt, St >>= 1;
        }
        for (; g < U; )
          O[g++] = 0;
        A.putImageData(c, 0, T * _e);
      }
    } else if (t.kind === _.RGBA_32BPP) {
      for (C = 0, M = s * _e * 4, T = 0; T < o; T++)
        S.set(b.subarray(p, p + M)), p += M, A.putImageData(c, 0, C), C += _e;
      T < h && (M = s * a * 4, S.set(b.subarray(p, p + M)), A.putImageData(c, 0, C));
    } else if (t.kind === _.RGB_24BPP)
      for (R = _e, M = s * R, T = 0; T < h; T++) {
        for (T >= o && (R = a, M = s * R), g = 0, C = M; C--; )
          S[g++] = b[p++], S[g++] = b[p++], S[g++] = b[p++], S[g++] = 255;
        A.putImageData(c, 0, T * _e);
      }
    else
      throw new Error(`bad image kind: ${t.kind}`);
  }
  function Bb(A, t) {
    if (t.bitmap) {
      A.drawImage(t.bitmap, 0, 0);
      return;
    }
    const e = t.height, s = t.width, a = e % _e, o = (e - a) / _e, h = a === 0 ? o : o + 1, c = A.createImageData(s, _e);
    let p = 0;
    const g = t.data, b = c.data;
    for (let S = 0; S < h; S++) {
      const T = S < o ? _e : a;
      ({
        srcPos: p
      } = _0({
        src: g,
        srcPos: p,
        dest: b,
        width: s,
        height: T,
        nonBlackColor: 0
      })), A.putImageData(c, 0, S * _e);
    }
  }
  function Ol(A, t) {
    const e = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
    for (const s of e)
      A[s] !== void 0 && (t[s] = A[s]);
    A.setLineDash !== void 0 && (t.setLineDash(A.getLineDash()), t.lineDashOffset = A.lineDashOffset);
  }
  function Mu(A) {
    if (A.strokeStyle = A.fillStyle = "#000000", A.fillRule = "nonzero", A.globalAlpha = 1, A.lineWidth = 1, A.lineCap = "butt", A.lineJoin = "miter", A.miterLimit = 10, A.globalCompositeOperation = "source-over", A.font = "10px sans-serif", A.setLineDash !== void 0 && (A.setLineDash([]), A.lineDashOffset = 0), !u) {
      const {
        filter: t
      } = A;
      t !== "none" && t !== "" && (A.filter = "none");
    }
  }
  function jb(A, t) {
    if (t)
      return !0;
    const e = et.singularValueDecompose2dScale(A);
    e[0] = Math.fround(e[0]), e[1] = Math.fround(e[1]);
    const s = Math.fround((globalThis.devicePixelRatio || 1) * Vi.PDF_TO_CSS_UNITS);
    return e[0] <= s && e[1] <= s;
  }
  const N0 = ["butt", "round", "square"], F0 = ["miter", "round", "bevel"], B0 = {}, Hb = {}, Lm = class Lm {
    constructor(t, e, s, a, o, {
      optionalContentConfig: h,
      markedContentStack: c = null
    }, p, g) {
      v(this, _h);
      v(this, Mh);
      this.ctx = t, this.current = new Nb(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = e, this.objs = s, this.canvasFactory = a, this.filterFactory = o, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = c || [], this.optionalContentConfig = h, this.cachedCanvases = new k0(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = p, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = g, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
    }
    getObject(t, e = null) {
      return typeof t == "string" ? t.startsWith("g_") ? this.commonObjs.get(t) : this.objs.get(t) : e;
    }
    beginDrawing({
      transform: t,
      viewport: e,
      transparency: s = !1,
      background: a = null
    }) {
      const o = this.ctx.canvas.width, h = this.ctx.canvas.height, c = this.ctx.fillStyle;
      if (this.ctx.fillStyle = a || "#ffffff", this.ctx.fillRect(0, 0, o, h), this.ctx.fillStyle = c, s) {
        const p = this.cachedCanvases.getCanvas("transparent", o, h);
        this.compositeCtx = this.ctx, this.transparentCanvas = p.canvas, this.ctx = p.context, this.ctx.save(), this.ctx.transform(...zt(this.compositeCtx));
      }
      this.ctx.save(), Mu(this.ctx), t && (this.ctx.transform(...t), this.outputScaleX = t[0], this.outputScaleY = t[0]), this.ctx.transform(...e.transform), this.viewportScale = e.scale, this.baseTransform = zt(this.ctx);
    }
    executeOperatorList(t, e, s, a) {
      const o = t.argsArray, h = t.fnArray;
      let c = e || 0;
      const p = o.length;
      if (p === c)
        return c;
      const g = p - c > kb && typeof s == "function", b = g ? Date.now() + M0 : 0;
      let S = 0;
      const T = this.commonObjs, C = this.objs;
      let R;
      for (; ; ) {
        if (a !== void 0 && c === a.nextBreakPoint)
          return a.breakIt(c, s), c;
        if (R = h[c], R !== N.dependency)
          this[R].apply(this, o[c]);
        else
          for (const M of o[c]) {
            const F = M.startsWith("g_") ? T : C;
            if (!F.has(M))
              return F.get(M, s), c;
          }
        if (c++, c === p)
          return c;
        if (g && ++S > kb) {
          if (Date.now() > b)
            return s(), c;
          S = 0;
        }
      }
    }
    endDrawing() {
      E(this, _h, cv).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
      for (const t of this._cachedBitmapsMap.values()) {
        for (const e of t.values())
          typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement && (e.width = e.height = 0);
        t.clear();
      }
      this._cachedBitmapsMap.clear(), E(this, Mh, dv).call(this);
    }
    _scaleImage(t, e) {
      const s = t.width, a = t.height;
      let o = Math.max(Math.hypot(e[0], e[1]), 1), h = Math.max(Math.hypot(e[2], e[3]), 1), c = s, p = a, g = "prescale1", b, S;
      for (; o > 2 && c > 1 || h > 2 && p > 1; ) {
        let T = c, C = p;
        o > 2 && c > 1 && (T = c >= 16384 ? Math.floor(c / 2) - 1 || 1 : Math.ceil(c / 2), o /= c / T), h > 2 && p > 1 && (C = p >= 16384 ? Math.floor(p / 2) - 1 || 1 : Math.ceil(p) / 2, h /= p / C), b = this.cachedCanvases.getCanvas(g, T, C), S = b.context, S.clearRect(0, 0, T, C), S.drawImage(t, 0, 0, c, p, 0, 0, T, C), t = b.canvas, c = T, p = C, g = g === "prescale1" ? "prescale2" : "prescale1";
      }
      return {
        img: t,
        paintWidth: c,
        paintHeight: p
      };
    }
    _createMaskCanvas(t) {
      const e = this.ctx, {
        width: s,
        height: a
      } = t, o = this.current.fillColor, h = this.current.patternFill, c = zt(e);
      let p, g, b, S;
      if ((t.bitmap || t.data) && t.count > 1) {
        const ft = t.bitmap || t.data.buffer;
        g = JSON.stringify(h ? c : [c.slice(0, 4), o]), p = this._cachedBitmapsMap.get(ft), p || (p = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(ft, p));
        const yt = p.get(g);
        if (yt && !h) {
          const St = Math.round(Math.min(c[0], c[2]) + c[4]), gt = Math.round(Math.min(c[1], c[3]) + c[5]);
          return {
            canvas: yt,
            offsetX: St,
            offsetY: gt
          };
        }
        b = yt;
      }
      b || (S = this.cachedCanvases.getCanvas("maskCanvas", s, a), Bb(S.context, t));
      let T = et.transform(c, [1 / s, 0, 0, -1 / a, 0, 0]);
      T = et.transform(T, [1, 0, 0, 1, 0, -a]);
      const [C, R, M, F] = et.getAxialAlignedBoundingBox([0, 0, s, a], T), O = Math.round(M - C) || 1, U = Math.round(F - R) || 1, Y = this.cachedCanvases.getCanvas("fillCanvas", O, U), J = Y.context, rt = C, st = R;
      J.translate(-rt, -st), J.transform(...T), b || (b = this._scaleImage(S.canvas, Ys(J)), b = b.img, p && h && p.set(g, b)), J.imageSmoothingEnabled = jb(zt(J), t.interpolate), _u(J, b, 0, 0, b.width, b.height, 0, 0, s, a), J.globalCompositeOperation = "source-in";
      const ot = et.transform(Ys(J), [1, 0, 0, 1, -rt, -st]);
      return J.fillStyle = h ? o.getPattern(e, this, ot, Se.FILL) : o, J.fillRect(0, 0, s, a), p && !h && (this.cachedCanvases.delete("fillCanvas"), p.set(g, Y.canvas)), {
        canvas: Y.canvas,
        offsetX: Math.round(rt),
        offsetY: Math.round(st)
      };
    }
    setLineWidth(t) {
      t !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = t, this.ctx.lineWidth = t;
    }
    setLineCap(t) {
      this.ctx.lineCap = N0[t];
    }
    setLineJoin(t) {
      this.ctx.lineJoin = F0[t];
    }
    setMiterLimit(t) {
      this.ctx.miterLimit = t;
    }
    setDash(t, e) {
      const s = this.ctx;
      s.setLineDash !== void 0 && (s.setLineDash(t), s.lineDashOffset = e);
    }
    setRenderingIntent(t) {
    }
    setFlatness(t) {
    }
    setGState(t) {
      for (const [e, s] of t)
        switch (e) {
          case "LW":
            this.setLineWidth(s);
            break;
          case "LC":
            this.setLineCap(s);
            break;
          case "LJ":
            this.setLineJoin(s);
            break;
          case "ML":
            this.setMiterLimit(s);
            break;
          case "D":
            this.setDash(s[0], s[1]);
            break;
          case "RI":
            this.setRenderingIntent(s);
            break;
          case "FL":
            this.setFlatness(s);
            break;
          case "Font":
            this.setFont(s[0], s[1]);
            break;
          case "CA":
            this.current.strokeAlpha = s;
            break;
          case "ca":
            this.current.fillAlpha = s, this.ctx.globalAlpha = s;
            break;
          case "BM":
            this.ctx.globalCompositeOperation = s;
            break;
          case "SMask":
            this.current.activeSMask = s ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
            break;
          case "TR":
            this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(s);
            break;
        }
    }
    get inSMaskMode() {
      return !!this.suspendedCtx;
    }
    checkSMaskState() {
      const t = this.inSMaskMode;
      this.current.activeSMask && !t ? this.beginSMaskMode() : !this.current.activeSMask && t && this.endSMaskMode();
    }
    beginSMaskMode() {
      if (this.inSMaskMode)
        throw new Error("beginSMaskMode called while already in smask mode");
      const t = this.ctx.canvas.width, e = this.ctx.canvas.height, s = "smaskGroupAt" + this.groupLevel, a = this.cachedCanvases.getCanvas(s, t, e);
      this.suspendedCtx = this.ctx, this.ctx = a.context;
      const o = this.ctx;
      o.setTransform(...zt(this.suspendedCtx)), Ol(this.suspendedCtx, o), O0(o, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
    }
    endSMaskMode() {
      if (!this.inSMaskMode)
        throw new Error("endSMaskMode called while not in smask mode");
      this.ctx._removeMirroring(), Ol(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
    }
    compose(t) {
      if (!this.current.activeSMask)
        return;
      t ? (t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.ceil(t[2]), t[3] = Math.ceil(t[3])) : t = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
      const e = this.current.activeSMask, s = this.suspendedCtx;
      this.composeSMask(s, e, this.ctx, t), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
    }
    composeSMask(t, e, s, a) {
      const o = a[0], h = a[1], c = a[2] - o, p = a[3] - h;
      c === 0 || p === 0 || (this.genericComposeSMask(e.context, s, c, p, e.subtype, e.backdrop, e.transferMap, o, h, e.offsetX, e.offsetY), t.save(), t.globalAlpha = 1, t.globalCompositeOperation = "source-over", t.setTransform(1, 0, 0, 1, 0, 0), t.drawImage(s.canvas, 0, 0), t.restore());
    }
    genericComposeSMask(t, e, s, a, o, h, c, p, g, b, S) {
      let T = t.canvas, C = p - b, R = g - S;
      if (h) {
        if (C < 0 || R < 0 || C + s > T.width || R + a > T.height) {
          const F = this.cachedCanvases.getCanvas("maskExtension", s, a), O = F.context;
          O.drawImage(T, -C, -R), h.some((U) => U !== 0) && (O.globalCompositeOperation = "destination-atop", O.fillStyle = et.makeHexColor(...h), O.fillRect(0, 0, s, a), O.globalCompositeOperation = "source-over"), T = F.canvas, C = R = 0;
        } else if (h.some((F) => F !== 0)) {
          t.save(), t.globalAlpha = 1, t.setTransform(1, 0, 0, 1, 0, 0);
          const F = new Path2D();
          F.rect(C, R, s, a), t.clip(F), t.globalCompositeOperation = "destination-atop", t.fillStyle = et.makeHexColor(...h), t.fillRect(C, R, s, a), t.restore();
        }
      }
      e.save(), e.globalAlpha = 1, e.setTransform(1, 0, 0, 1, 0, 0), o === "Alpha" && c ? e.filter = this.filterFactory.addAlphaFilter(c) : o === "Luminosity" && (e.filter = this.filterFactory.addLuminosityFilter(c));
      const M = new Path2D();
      M.rect(p, g, s, a), e.clip(M), e.globalCompositeOperation = "destination-in", e.drawImage(T, C, R, s, a, p, g, s, a), e.restore();
    }
    save() {
      this.inSMaskMode ? (Ol(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
      const t = this.current;
      this.stateStack.push(t), this.current = t.clone();
    }
    restore() {
      this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), Ol(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
    }
    transform(t, e, s, a, o, h) {
      this.ctx.transform(t, e, s, a, o, h), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
    }
    constructPath(t, e, s) {
      const a = this.ctx, o = this.current;
      let h = o.x, c = o.y, p, g;
      const b = zt(a), S = b[0] === 0 && b[3] === 0 || b[1] === 0 && b[2] === 0, T = S ? s.slice(0) : null;
      for (let C = 0, R = 0, M = t.length; C < M; C++)
        switch (t[C] | 0) {
          case N.rectangle:
            h = e[R++], c = e[R++];
            const F = e[R++], O = e[R++], U = h + F, Y = c + O;
            a.moveTo(h, c), F === 0 || O === 0 ? a.lineTo(U, Y) : (a.lineTo(U, c), a.lineTo(U, Y), a.lineTo(h, Y)), S || o.updateRectMinMax(b, [h, c, U, Y]), a.closePath();
            break;
          case N.moveTo:
            h = e[R++], c = e[R++], a.moveTo(h, c), S || o.updatePathMinMax(b, h, c);
            break;
          case N.lineTo:
            h = e[R++], c = e[R++], a.lineTo(h, c), S || o.updatePathMinMax(b, h, c);
            break;
          case N.curveTo:
            p = h, g = c, h = e[R + 4], c = e[R + 5], a.bezierCurveTo(e[R], e[R + 1], e[R + 2], e[R + 3], h, c), o.updateCurvePathMinMax(b, p, g, e[R], e[R + 1], e[R + 2], e[R + 3], h, c, T), R += 6;
            break;
          case N.curveTo2:
            p = h, g = c, a.bezierCurveTo(h, c, e[R], e[R + 1], e[R + 2], e[R + 3]), o.updateCurvePathMinMax(b, p, g, h, c, e[R], e[R + 1], e[R + 2], e[R + 3], T), h = e[R + 2], c = e[R + 3], R += 4;
            break;
          case N.curveTo3:
            p = h, g = c, h = e[R + 2], c = e[R + 3], a.bezierCurveTo(e[R], e[R + 1], h, c, h, c), o.updateCurvePathMinMax(b, p, g, e[R], e[R + 1], h, c, h, c, T), R += 4;
            break;
          case N.closePath:
            a.closePath();
            break;
        }
      S && o.updateScalingPathMinMax(b, T), o.setCurrentPoint(h, c);
    }
    closePath() {
      this.ctx.closePath();
    }
    stroke(t = !0) {
      const e = this.ctx, s = this.current.strokeColor;
      e.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof s == "object" && (s != null && s.getPattern) ? (e.save(), e.strokeStyle = s.getPattern(e, this, Ys(e), Se.STROKE), this.rescaleAndStroke(!1), e.restore()) : this.rescaleAndStroke(!0)), t && this.consumePath(this.current.getClippedPathBoundingBox()), e.globalAlpha = this.current.fillAlpha;
    }
    closeStroke() {
      this.closePath(), this.stroke();
    }
    fill(t = !0) {
      const e = this.ctx, s = this.current.fillColor, a = this.current.patternFill;
      let o = !1;
      a && (e.save(), e.fillStyle = s.getPattern(e, this, Ys(e), Se.FILL), o = !0);
      const h = this.current.getClippedPathBoundingBox();
      this.contentVisible && h !== null && (this.pendingEOFill ? (e.fill("evenodd"), this.pendingEOFill = !1) : e.fill()), o && e.restore(), t && this.consumePath(h);
    }
    eoFill() {
      this.pendingEOFill = !0, this.fill();
    }
    fillStroke() {
      this.fill(!1), this.stroke(!1), this.consumePath();
    }
    eoFillStroke() {
      this.pendingEOFill = !0, this.fillStroke();
    }
    closeFillStroke() {
      this.closePath(), this.fillStroke();
    }
    closeEOFillStroke() {
      this.pendingEOFill = !0, this.closePath(), this.fillStroke();
    }
    endPath() {
      this.consumePath();
    }
    clip() {
      this.pendingClip = B0;
    }
    eoClip() {
      this.pendingClip = Hb;
    }
    beginText() {
      this.current.textMatrix = n, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
    }
    endText() {
      const t = this.pendingTextPaths, e = this.ctx;
      if (t === void 0) {
        e.beginPath();
        return;
      }
      e.save(), e.beginPath();
      for (const s of t)
        e.setTransform(...s.transform), e.translate(s.x, s.y), s.addToPath(e, s.fontSize);
      e.restore(), e.clip(), e.beginPath(), delete this.pendingTextPaths;
    }
    setCharSpacing(t) {
      this.current.charSpacing = t;
    }
    setWordSpacing(t) {
      this.current.wordSpacing = t;
    }
    setHScale(t) {
      this.current.textHScale = t / 100;
    }
    setLeading(t) {
      this.current.leading = -t;
    }
    setFont(t, e) {
      var b;
      const s = this.commonObjs.get(t), a = this.current;
      if (!s)
        throw new Error(`Can't find font for ${t}`);
      if (a.fontMatrix = s.fontMatrix || i, (a.fontMatrix[0] === 0 || a.fontMatrix[3] === 0) && j("Invalid font matrix for font " + t), e < 0 ? (e = -e, a.fontDirection = -1) : a.fontDirection = 1, this.current.font = s, this.current.fontSize = e, s.isType3Font)
        return;
      const o = s.loadedName || "sans-serif", h = ((b = s.systemFontInfo) == null ? void 0 : b.css) || `"${o}", ${s.fallbackName}`;
      let c = "normal";
      s.black ? c = "900" : s.bold && (c = "bold");
      const p = s.italic ? "italic" : "normal";
      let g = e;
      e < Mb ? g = Mb : e > Ob && (g = Ob), this.current.fontSizeScale = e / g, this.ctx.font = `${p} ${c} ${g}px ${h}`;
    }
    setTextRenderingMode(t) {
      this.current.textRenderingMode = t;
    }
    setTextRise(t) {
      this.current.textRise = t;
    }
    moveText(t, e) {
      this.current.x = this.current.lineX += t, this.current.y = this.current.lineY += e;
    }
    setLeadingMoveText(t, e) {
      this.setLeading(-e), this.moveText(t, e);
    }
    setTextMatrix(t, e, s, a, o, h) {
      this.current.textMatrix = [t, e, s, a, o, h], this.current.textMatrixScale = Math.hypot(t, e), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
    }
    nextLine() {
      this.moveText(0, this.current.leading);
    }
    paintChar(t, e, s, a) {
      const o = this.ctx, h = this.current, c = h.font, p = h.textRenderingMode, g = h.fontSize / h.fontSizeScale, b = p & L.FILL_STROKE_MASK, S = !!(p & L.ADD_TO_PATH_FLAG), T = h.patternFill && !c.missingFile;
      let C;
      (c.disableFontFace || S || T) && (C = c.getPathGenerator(this.commonObjs, t)), c.disableFontFace || T ? (o.save(), o.translate(e, s), o.beginPath(), C(o, g), a && o.setTransform(...a), (b === L.FILL || b === L.FILL_STROKE) && o.fill(), (b === L.STROKE || b === L.FILL_STROKE) && o.stroke(), o.restore()) : ((b === L.FILL || b === L.FILL_STROKE) && o.fillText(t, e, s), (b === L.STROKE || b === L.FILL_STROKE) && o.strokeText(t, e, s)), S && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
        transform: zt(o),
        x: e,
        y: s,
        fontSize: g,
        addToPath: C
      });
    }
    get isFontSubpixelAAEnabled() {
      const {
        context: t
      } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
      t.scale(1.5, 1), t.fillText("I", 0, 10);
      const e = t.getImageData(0, 0, 10, 10).data;
      let s = !1;
      for (let a = 3; a < e.length; a += 4)
        if (e[a] > 0 && e[a] < 255) {
          s = !0;
          break;
        }
      return tt(this, "isFontSubpixelAAEnabled", s);
    }
    showText(t) {
      const e = this.current, s = e.font;
      if (s.isType3Font)
        return this.showType3Text(t);
      const a = e.fontSize;
      if (a === 0)
        return;
      const o = this.ctx, h = e.fontSizeScale, c = e.charSpacing, p = e.wordSpacing, g = e.fontDirection, b = e.textHScale * g, S = t.length, T = s.vertical, C = T ? 1 : -1, R = s.defaultVMetrics, M = a * e.fontMatrix[0], F = e.textRenderingMode === L.FILL && !s.disableFontFace && !e.patternFill;
      o.save(), o.transform(...e.textMatrix), o.translate(e.x, e.y + e.textRise), g > 0 ? o.scale(b, -1) : o.scale(b, 1);
      let O;
      if (e.patternFill) {
        o.save();
        const st = e.fillColor.getPattern(o, this, Ys(o), Se.FILL);
        O = zt(o), o.restore(), o.fillStyle = st;
      }
      let U = e.lineWidth;
      const Y = e.textMatrixScale;
      if (Y === 0 || U === 0) {
        const st = e.textRenderingMode & L.FILL_STROKE_MASK;
        (st === L.STROKE || st === L.FILL_STROKE) && (U = this.getSinglePixelWidth());
      } else
        U /= Y;
      if (h !== 1 && (o.scale(h, h), U /= h), o.lineWidth = U, s.isInvalidPDFjsFont) {
        const st = [];
        let ot = 0;
        for (const ft of t)
          st.push(ft.unicode), ot += ft.width;
        o.fillText(st.join(""), 0, 0), e.x += ot * M * b, o.restore(), this.compose();
        return;
      }
      let J = 0, rt;
      for (rt = 0; rt < S; ++rt) {
        const st = t[rt];
        if (typeof st == "number") {
          J += C * st * a / 1e3;
          continue;
        }
        let ot = !1;
        const ft = (st.isSpace ? p : 0) + c, yt = st.fontChar, St = st.accent;
        let gt, Wt, Dt = st.width;
        if (T) {
          const Ut = st.vmetric || R, Ce = -(st.vmetric ? Ut[1] : Dt * 0.5) * M, mt = Ut[2] * M;
          Dt = Ut ? -Ut[0] : Dt, gt = Ce / h, Wt = (J + mt) / h;
        } else
          gt = J / h, Wt = 0;
        if (s.remeasure && Dt > 0) {
          const Ut = o.measureText(yt).width * 1e3 / a * h;
          if (Dt < Ut && this.isFontSubpixelAAEnabled) {
            const Ce = Dt / Ut;
            ot = !0, o.save(), o.scale(Ce, 1), gt /= Ce;
          } else
            Dt !== Ut && (gt += (Dt - Ut) / 2e3 * a / h);
        }
        if (this.contentVisible && (st.isInFont || s.missingFile)) {
          if (F && !St)
            o.fillText(yt, gt, Wt);
          else if (this.paintChar(yt, gt, Wt, O), St) {
            const Ut = gt + a * St.offset.x / h, Ce = Wt - a * St.offset.y / h;
            this.paintChar(St.fontChar, Ut, Ce, O);
          }
        }
        const $t = T ? Dt * M - ft * g : Dt * M + ft * g;
        J += $t, ot && o.restore();
      }
      T ? e.y -= J : e.x += J * b, o.restore(), this.compose();
    }
    showType3Text(t) {
      const e = this.ctx, s = this.current, a = s.font, o = s.fontSize, h = s.fontDirection, c = a.vertical ? 1 : -1, p = s.charSpacing, g = s.wordSpacing, b = s.textHScale * h, S = s.fontMatrix || i, T = t.length, C = s.textRenderingMode === L.INVISIBLE;
      let R, M, F, O;
      if (!(C || o === 0)) {
        for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, e.save(), e.transform(...s.textMatrix), e.translate(s.x, s.y), e.scale(b, h), R = 0; R < T; ++R) {
          if (M = t[R], typeof M == "number") {
            O = c * M * o / 1e3, this.ctx.translate(O, 0), s.x += O * b;
            continue;
          }
          const U = (M.isSpace ? g : 0) + p, Y = a.charProcOperatorList[M.operatorListId];
          if (!Y) {
            j(`Type3 character "${M.operatorListId}" is not available.`);
            continue;
          }
          this.contentVisible && (this.processingType3 = M, this.save(), e.scale(o, o), e.transform(...S), this.executeOperatorList(Y), this.restore()), F = et.applyTransform([M.width, 0], S)[0] * o + U, e.translate(F, 0), s.x += F * b;
        }
        e.restore(), this.processingType3 = null;
      }
    }
    setCharWidth(t, e) {
    }
    setCharWidthAndBounds(t, e, s, a, o, h) {
      this.ctx.rect(s, a, o - s, h - a), this.ctx.clip(), this.endPath();
    }
    getColorN_Pattern(t) {
      let e;
      if (t[0] === "TilingPattern") {
        const s = t[1], a = this.baseTransform || zt(this.ctx), o = {
          createCanvasGraphics: (h) => new Lm(h, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
            optionalContentConfig: this.optionalContentConfig,
            markedContentStack: this.markedContentStack
          })
        };
        e = new pm(t, s, this.ctx, o, a);
      } else
        e = this._getPattern(t[1], t[2]);
      return e;
    }
    setStrokeColorN() {
      this.current.strokeColor = this.getColorN_Pattern(arguments);
    }
    setFillColorN() {
      this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
    }
    setStrokeRGBColor(t, e, s) {
      const a = et.makeHexColor(t, e, s);
      this.ctx.strokeStyle = a, this.current.strokeColor = a;
    }
    setFillRGBColor(t, e, s) {
      const a = et.makeHexColor(t, e, s);
      this.ctx.fillStyle = a, this.current.fillColor = a, this.current.patternFill = !1;
    }
    _getPattern(t, e = null) {
      let s;
      return this.cachedPatterns.has(t) ? s = this.cachedPatterns.get(t) : (s = L0(this.getObject(t)), this.cachedPatterns.set(t, s)), e && (s.matrix = e), s;
    }
    shadingFill(t) {
      if (!this.contentVisible)
        return;
      const e = this.ctx;
      this.save();
      const s = this._getPattern(t);
      e.fillStyle = s.getPattern(e, this, Ys(e), Se.SHADING);
      const a = Ys(e);
      if (a) {
        const {
          width: o,
          height: h
        } = e.canvas, [c, p, g, b] = et.getAxialAlignedBoundingBox([0, 0, o, h], a);
        this.ctx.fillRect(c, p, g - c, b - p);
      } else
        this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
      this.compose(this.current.getClippedPathBoundingBox()), this.restore();
    }
    beginInlineImage() {
      Q("Should not call beginInlineImage");
    }
    beginImageData() {
      Q("Should not call beginImageData");
    }
    paintFormXObjectBegin(t, e) {
      if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), t && this.transform(...t), this.baseTransform = zt(this.ctx), e)) {
        const s = e[2] - e[0], a = e[3] - e[1];
        this.ctx.rect(e[0], e[1], s, a), this.current.updateRectMinMax(zt(this.ctx), e), this.clip(), this.endPath();
      }
    }
    paintFormXObjectEnd() {
      this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
    }
    beginGroup(t) {
      if (!this.contentVisible)
        return;
      this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
      const e = this.ctx;
      t.isolated || $("TODO: Support non-isolated groups."), t.knockout && j("Knockout groups not supported.");
      const s = zt(e);
      if (t.matrix && e.transform(...t.matrix), !t.bbox)
        throw new Error("Bounding box is required.");
      let a = et.getAxialAlignedBoundingBox(t.bbox, zt(e));
      const o = [0, 0, e.canvas.width, e.canvas.height];
      a = et.intersect(a, o) || [0, 0, 0, 0];
      const h = Math.floor(a[0]), c = Math.floor(a[1]), p = Math.max(Math.ceil(a[2]) - h, 1), g = Math.max(Math.ceil(a[3]) - c, 1);
      this.current.startNewPathAndClipBox([0, 0, p, g]);
      let b = "groupAt" + this.groupLevel;
      t.smask && (b += "_smask_" + this.smaskCounter++ % 2);
      const S = this.cachedCanvases.getCanvas(b, p, g), T = S.context;
      T.translate(-h, -c), T.transform(...s), t.smask ? this.smaskStack.push({
        canvas: S.canvas,
        context: T,
        offsetX: h,
        offsetY: c,
        subtype: t.smask.subtype,
        backdrop: t.smask.backdrop,
        transferMap: t.smask.transferMap || null,
        startTransformInverse: null
      }) : (e.setTransform(1, 0, 0, 1, 0, 0), e.translate(h, c), e.save()), Ol(e, T), this.ctx = T, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(e), this.groupLevel++;
    }
    endGroup(t) {
      if (!this.contentVisible)
        return;
      this.groupLevel--;
      const e = this.ctx, s = this.groupStack.pop();
      if (this.ctx = s, this.ctx.imageSmoothingEnabled = !1, t.smask)
        this.tempSMask = this.smaskStack.pop(), this.restore();
      else {
        this.ctx.restore();
        const a = zt(this.ctx);
        this.restore(), this.ctx.save(), this.ctx.setTransform(...a);
        const o = et.getAxialAlignedBoundingBox([0, 0, e.canvas.width, e.canvas.height], a);
        this.ctx.drawImage(e.canvas, 0, 0), this.ctx.restore(), this.compose(o);
      }
    }
    beginAnnotation(t, e, s, a, o) {
      if (E(this, _h, cv).call(this), Mu(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), e) {
        const h = e[2] - e[0], c = e[3] - e[1];
        if (o && this.annotationCanvasMap) {
          s = s.slice(), s[4] -= e[0], s[5] -= e[1], e = e.slice(), e[0] = e[1] = 0, e[2] = h, e[3] = c;
          const [p, g] = et.singularValueDecompose2dScale(zt(this.ctx)), {
            viewportScale: b
          } = this, S = Math.ceil(h * this.outputScaleX * b), T = Math.ceil(c * this.outputScaleY * b);
          this.annotationCanvas = this.canvasFactory.create(S, T);
          const {
            canvas: C,
            context: R
          } = this.annotationCanvas;
          this.annotationCanvasMap.set(t, C), this.annotationCanvas.savedCtx = this.ctx, this.ctx = R, this.ctx.save(), this.ctx.setTransform(p, 0, 0, -g, 0, c * g), Mu(this.ctx);
        } else
          Mu(this.ctx), this.ctx.rect(e[0], e[1], h, c), this.ctx.clip(), this.endPath();
      }
      this.current = new Nb(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...s), this.transform(...a);
    }
    endAnnotation() {
      this.annotationCanvas && (this.ctx.restore(), E(this, Mh, dv).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
    }
    paintImageMaskXObject(t) {
      if (!this.contentVisible)
        return;
      const e = t.count;
      t = this.getObject(t.data, t), t.count = e;
      const s = this.ctx, a = this.processingType3;
      if (a && (a.compiled === void 0 && (a.compiled = D0(t)), a.compiled)) {
        a.compiled(s);
        return;
      }
      const o = this._createMaskCanvas(t), h = o.canvas;
      s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.drawImage(h, o.offsetX, o.offsetY), s.restore(), this.compose();
    }
    paintImageMaskXObjectRepeat(t, e, s = 0, a = 0, o, h) {
      if (!this.contentVisible)
        return;
      t = this.getObject(t.data, t);
      const c = this.ctx;
      c.save();
      const p = zt(c);
      c.transform(e, s, a, o, 0, 0);
      const g = this._createMaskCanvas(t);
      c.setTransform(1, 0, 0, 1, g.offsetX - p[4], g.offsetY - p[5]);
      for (let b = 0, S = h.length; b < S; b += 2) {
        const T = et.transform(p, [e, s, a, o, h[b], h[b + 1]]), [C, R] = et.applyTransform([0, 0], T);
        c.drawImage(g.canvas, C, R);
      }
      c.restore(), this.compose();
    }
    paintImageMaskXObjectGroup(t) {
      if (!this.contentVisible)
        return;
      const e = this.ctx, s = this.current.fillColor, a = this.current.patternFill;
      for (const o of t) {
        const {
          data: h,
          width: c,
          height: p,
          transform: g
        } = o, b = this.cachedCanvases.getCanvas("maskCanvas", c, p), S = b.context;
        S.save();
        const T = this.getObject(h, o);
        Bb(S, T), S.globalCompositeOperation = "source-in", S.fillStyle = a ? s.getPattern(S, this, Ys(e), Se.FILL) : s, S.fillRect(0, 0, c, p), S.restore(), e.save(), e.transform(...g), e.scale(1, -1), _u(e, b.canvas, 0, 0, c, p, 0, -1, 1, 1), e.restore();
      }
      this.compose();
    }
    paintImageXObject(t) {
      if (!this.contentVisible)
        return;
      const e = this.getObject(t);
      if (!e) {
        j("Dependent image isn't ready yet");
        return;
      }
      this.paintInlineImageXObject(e);
    }
    paintImageXObjectRepeat(t, e, s, a) {
      if (!this.contentVisible)
        return;
      const o = this.getObject(t);
      if (!o) {
        j("Dependent image isn't ready yet");
        return;
      }
      const h = o.width, c = o.height, p = [];
      for (let g = 0, b = a.length; g < b; g += 2)
        p.push({
          transform: [e, 0, 0, s, a[g], a[g + 1]],
          x: 0,
          y: 0,
          w: h,
          h: c
        });
      this.paintInlineImageXObjectGroup(o, p);
    }
    applyTransferMapsToCanvas(t) {
      return this.current.transferMaps !== "none" && (t.filter = this.current.transferMaps, t.drawImage(t.canvas, 0, 0), t.filter = "none"), t.canvas;
    }
    applyTransferMapsToBitmap(t) {
      if (this.current.transferMaps === "none")
        return t.bitmap;
      const {
        bitmap: e,
        width: s,
        height: a
      } = t, o = this.cachedCanvases.getCanvas("inlineImage", s, a), h = o.context;
      return h.filter = this.current.transferMaps, h.drawImage(e, 0, 0), h.filter = "none", o.canvas;
    }
    paintInlineImageXObject(t) {
      if (!this.contentVisible)
        return;
      const e = t.width, s = t.height, a = this.ctx;
      if (this.save(), !u) {
        const {
          filter: c
        } = a;
        c !== "none" && c !== "" && (a.filter = "none");
      }
      a.scale(1 / e, -1 / s);
      let o;
      if (t.bitmap)
        o = this.applyTransferMapsToBitmap(t);
      else if (typeof HTMLElement == "function" && t instanceof HTMLElement || !t.data)
        o = t;
      else {
        const p = this.cachedCanvases.getCanvas("inlineImage", e, s).context;
        Fb(p, t), o = this.applyTransferMapsToCanvas(p);
      }
      const h = this._scaleImage(o, Ys(a));
      a.imageSmoothingEnabled = jb(zt(a), t.interpolate), _u(a, h.img, 0, 0, h.paintWidth, h.paintHeight, 0, -s, e, s), this.compose(), this.restore();
    }
    paintInlineImageXObjectGroup(t, e) {
      if (!this.contentVisible)
        return;
      const s = this.ctx;
      let a;
      if (t.bitmap)
        a = t.bitmap;
      else {
        const o = t.width, h = t.height, p = this.cachedCanvases.getCanvas("inlineImage", o, h).context;
        Fb(p, t), a = this.applyTransferMapsToCanvas(p);
      }
      for (const o of e)
        s.save(), s.transform(...o.transform), s.scale(1, -1), _u(s, a, o.x, o.y, o.w, o.h, 0, -1, 1, 1), s.restore();
      this.compose();
    }
    paintSolidColorImageMask() {
      this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
    }
    markPoint(t) {
    }
    markPointProps(t, e) {
    }
    beginMarkedContent(t) {
      this.markedContentStack.push({
        visible: !0
      });
    }
    beginMarkedContentProps(t, e) {
      t === "OC" ? this.markedContentStack.push({
        visible: this.optionalContentConfig.isVisible(e)
      }) : this.markedContentStack.push({
        visible: !0
      }), this.contentVisible = this.isContentVisible();
    }
    endMarkedContent() {
      this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
    }
    beginCompat() {
    }
    endCompat() {
    }
    consumePath(t) {
      const e = this.current.isEmptyClip();
      this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(t);
      const s = this.ctx;
      this.pendingClip && (e || (this.pendingClip === Hb ? s.clip("evenodd") : s.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), s.beginPath();
    }
    getSinglePixelWidth() {
      if (!this._cachedGetSinglePixelWidth) {
        const t = zt(this.ctx);
        if (t[1] === 0 && t[2] === 0)
          this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(t[0]), Math.abs(t[3]));
        else {
          const e = Math.abs(t[0] * t[3] - t[2] * t[1]), s = Math.hypot(t[0], t[2]), a = Math.hypot(t[1], t[3]);
          this._cachedGetSinglePixelWidth = Math.max(s, a) / e;
        }
      }
      return this._cachedGetSinglePixelWidth;
    }
    getScaleForStroking() {
      if (this._cachedScaleForStroking[0] === -1) {
        const {
          lineWidth: t
        } = this.current, {
          a: e,
          b: s,
          c: a,
          d: o
        } = this.ctx.getTransform();
        let h, c;
        if (s === 0 && a === 0) {
          const p = Math.abs(e), g = Math.abs(o);
          if (p === g)
            if (t === 0)
              h = c = 1 / p;
            else {
              const b = p * t;
              h = c = b < 1 ? 1 / b : 1;
            }
          else if (t === 0)
            h = 1 / p, c = 1 / g;
          else {
            const b = p * t, S = g * t;
            h = b < 1 ? 1 / b : 1, c = S < 1 ? 1 / S : 1;
          }
        } else {
          const p = Math.abs(e * o - s * a), g = Math.hypot(e, s), b = Math.hypot(a, o);
          if (t === 0)
            h = b / p, c = g / p;
          else {
            const S = t * p;
            h = b > S ? b / S : 1, c = g > S ? g / S : 1;
          }
        }
        this._cachedScaleForStroking[0] = h, this._cachedScaleForStroking[1] = c;
      }
      return this._cachedScaleForStroking;
    }
    rescaleAndStroke(t) {
      const {
        ctx: e
      } = this, {
        lineWidth: s
      } = this.current, [a, o] = this.getScaleForStroking();
      if (e.lineWidth = s || 1, a === 1 && o === 1) {
        e.stroke();
        return;
      }
      const h = e.getLineDash();
      if (t && e.save(), e.scale(a, o), h.length > 0) {
        const c = Math.max(a, o);
        e.setLineDash(h.map((p) => p / c)), e.lineDashOffset /= c;
      }
      e.stroke(), t && e.restore();
    }
    isContentVisible() {
      for (let t = this.markedContentStack.length - 1; t >= 0; t--)
        if (!this.markedContentStack[t].visible)
          return !1;
      return !0;
    }
  };
  _h = new WeakSet(), cv = function() {
    for (; this.stateStack.length || this.inSMaskMode; )
      this.restore();
    this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
  }, Mh = new WeakSet(), dv = function() {
    if (this.pageColors) {
      const t = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
      if (t !== "none") {
        const e = this.ctx.filter;
        this.ctx.filter = t, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = e;
      }
    }
  };
  let Ca = Lm;
  for (const A in N)
    Ca.prototype[A] !== void 0 && (Ca.prototype[N[A]] = Ca.prototype[A]);
  class Qs {
    static get workerPort() {
      return r(this, Oh);
    }
    static set workerPort(t) {
      if (!(typeof Worker < "u" && t instanceof Worker) && t !== null)
        throw new Error("Invalid `workerPort` type.");
      x(this, Oh, t);
    }
    static get workerSrc() {
      return r(this, kh);
    }
    static set workerSrc(t) {
      if (typeof t != "string")
        throw new Error("Invalid `workerSrc` type.");
      x(this, kh, t);
    }
  }
  Oh = new WeakMap(), kh = new WeakMap(), v(Qs, Oh, null), v(Qs, kh, "");
  const Ou = {
    UNKNOWN: 0,
    DATA: 1,
    ERROR: 2
  }, Zt = {
    UNKNOWN: 0,
    CANCEL: 1,
    CANCEL_COMPLETE: 2,
    CLOSE: 3,
    ENQUEUE: 4,
    ERROR: 5,
    PULL: 6,
    PULL_COMPLETE: 7,
    START_COMPLETE: 8
  };
  function Ne(A) {
    switch (A instanceof Error || typeof A == "object" && A !== null || Q('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), A.name) {
      case "AbortException":
        return new Ft(A.message);
      case "MissingPDFException":
        return new Et(A.message);
      case "PasswordException":
        return new vt(A.message, A.code);
      case "UnexpectedResponseException":
        return new Pt(A.message, A.status);
      case "UnknownErrorException":
        return new dt(A.message, A.details);
      default:
        return new dt(A.message, A.toString());
    }
  }
  class kl {
    constructor(t, e, s) {
      v(this, Af);
      v(this, Ef);
      v(this, Ka);
      this.sourceName = t, this.targetName = e, this.comObj = s, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (a) => {
        const o = a.data;
        if (o.targetName !== this.sourceName)
          return;
        if (o.stream) {
          E(this, Ef, EA).call(this, o);
          return;
        }
        if (o.callback) {
          const c = o.callbackId, p = this.callbackCapabilities[c];
          if (!p)
            throw new Error(`Cannot resolve callback ${c}`);
          if (delete this.callbackCapabilities[c], o.callback === Ou.DATA)
            p.resolve(o.data);
          else if (o.callback === Ou.ERROR)
            p.reject(Ne(o.reason));
          else
            throw new Error("Unexpected callback case");
          return;
        }
        const h = this.actionHandler[o.action];
        if (!h)
          throw new Error(`Unknown action from worker: ${o.action}`);
        if (o.callbackId) {
          const c = this.sourceName, p = o.sourceName;
          new Promise(function(g) {
            g(h(o.data));
          }).then(function(g) {
            s.postMessage({
              sourceName: c,
              targetName: p,
              callback: Ou.DATA,
              callbackId: o.callbackId,
              data: g
            });
          }, function(g) {
            s.postMessage({
              sourceName: c,
              targetName: p,
              callback: Ou.ERROR,
              callbackId: o.callbackId,
              reason: Ne(g)
            });
          });
          return;
        }
        if (o.streamId) {
          E(this, Af, AA).call(this, o);
          return;
        }
        h(o.data);
      }, s.addEventListener("message", this._onComObjOnMessage);
    }
    on(t, e) {
      const s = this.actionHandler;
      if (s[t])
        throw new Error(`There is already an actionName called "${t}"`);
      s[t] = e;
    }
    send(t, e, s) {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: t,
        data: e
      }, s);
    }
    sendWithPromise(t, e, s) {
      const a = this.callbackId++, o = Promise.withResolvers();
      this.callbackCapabilities[a] = o;
      try {
        this.comObj.postMessage({
          sourceName: this.sourceName,
          targetName: this.targetName,
          action: t,
          callbackId: a,
          data: e
        }, s);
      } catch (h) {
        o.reject(h);
      }
      return o.promise;
    }
    sendWithStream(t, e, s, a) {
      const o = this.streamId++, h = this.sourceName, c = this.targetName, p = this.comObj;
      return new ReadableStream({
        start: (g) => {
          const b = Promise.withResolvers();
          return this.streamControllers[o] = {
            controller: g,
            startCall: b,
            pullCall: null,
            cancelCall: null,
            isClosed: !1
          }, p.postMessage({
            sourceName: h,
            targetName: c,
            action: t,
            streamId: o,
            data: e,
            desiredSize: g.desiredSize
          }, a), b.promise;
        },
        pull: (g) => {
          const b = Promise.withResolvers();
          return this.streamControllers[o].pullCall = b, p.postMessage({
            sourceName: h,
            targetName: c,
            stream: Zt.PULL,
            streamId: o,
            desiredSize: g.desiredSize
          }), b.promise;
        },
        cancel: (g) => {
          B(g instanceof Error, "cancel must have a valid reason");
          const b = Promise.withResolvers();
          return this.streamControllers[o].cancelCall = b, this.streamControllers[o].isClosed = !0, p.postMessage({
            sourceName: h,
            targetName: c,
            stream: Zt.CANCEL,
            streamId: o,
            reason: Ne(g)
          }), b.promise;
        }
      }, s);
    }
    destroy() {
      this.comObj.removeEventListener("message", this._onComObjOnMessage);
    }
  }
  Af = new WeakSet(), AA = function(t) {
    const e = t.streamId, s = this.sourceName, a = t.sourceName, o = this.comObj, h = this, c = this.actionHandler[t.action], p = {
      enqueue(g, b = 1, S) {
        if (this.isCancelled)
          return;
        const T = this.desiredSize;
        this.desiredSize -= b, T > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), o.postMessage({
          sourceName: s,
          targetName: a,
          stream: Zt.ENQUEUE,
          streamId: e,
          chunk: g
        }, S);
      },
      close() {
        this.isCancelled || (this.isCancelled = !0, o.postMessage({
          sourceName: s,
          targetName: a,
          stream: Zt.CLOSE,
          streamId: e
        }), delete h.streamSinks[e]);
      },
      error(g) {
        B(g instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, o.postMessage({
          sourceName: s,
          targetName: a,
          stream: Zt.ERROR,
          streamId: e,
          reason: Ne(g)
        }));
      },
      sinkCapability: Promise.withResolvers(),
      onPull: null,
      onCancel: null,
      isCancelled: !1,
      desiredSize: t.desiredSize,
      ready: null
    };
    p.sinkCapability.resolve(), p.ready = p.sinkCapability.promise, this.streamSinks[e] = p, new Promise(function(g) {
      g(c(t.data, p));
    }).then(function() {
      o.postMessage({
        sourceName: s,
        targetName: a,
        stream: Zt.START_COMPLETE,
        streamId: e,
        success: !0
      });
    }, function(g) {
      o.postMessage({
        sourceName: s,
        targetName: a,
        stream: Zt.START_COMPLETE,
        streamId: e,
        reason: Ne(g)
      });
    });
  }, Ef = new WeakSet(), EA = function(t) {
    const e = t.streamId, s = this.sourceName, a = t.sourceName, o = this.comObj, h = this.streamControllers[e], c = this.streamSinks[e];
    switch (t.stream) {
      case Zt.START_COMPLETE:
        t.success ? h.startCall.resolve() : h.startCall.reject(Ne(t.reason));
        break;
      case Zt.PULL_COMPLETE:
        t.success ? h.pullCall.resolve() : h.pullCall.reject(Ne(t.reason));
        break;
      case Zt.PULL:
        if (!c) {
          o.postMessage({
            sourceName: s,
            targetName: a,
            stream: Zt.PULL_COMPLETE,
            streamId: e,
            success: !0
          });
          break;
        }
        c.desiredSize <= 0 && t.desiredSize > 0 && c.sinkCapability.resolve(), c.desiredSize = t.desiredSize, new Promise(function(p) {
          var g;
          p((g = c.onPull) == null ? void 0 : g.call(c));
        }).then(function() {
          o.postMessage({
            sourceName: s,
            targetName: a,
            stream: Zt.PULL_COMPLETE,
            streamId: e,
            success: !0
          });
        }, function(p) {
          o.postMessage({
            sourceName: s,
            targetName: a,
            stream: Zt.PULL_COMPLETE,
            streamId: e,
            reason: Ne(p)
          });
        });
        break;
      case Zt.ENQUEUE:
        if (B(h, "enqueue should have stream controller"), h.isClosed)
          break;
        h.controller.enqueue(t.chunk);
        break;
      case Zt.CLOSE:
        if (B(h, "close should have stream controller"), h.isClosed)
          break;
        h.isClosed = !0, h.controller.close(), E(this, Ka, Dp).call(this, h, e);
        break;
      case Zt.ERROR:
        B(h, "error should have stream controller"), h.controller.error(Ne(t.reason)), E(this, Ka, Dp).call(this, h, e);
        break;
      case Zt.CANCEL_COMPLETE:
        t.success ? h.cancelCall.resolve() : h.cancelCall.reject(Ne(t.reason)), E(this, Ka, Dp).call(this, h, e);
        break;
      case Zt.CANCEL:
        if (!c)
          break;
        new Promise(function(p) {
          var g;
          p((g = c.onCancel) == null ? void 0 : g.call(c, Ne(t.reason)));
        }).then(function() {
          o.postMessage({
            sourceName: s,
            targetName: a,
            stream: Zt.CANCEL_COMPLETE,
            streamId: e,
            success: !0
          });
        }, function(p) {
          o.postMessage({
            sourceName: s,
            targetName: a,
            stream: Zt.CANCEL_COMPLETE,
            streamId: e,
            reason: Ne(p)
          });
        }), c.sinkCapability.reject(Ne(t.reason)), c.isCancelled = !0, delete this.streamSinks[e];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  }, Ka = new WeakSet(), Dp = async function(t, e) {
    var s, a, o;
    await Promise.allSettled([(s = t.startCall) == null ? void 0 : s.promise, (a = t.pullCall) == null ? void 0 : a.promise, (o = t.cancelCall) == null ? void 0 : o.promise]), delete this.streamControllers[e];
  };
  class j0 {
    constructor({
      parsedData: t,
      rawData: e
    }) {
      v(this, cr, void 0);
      v(this, Dh, void 0);
      x(this, cr, t), x(this, Dh, e);
    }
    getRaw() {
      return r(this, Dh);
    }
    get(t) {
      return r(this, cr).get(t) ?? null;
    }
    getAll() {
      return Bn(r(this, cr));
    }
    has(t) {
      return r(this, cr).has(t);
    }
  }
  cr = new WeakMap(), Dh = new WeakMap();
  const $i = Symbol("INTERNAL");
  class H0 {
    constructor(t, {
      name: e,
      intent: s,
      usage: a
    }) {
      v(this, Nh, !1);
      v(this, Fh, !1);
      v(this, Bh, !1);
      v(this, Ya, !0);
      x(this, Nh, !!(t & f.DISPLAY)), x(this, Fh, !!(t & f.PRINT)), this.name = e, this.intent = s, this.usage = a;
    }
    get visible() {
      if (r(this, Bh))
        return r(this, Ya);
      if (!r(this, Ya))
        return !1;
      const {
        print: t,
        view: e
      } = this.usage;
      return r(this, Nh) ? (e == null ? void 0 : e.viewState) !== "OFF" : r(this, Fh) ? (t == null ? void 0 : t.printState) !== "OFF" : !0;
    }
    _setVisible(t, e, s = !1) {
      t !== $i && Q("Internal method `_setVisible` called."), x(this, Bh, s), x(this, Ya, e);
    }
  }
  Nh = new WeakMap(), Fh = new WeakMap(), Bh = new WeakMap(), Ya = new WeakMap();
  class V0 {
    constructor(t, e = f.DISPLAY) {
      v(this, jh);
      v(this, Zi, null);
      v(this, _t, /* @__PURE__ */ new Map());
      v(this, Qa, null);
      v(this, Za, null);
      if (this.renderingIntent = e, this.name = null, this.creator = null, t !== null) {
        this.name = t.name, this.creator = t.creator, x(this, Za, t.order);
        for (const s of t.groups)
          r(this, _t).set(s.id, new H0(e, s));
        if (t.baseState === "OFF")
          for (const s of r(this, _t).values())
            s._setVisible($i, !1);
        for (const s of t.on)
          r(this, _t).get(s)._setVisible($i, !0);
        for (const s of t.off)
          r(this, _t).get(s)._setVisible($i, !1);
        x(this, Qa, this.getHash());
      }
    }
    isVisible(t) {
      if (r(this, _t).size === 0)
        return !0;
      if (!t)
        return $("Optional content group not defined."), !0;
      if (t.type === "OCG")
        return r(this, _t).has(t.id) ? r(this, _t).get(t.id).visible : (j(`Optional content group not found: ${t.id}`), !0);
      if (t.type === "OCMD") {
        if (t.expression)
          return E(this, jh, uv).call(this, t.expression);
        if (!t.policy || t.policy === "AnyOn") {
          for (const e of t.ids) {
            if (!r(this, _t).has(e))
              return j(`Optional content group not found: ${e}`), !0;
            if (r(this, _t).get(e).visible)
              return !0;
          }
          return !1;
        } else if (t.policy === "AllOn") {
          for (const e of t.ids) {
            if (!r(this, _t).has(e))
              return j(`Optional content group not found: ${e}`), !0;
            if (!r(this, _t).get(e).visible)
              return !1;
          }
          return !0;
        } else if (t.policy === "AnyOff") {
          for (const e of t.ids) {
            if (!r(this, _t).has(e))
              return j(`Optional content group not found: ${e}`), !0;
            if (!r(this, _t).get(e).visible)
              return !0;
          }
          return !1;
        } else if (t.policy === "AllOff") {
          for (const e of t.ids) {
            if (!r(this, _t).has(e))
              return j(`Optional content group not found: ${e}`), !0;
            if (r(this, _t).get(e).visible)
              return !1;
          }
          return !0;
        }
        return j(`Unknown optional content policy ${t.policy}.`), !0;
      }
      return j(`Unknown group type ${t.type}.`), !0;
    }
    setVisibility(t, e = !0) {
      const s = r(this, _t).get(t);
      if (!s) {
        j(`Optional content group not found: ${t}`);
        return;
      }
      s._setVisible($i, !!e, !0), x(this, Zi, null);
    }
    setOCGState({
      state: t,
      preserveRB: e
    }) {
      let s;
      for (const a of t) {
        switch (a) {
          case "ON":
          case "OFF":
          case "Toggle":
            s = a;
            continue;
        }
        const o = r(this, _t).get(a);
        if (o)
          switch (s) {
            case "ON":
              o._setVisible($i, !0);
              break;
            case "OFF":
              o._setVisible($i, !1);
              break;
            case "Toggle":
              o._setVisible($i, !o.visible);
              break;
          }
      }
      x(this, Zi, null);
    }
    get hasInitialVisibility() {
      return r(this, Qa) === null || this.getHash() === r(this, Qa);
    }
    getOrder() {
      return r(this, _t).size ? r(this, Za) ? r(this, Za).slice() : [...r(this, _t).keys()] : null;
    }
    getGroups() {
      return r(this, _t).size > 0 ? Bn(r(this, _t)) : null;
    }
    getGroup(t) {
      return r(this, _t).get(t) || null;
    }
    getHash() {
      if (r(this, Zi) !== null)
        return r(this, Zi);
      const t = new Rb();
      for (const [e, s] of r(this, _t))
        t.update(`${e}:${s.visible}`);
      return x(this, Zi, t.hexdigest());
    }
  }
  Zi = new WeakMap(), _t = new WeakMap(), Qa = new WeakMap(), Za = new WeakMap(), jh = new WeakSet(), uv = function(t) {
    const e = t.length;
    if (e < 2)
      return !0;
    const s = t[0];
    for (let a = 1; a < e; a++) {
      const o = t[a];
      let h;
      if (Array.isArray(o))
        h = E(this, jh, uv).call(this, o);
      else if (r(this, _t).has(o))
        h = r(this, _t).get(o).visible;
      else
        return j(`Optional content group not found: ${o}`), !0;
      switch (s) {
        case "And":
          if (!h)
            return !1;
          break;
        case "Or":
          if (h)
            return !0;
          break;
        case "Not":
          return !h;
        default:
          return !0;
      }
    }
    return s === "And";
  };
  class $0 {
    constructor(t, {
      disableRange: e = !1,
      disableStream: s = !1
    }) {
      B(t, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
      const {
        length: a,
        initialData: o,
        progressiveDone: h,
        contentDispositionFilename: c
      } = t;
      if (this._queuedChunks = [], this._progressiveDone = h, this._contentDispositionFilename = c, (o == null ? void 0 : o.length) > 0) {
        const p = o instanceof Uint8Array && o.byteLength === o.buffer.byteLength ? o.buffer : new Uint8Array(o).buffer;
        this._queuedChunks.push(p);
      }
      this._pdfDataRangeTransport = t, this._isStreamingSupported = !s, this._isRangeSupported = !e, this._contentLength = a, this._fullRequestReader = null, this._rangeReaders = [], t.addRangeListener((p, g) => {
        this._onReceiveData({
          begin: p,
          chunk: g
        });
      }), t.addProgressListener((p, g) => {
        this._onProgress({
          loaded: p,
          total: g
        });
      }), t.addProgressiveReadListener((p) => {
        this._onReceiveData({
          chunk: p
        });
      }), t.addProgressiveDoneListener(() => {
        this._onProgressiveDone();
      }), t.transportReady();
    }
    _onReceiveData({
      begin: t,
      chunk: e
    }) {
      const s = e instanceof Uint8Array && e.byteLength === e.buffer.byteLength ? e.buffer : new Uint8Array(e).buffer;
      if (t === void 0)
        this._fullRequestReader ? this._fullRequestReader._enqueue(s) : this._queuedChunks.push(s);
      else {
        const a = this._rangeReaders.some(function(o) {
          return o._begin !== t ? !1 : (o._enqueue(s), !0);
        });
        B(a, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
      }
    }
    get _progressiveDataLength() {
      var t;
      return ((t = this._fullRequestReader) == null ? void 0 : t._loaded) ?? 0;
    }
    _onProgress(t) {
      var e, s, a, o;
      t.total === void 0 ? (s = (e = this._rangeReaders[0]) == null ? void 0 : e.onProgress) == null || s.call(e, {
        loaded: t.loaded
      }) : (o = (a = this._fullRequestReader) == null ? void 0 : a.onProgress) == null || o.call(a, {
        loaded: t.loaded,
        total: t.total
      });
    }
    _onProgressiveDone() {
      var t;
      (t = this._fullRequestReader) == null || t.progressiveDone(), this._progressiveDone = !0;
    }
    _removeRangeReader(t) {
      const e = this._rangeReaders.indexOf(t);
      e >= 0 && this._rangeReaders.splice(e, 1);
    }
    getFullReader() {
      B(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
      const t = this._queuedChunks;
      return this._queuedChunks = null, new U0(this, t, this._progressiveDone, this._contentDispositionFilename);
    }
    getRangeReader(t, e) {
      if (e <= this._progressiveDataLength)
        return null;
      const s = new z0(this, t, e);
      return this._pdfDataRangeTransport.requestDataRange(t, e), this._rangeReaders.push(s), s;
    }
    cancelAllRequests(t) {
      var e;
      (e = this._fullRequestReader) == null || e.cancel(t);
      for (const s of this._rangeReaders.slice(0))
        s.cancel(t);
      this._pdfDataRangeTransport.abort();
    }
  }
  class U0 {
    constructor(t, e, s = !1, a = null) {
      this._stream = t, this._done = s || !1, this._filename = nm(a) ? a : null, this._queuedChunks = e || [], this._loaded = 0;
      for (const o of this._queuedChunks)
        this._loaded += o.byteLength;
      this._requests = [], this._headersReady = Promise.resolve(), t._fullRequestReader = this, this.onProgress = null;
    }
    _enqueue(t) {
      this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
        value: t,
        done: !1
      }) : this._queuedChunks.push(t), this._loaded += t.byteLength);
    }
    get headersReady() {
      return this._headersReady;
    }
    get filename() {
      return this._filename;
    }
    get isRangeSupported() {
      return this._stream._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._stream._isStreamingSupported;
    }
    get contentLength() {
      return this._stream._contentLength;
    }
    async read() {
      if (this._queuedChunks.length > 0)
        return {
          value: this._queuedChunks.shift(),
          done: !1
        };
      if (this._done)
        return {
          value: void 0,
          done: !0
        };
      const t = Promise.withResolvers();
      return this._requests.push(t), t.promise;
    }
    cancel(t) {
      this._done = !0;
      for (const e of this._requests)
        e.resolve({
          value: void 0,
          done: !0
        });
      this._requests.length = 0;
    }
    progressiveDone() {
      this._done || (this._done = !0);
    }
  }
  class z0 {
    constructor(t, e, s) {
      this._stream = t, this._begin = e, this._end = s, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
    }
    _enqueue(t) {
      if (!this._done) {
        if (this._requests.length === 0)
          this._queuedChunk = t;
        else {
          this._requests.shift().resolve({
            value: t,
            done: !1
          });
          for (const s of this._requests)
            s.resolve({
              value: void 0,
              done: !0
            });
          this._requests.length = 0;
        }
        this._done = !0, this._stream._removeRangeReader(this);
      }
    }
    get isStreamingSupported() {
      return !1;
    }
    async read() {
      if (this._queuedChunk) {
        const e = this._queuedChunk;
        return this._queuedChunk = null, {
          value: e,
          done: !1
        };
      }
      if (this._done)
        return {
          value: void 0,
          done: !0
        };
      const t = Promise.withResolvers();
      return this._requests.push(t), t.promise;
    }
    cancel(t) {
      this._done = !0;
      for (const e of this._requests)
        e.resolve({
          value: void 0,
          done: !0
        });
      this._requests.length = 0, this._stream._removeRangeReader(this);
    }
  }
  function W0(A) {
    let t = !0, e = s("filename\\*", "i").exec(A);
    if (e) {
      e = e[1];
      let b = c(e);
      return b = unescape(b), b = p(b), b = g(b), o(b);
    }
    if (e = h(A), e) {
      const b = g(e);
      return o(b);
    }
    if (e = s("filename", "i").exec(A), e) {
      e = e[1];
      let b = c(e);
      return b = g(b), o(b);
    }
    function s(b, S) {
      return new RegExp("(?:^|;)\\s*" + b + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', S);
    }
    function a(b, S) {
      if (b) {
        if (!/^[\x00-\xFF]+$/.test(S))
          return S;
        try {
          const T = new TextDecoder(b, {
            fatal: !0
          }), C = be(S);
          S = T.decode(C), t = !1;
        } catch {
        }
      }
      return S;
    }
    function o(b) {
      return t && /[\x80-\xff]/.test(b) && (b = a("utf-8", b), t && (b = a("iso-8859-1", b))), b;
    }
    function h(b) {
      const S = [];
      let T;
      const C = s("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
      for (; (T = C.exec(b)) !== null; ) {
        let [, M, F, O] = T;
        if (M = parseInt(M, 10), M in S) {
          if (M === 0)
            break;
          continue;
        }
        S[M] = [F, O];
      }
      const R = [];
      for (let M = 0; M < S.length && M in S; ++M) {
        let [F, O] = S[M];
        O = c(O), F && (O = unescape(O), M === 0 && (O = p(O))), R.push(O);
      }
      return R.join("");
    }
    function c(b) {
      if (b.startsWith('"')) {
        const S = b.slice(1).split('\\"');
        for (let T = 0; T < S.length; ++T) {
          const C = S[T].indexOf('"');
          C !== -1 && (S[T] = S[T].slice(0, C), S.length = T + 1), S[T] = S[T].replaceAll(/\\(.)/g, "$1");
        }
        b = S.join('"');
      }
      return b;
    }
    function p(b) {
      const S = b.indexOf("'");
      if (S === -1)
        return b;
      const T = b.slice(0, S), R = b.slice(S + 1).replace(/^[^']*'/, "");
      return a(T, R);
    }
    function g(b) {
      return !b.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(b) ? b : b.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(S, T, C, R) {
        if (C === "q" || C === "Q")
          return R = R.replaceAll("_", " "), R = R.replaceAll(/=([0-9a-fA-F]{2})/g, function(M, F) {
            return String.fromCharCode(parseInt(F, 16));
          }), a(T, R);
        try {
          R = atob(R);
        } catch {
        }
        return a(T, R);
      });
    }
    return "";
  }
  function gm({
    getResponseHeader: A,
    isHttp: t,
    rangeChunkSize: e,
    disableRange: s
  }) {
    const a = {
      allowRangeRequests: !1,
      suggestedLength: void 0
    }, o = parseInt(A("Content-Length"), 10);
    return !Number.isInteger(o) || (a.suggestedLength = o, o <= 2 * e) || s || !t || A("Accept-Ranges") !== "bytes" || (A("Content-Encoding") || "identity") !== "identity" || (a.allowRangeRequests = !0), a;
  }
  function mm(A) {
    const t = A("Content-Disposition");
    if (t) {
      let e = W0(t);
      if (e.includes("%"))
        try {
          e = decodeURIComponent(e);
        } catch {
        }
      if (nm(e))
        return e;
    }
    return null;
  }
  function ku(A, t) {
    return A === 404 || A === 0 && t.startsWith("file:") ? new Et('Missing PDF "' + t + '".') : new Pt(`Unexpected server response (${A}) while retrieving PDF "${t}".`, A);
  }
  function Vb(A) {
    return A === 200 || A === 206;
  }
  function $b(A, t, e) {
    return {
      method: "GET",
      headers: A,
      signal: e.signal,
      mode: "cors",
      credentials: t ? "include" : "same-origin",
      redirect: "follow"
    };
  }
  function Ub(A) {
    const t = new Headers();
    for (const e in A) {
      const s = A[e];
      s !== void 0 && t.append(e, s);
    }
    return t;
  }
  function zb(A) {
    return A instanceof Uint8Array ? A.buffer : A instanceof ArrayBuffer ? A : (j(`getArrayBuffer - unexpected data format: ${A}`), new Uint8Array(A).buffer);
  }
  class Wb {
    constructor(t) {
      this.source = t, this.isHttp = /^https?:/i.test(t.url), this.httpHeaders = this.isHttp && t.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
    }
    get _progressiveDataLength() {
      var t;
      return ((t = this._fullRequestReader) == null ? void 0 : t._loaded) ?? 0;
    }
    getFullReader() {
      return B(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new G0(this), this._fullRequestReader;
    }
    getRangeReader(t, e) {
      if (e <= this._progressiveDataLength)
        return null;
      const s = new X0(this, t, e);
      return this._rangeRequestReaders.push(s), s;
    }
    cancelAllRequests(t) {
      var e;
      (e = this._fullRequestReader) == null || e.cancel(t);
      for (const s of this._rangeRequestReaders.slice(0))
        s.cancel(t);
    }
  }
  class G0 {
    constructor(t) {
      this._stream = t, this._reader = null, this._loaded = 0, this._filename = null;
      const e = t.source;
      this._withCredentials = e.withCredentials || !1, this._contentLength = e.length, this._headersCapability = Promise.withResolvers(), this._disableRange = e.disableRange || !1, this._rangeChunkSize = e.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !e.disableStream, this._isRangeSupported = !e.disableRange, this._headers = Ub(this._stream.httpHeaders);
      const s = e.url;
      fetch(s, $b(this._headers, this._withCredentials, this._abortController)).then((a) => {
        if (!Vb(a.status))
          throw ku(a.status, s);
        this._reader = a.body.getReader(), this._headersCapability.resolve();
        const o = (p) => a.headers.get(p), {
          allowRangeRequests: h,
          suggestedLength: c
        } = gm({
          getResponseHeader: o,
          isHttp: this._stream.isHttp,
          rangeChunkSize: this._rangeChunkSize,
          disableRange: this._disableRange
        });
        this._isRangeSupported = h, this._contentLength = c || this._contentLength, this._filename = mm(o), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new Ft("Streaming is disabled."));
      }).catch(this._headersCapability.reject), this.onProgress = null;
    }
    get headersReady() {
      return this._headersCapability.promise;
    }
    get filename() {
      return this._filename;
    }
    get contentLength() {
      return this._contentLength;
    }
    get isRangeSupported() {
      return this._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      var s;
      await this._headersCapability.promise;
      const {
        value: t,
        done: e
      } = await this._reader.read();
      return e ? {
        value: t,
        done: e
      } : (this._loaded += t.byteLength, (s = this.onProgress) == null || s.call(this, {
        loaded: this._loaded,
        total: this._contentLength
      }), {
        value: zb(t),
        done: !1
      });
    }
    cancel(t) {
      var e;
      (e = this._reader) == null || e.cancel(t), this._abortController.abort();
    }
  }
  class X0 {
    constructor(t, e, s) {
      this._stream = t, this._reader = null, this._loaded = 0;
      const a = t.source;
      this._withCredentials = a.withCredentials || !1, this._readCapability = Promise.withResolvers(), this._isStreamingSupported = !a.disableStream, this._abortController = new AbortController(), this._headers = Ub(this._stream.httpHeaders), this._headers.append("Range", `bytes=${e}-${s - 1}`);
      const o = a.url;
      fetch(o, $b(this._headers, this._withCredentials, this._abortController)).then((h) => {
        if (!Vb(h.status))
          throw ku(h.status, o);
        this._readCapability.resolve(), this._reader = h.body.getReader();
      }).catch(this._readCapability.reject), this.onProgress = null;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      var s;
      await this._readCapability.promise;
      const {
        value: t,
        done: e
      } = await this._reader.read();
      return e ? {
        value: t,
        done: e
      } : (this._loaded += t.byteLength, (s = this.onProgress) == null || s.call(this, {
        loaded: this._loaded
      }), {
        value: zb(t),
        done: !1
      });
    }
    cancel(t) {
      var e;
      (e = this._reader) == null || e.cancel(t), this._abortController.abort();
    }
  }
  const vm = 200, bm = 206;
  function K0(A) {
    const t = A.response;
    return typeof t != "string" ? t : be(t).buffer;
  }
  class Y0 {
    constructor(t, e = {}) {
      this.url = t, this.isHttp = /^https?:/i.test(t), this.httpHeaders = this.isHttp && e.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = e.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
    }
    requestRange(t, e, s) {
      const a = {
        begin: t,
        end: e
      };
      for (const o in s)
        a[o] = s[o];
      return this.request(a);
    }
    requestFull(t) {
      return this.request(t);
    }
    request(t) {
      const e = new XMLHttpRequest(), s = this.currXhrId++, a = this.pendingRequests[s] = {
        xhr: e
      };
      e.open("GET", this.url), e.withCredentials = this.withCredentials;
      for (const o in this.httpHeaders) {
        const h = this.httpHeaders[o];
        h !== void 0 && e.setRequestHeader(o, h);
      }
      return this.isHttp && "begin" in t && "end" in t ? (e.setRequestHeader("Range", `bytes=${t.begin}-${t.end - 1}`), a.expectedStatus = bm) : a.expectedStatus = vm, e.responseType = "arraybuffer", t.onError && (e.onerror = function(o) {
        t.onError(e.status);
      }), e.onreadystatechange = this.onStateChange.bind(this, s), e.onprogress = this.onProgress.bind(this, s), a.onHeadersReceived = t.onHeadersReceived, a.onDone = t.onDone, a.onError = t.onError, a.onProgress = t.onProgress, e.send(null), s;
    }
    onProgress(t, e) {
      var a;
      const s = this.pendingRequests[t];
      s && ((a = s.onProgress) == null || a.call(s, e));
    }
    onStateChange(t, e) {
      var p, g, b;
      const s = this.pendingRequests[t];
      if (!s)
        return;
      const a = s.xhr;
      if (a.readyState >= 2 && s.onHeadersReceived && (s.onHeadersReceived(), delete s.onHeadersReceived), a.readyState !== 4 || !(t in this.pendingRequests))
        return;
      if (delete this.pendingRequests[t], a.status === 0 && this.isHttp) {
        (p = s.onError) == null || p.call(s, a.status);
        return;
      }
      const o = a.status || vm;
      if (!(o === vm && s.expectedStatus === bm) && o !== s.expectedStatus) {
        (g = s.onError) == null || g.call(s, a.status);
        return;
      }
      const c = K0(a);
      if (o === bm) {
        const S = a.getResponseHeader("Content-Range"), T = /bytes (\d+)-(\d+)\/(\d+)/.exec(S);
        s.onDone({
          begin: parseInt(T[1], 10),
          chunk: c
        });
      } else
        c ? s.onDone({
          begin: 0,
          chunk: c
        }) : (b = s.onError) == null || b.call(s, a.status);
    }
    getRequestXhr(t) {
      return this.pendingRequests[t].xhr;
    }
    isPendingRequest(t) {
      return t in this.pendingRequests;
    }
    abortRequest(t) {
      const e = this.pendingRequests[t].xhr;
      delete this.pendingRequests[t], e.abort();
    }
  }
  class Q0 {
    constructor(t) {
      this._source = t, this._manager = new Y0(t.url, {
        httpHeaders: t.httpHeaders,
        withCredentials: t.withCredentials
      }), this._rangeChunkSize = t.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
    }
    _onRangeRequestReaderClosed(t) {
      const e = this._rangeRequestReaders.indexOf(t);
      e >= 0 && this._rangeRequestReaders.splice(e, 1);
    }
    getFullReader() {
      return B(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new Z0(this._manager, this._source), this._fullRequestReader;
    }
    getRangeReader(t, e) {
      const s = new J0(this._manager, t, e);
      return s.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(s), s;
    }
    cancelAllRequests(t) {
      var e;
      (e = this._fullRequestReader) == null || e.cancel(t);
      for (const s of this._rangeRequestReaders.slice(0))
        s.cancel(t);
    }
  }
  class Z0 {
    constructor(t, e) {
      this._manager = t;
      const s = {
        onHeadersReceived: this._onHeadersReceived.bind(this),
        onDone: this._onDone.bind(this),
        onError: this._onError.bind(this),
        onProgress: this._onProgress.bind(this)
      };
      this._url = e.url, this._fullRequestId = t.requestFull(s), this._headersReceivedCapability = Promise.withResolvers(), this._disableRange = e.disableRange || !1, this._contentLength = e.length, this._rangeChunkSize = e.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
    }
    _onHeadersReceived() {
      const t = this._fullRequestId, e = this._manager.getRequestXhr(t), s = (h) => e.getResponseHeader(h), {
        allowRangeRequests: a,
        suggestedLength: o
      } = gm({
        getResponseHeader: s,
        isHttp: this._manager.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      a && (this._isRangeSupported = !0), this._contentLength = o || this._contentLength, this._filename = mm(s), this._isRangeSupported && this._manager.abortRequest(t), this._headersReceivedCapability.resolve();
    }
    _onDone(t) {
      if (t && (this._requests.length > 0 ? this._requests.shift().resolve({
        value: t.chunk,
        done: !1
      }) : this._cachedChunks.push(t.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
        for (const e of this._requests)
          e.resolve({
            value: void 0,
            done: !0
          });
        this._requests.length = 0;
      }
    }
    _onError(t) {
      this._storedError = ku(t, this._url), this._headersReceivedCapability.reject(this._storedError);
      for (const e of this._requests)
        e.reject(this._storedError);
      this._requests.length = 0, this._cachedChunks.length = 0;
    }
    _onProgress(t) {
      var e;
      (e = this.onProgress) == null || e.call(this, {
        loaded: t.loaded,
        total: t.lengthComputable ? t.total : this._contentLength
      });
    }
    get filename() {
      return this._filename;
    }
    get isRangeSupported() {
      return this._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    get contentLength() {
      return this._contentLength;
    }
    get headersReady() {
      return this._headersReceivedCapability.promise;
    }
    async read() {
      if (this._storedError)
        throw this._storedError;
      if (this._cachedChunks.length > 0)
        return {
          value: this._cachedChunks.shift(),
          done: !1
        };
      if (this._done)
        return {
          value: void 0,
          done: !0
        };
      const t = Promise.withResolvers();
      return this._requests.push(t), t.promise;
    }
    cancel(t) {
      this._done = !0, this._headersReceivedCapability.reject(t);
      for (const e of this._requests)
        e.resolve({
          value: void 0,
          done: !0
        });
      this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
    }
  }
  class J0 {
    constructor(t, e, s) {
      this._manager = t;
      const a = {
        onDone: this._onDone.bind(this),
        onError: this._onError.bind(this),
        onProgress: this._onProgress.bind(this)
      };
      this._url = t.url, this._requestId = t.requestRange(e, s, a), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
    }
    _close() {
      var t;
      (t = this.onClosed) == null || t.call(this, this);
    }
    _onDone(t) {
      const e = t.chunk;
      this._requests.length > 0 ? this._requests.shift().resolve({
        value: e,
        done: !1
      }) : this._queuedChunk = e, this._done = !0;
      for (const s of this._requests)
        s.resolve({
          value: void 0,
          done: !0
        });
      this._requests.length = 0, this._close();
    }
    _onError(t) {
      this._storedError = ku(t, this._url);
      for (const e of this._requests)
        e.reject(this._storedError);
      this._requests.length = 0, this._queuedChunk = null;
    }
    _onProgress(t) {
      var e;
      this.isStreamingSupported || (e = this.onProgress) == null || e.call(this, {
        loaded: t.loaded
      });
    }
    get isStreamingSupported() {
      return !1;
    }
    async read() {
      if (this._storedError)
        throw this._storedError;
      if (this._queuedChunk !== null) {
        const e = this._queuedChunk;
        return this._queuedChunk = null, {
          value: e,
          done: !1
        };
      }
      if (this._done)
        return {
          value: void 0,
          done: !0
        };
      const t = Promise.withResolvers();
      return this._requests.push(t), t.promise;
    }
    cancel(t) {
      this._done = !0;
      for (const e of this._requests)
        e.resolve({
          value: void 0,
          done: !0
        });
      this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
    }
  }
  const Gb = /^file:\/\/\/[a-zA-Z]:\//;
  function q0(A) {
    const t = Es.get("url"), e = t.parse(A);
    return e.protocol === "file:" || e.host ? e : /^[a-z]:[/\\]/i.test(A) ? t.parse(`file:///${A}`) : (e.host || (e.protocol = "file:"), e);
  }
  class tw {
    constructor(t) {
      this.source = t, this.url = q0(t.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && t.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
    }
    get _progressiveDataLength() {
      var t;
      return ((t = this._fullRequestReader) == null ? void 0 : t._loaded) ?? 0;
    }
    getFullReader() {
      return B(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new iw(this) : new ew(this), this._fullRequestReader;
    }
    getRangeReader(t, e) {
      if (e <= this._progressiveDataLength)
        return null;
      const s = this.isFsUrl ? new nw(this, t, e) : new sw(this, t, e);
      return this._rangeRequestReaders.push(s), s;
    }
    cancelAllRequests(t) {
      var e;
      (e = this._fullRequestReader) == null || e.cancel(t);
      for (const s of this._rangeRequestReaders.slice(0))
        s.cancel(t);
    }
  }
  class Xb {
    constructor(t) {
      this._url = t.url, this._done = !1, this._storedError = null, this.onProgress = null;
      const e = t.source;
      this._contentLength = e.length, this._loaded = 0, this._filename = null, this._disableRange = e.disableRange || !1, this._rangeChunkSize = e.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !e.disableStream, this._isRangeSupported = !e.disableRange, this._readableStream = null, this._readCapability = Promise.withResolvers(), this._headersCapability = Promise.withResolvers();
    }
    get headersReady() {
      return this._headersCapability.promise;
    }
    get filename() {
      return this._filename;
    }
    get contentLength() {
      return this._contentLength;
    }
    get isRangeSupported() {
      return this._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      var s;
      if (await this._readCapability.promise, this._done)
        return {
          value: void 0,
          done: !0
        };
      if (this._storedError)
        throw this._storedError;
      const t = this._readableStream.read();
      return t === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += t.length, (s = this.onProgress) == null || s.call(this, {
        loaded: this._loaded,
        total: this._contentLength
      }), {
        value: new Uint8Array(t).buffer,
        done: !1
      });
    }
    cancel(t) {
      if (!this._readableStream) {
        this._error(t);
        return;
      }
      this._readableStream.destroy(t);
    }
    _error(t) {
      this._storedError = t, this._readCapability.resolve();
    }
    _setReadableStream(t) {
      this._readableStream = t, t.on("readable", () => {
        this._readCapability.resolve();
      }), t.on("end", () => {
        t.destroy(), this._done = !0, this._readCapability.resolve();
      }), t.on("error", (e) => {
        this._error(e);
      }), !this._isStreamingSupported && this._isRangeSupported && this._error(new Ft("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
    }
  }
  class Kb {
    constructor(t) {
      this._url = t.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = Promise.withResolvers();
      const e = t.source;
      this._isStreamingSupported = !e.disableStream;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      var s;
      if (await this._readCapability.promise, this._done)
        return {
          value: void 0,
          done: !0
        };
      if (this._storedError)
        throw this._storedError;
      const t = this._readableStream.read();
      return t === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += t.length, (s = this.onProgress) == null || s.call(this, {
        loaded: this._loaded
      }), {
        value: new Uint8Array(t).buffer,
        done: !1
      });
    }
    cancel(t) {
      if (!this._readableStream) {
        this._error(t);
        return;
      }
      this._readableStream.destroy(t);
    }
    _error(t) {
      this._storedError = t, this._readCapability.resolve();
    }
    _setReadableStream(t) {
      this._readableStream = t, t.on("readable", () => {
        this._readCapability.resolve();
      }), t.on("end", () => {
        t.destroy(), this._done = !0, this._readCapability.resolve();
      }), t.on("error", (e) => {
        this._error(e);
      }), this._storedError && this._readableStream.destroy(this._storedError);
    }
  }
  function Du(A, t) {
    return {
      protocol: A.protocol,
      auth: A.auth,
      host: A.hostname,
      port: A.port,
      path: A.path,
      method: "GET",
      headers: t
    };
  }
  class ew extends Xb {
    constructor(t) {
      super(t);
      const e = (s) => {
        if (s.statusCode === 404) {
          const c = new Et(`Missing PDF "${this._url}".`);
          this._storedError = c, this._headersCapability.reject(c);
          return;
        }
        this._headersCapability.resolve(), this._setReadableStream(s);
        const a = (c) => this._readableStream.headers[c.toLowerCase()], {
          allowRangeRequests: o,
          suggestedLength: h
        } = gm({
          getResponseHeader: a,
          isHttp: t.isHttp,
          rangeChunkSize: this._rangeChunkSize,
          disableRange: this._disableRange
        });
        this._isRangeSupported = o, this._contentLength = h || this._contentLength, this._filename = mm(a);
      };
      if (this._request = null, this._url.protocol === "http:") {
        const s = Es.get("http");
        this._request = s.request(Du(this._url, t.httpHeaders), e);
      } else {
        const s = Es.get("https");
        this._request = s.request(Du(this._url, t.httpHeaders), e);
      }
      this._request.on("error", (s) => {
        this._storedError = s, this._headersCapability.reject(s);
      }), this._request.end();
    }
  }
  class sw extends Kb {
    constructor(t, e, s) {
      super(t), this._httpHeaders = {};
      for (const o in t.httpHeaders) {
        const h = t.httpHeaders[o];
        h !== void 0 && (this._httpHeaders[o] = h);
      }
      this._httpHeaders.Range = `bytes=${e}-${s - 1}`;
      const a = (o) => {
        if (o.statusCode === 404) {
          const h = new Et(`Missing PDF "${this._url}".`);
          this._storedError = h;
          return;
        }
        this._setReadableStream(o);
      };
      if (this._request = null, this._url.protocol === "http:") {
        const o = Es.get("http");
        this._request = o.request(Du(this._url, this._httpHeaders), a);
      } else {
        const o = Es.get("https");
        this._request = o.request(Du(this._url, this._httpHeaders), a);
      }
      this._request.on("error", (o) => {
        this._storedError = o;
      }), this._request.end();
    }
  }
  class iw extends Xb {
    constructor(t) {
      super(t);
      let e = decodeURIComponent(this._url.path);
      Gb.test(this._url.href) && (e = e.replace(/^\//, ""));
      const s = Es.get("fs");
      s.promises.lstat(e).then((a) => {
        this._contentLength = a.size, this._setReadableStream(s.createReadStream(e)), this._headersCapability.resolve();
      }, (a) => {
        a.code === "ENOENT" && (a = new Et(`Missing PDF "${e}".`)), this._storedError = a, this._headersCapability.reject(a);
      });
    }
  }
  class nw extends Kb {
    constructor(t, e, s) {
      super(t);
      let a = decodeURIComponent(this._url.path);
      Gb.test(this._url.href) && (a = a.replace(/^\//, ""));
      const o = Es.get("fs");
      this._setReadableStream(o.createReadStream(a, {
        start: e,
        end: s - 1
      }));
    }
  }
  const rw = 1e5, Me = 30, aw = 0.8, Qe = class Qe {
    constructor({
      textContentSource: t,
      container: e,
      viewport: s
    }) {
      v(this, wf);
      v(this, Sf);
      v(this, Xh);
      v(this, Ji, Promise.withResolvers());
      v(this, ke, null);
      v(this, Hh, !1);
      v(this, Vh, !!((ly = globalThis.FontInspector) != null && ly.enabled));
      v(this, dr, null);
      v(this, ci, null);
      v(this, $h, 0);
      v(this, Uh, 0);
      v(this, ur, null);
      v(this, Ja, null);
      v(this, qa, 0);
      v(this, qi, 0);
      v(this, to, /* @__PURE__ */ Object.create(null));
      v(this, zh, []);
      v(this, eo, null);
      v(this, fr, []);
      v(this, Wh, /* @__PURE__ */ new WeakMap());
      v(this, Gh, null);
      if (t instanceof ReadableStream)
        x(this, eo, t);
      else if (typeof t == "object")
        x(this, eo, new ReadableStream({
          start(p) {
            p.enqueue(t), p.close();
          }
        }));
      else
        throw new Error('No "textContentSource" parameter specified.');
      x(this, ke, x(this, Ja, e)), x(this, qi, s.scale * (globalThis.devicePixelRatio || 1)), x(this, qa, s.rotation), x(this, ci, {
        prevFontSize: null,
        prevFontFamily: null,
        div: null,
        properties: null,
        ctx: null
      });
      const {
        pageWidth: a,
        pageHeight: o,
        pageX: h,
        pageY: c
      } = s.rawDims;
      x(this, Gh, [1, 0, 0, -1, -h, c + o]), x(this, Uh, a), x(this, $h, o), jn(e, s), r(this, Ji).promise.catch(() => {
      }).then(() => {
        r(Qe, so).delete(this), x(this, ci, null), x(this, to, null);
      });
    }
    render() {
      const t = () => {
        r(this, ur).read().then(({
          value: e,
          done: s
        }) => {
          if (s) {
            r(this, Ji).resolve();
            return;
          }
          r(this, dr) ?? x(this, dr, e.lang), Object.assign(r(this, to), e.styles), E(this, wf, wA).call(this, e.items), t();
        }, r(this, Ji).reject);
      };
      return x(this, ur, r(this, eo).getReader()), r(Qe, so).add(this), t(), r(this, Ji).promise;
    }
    update({
      viewport: t,
      onBefore: e = null
    }) {
      var o;
      const s = t.scale * (globalThis.devicePixelRatio || 1), a = t.rotation;
      if (a !== r(this, qa) && (e == null || e(), x(this, qa, a), jn(r(this, Ja), {
        rotation: a
      })), s !== r(this, qi)) {
        e == null || e(), x(this, qi, s);
        const h = {
          prevFontSize: null,
          prevFontFamily: null,
          div: null,
          properties: null,
          ctx: E(o = Qe, io, Np).call(o, r(this, dr))
        };
        for (const c of r(this, fr))
          h.properties = r(this, Wh).get(c), h.div = c, E(this, Xh, fv).call(this, h);
      }
    }
    cancel() {
      var e;
      const t = new Ft("TextLayer task cancelled.");
      (e = r(this, ur)) == null || e.cancel(t).catch(() => {
      }), x(this, ur, null), r(this, Ji).reject(t);
    }
    get textDivs() {
      return r(this, fr);
    }
    get textContentItemsStr() {
      return r(this, zh);
    }
    static cleanup() {
      if (!(r(this, so).size > 0)) {
        r(this, pr).clear();
        for (const {
          canvas: t
        } of r(this, gr).values())
          t.remove();
        r(this, gr).clear();
      }
    }
  };
  Ji = new WeakMap(), ke = new WeakMap(), Hh = new WeakMap(), Vh = new WeakMap(), dr = new WeakMap(), ci = new WeakMap(), $h = new WeakMap(), Uh = new WeakMap(), ur = new WeakMap(), Ja = new WeakMap(), qa = new WeakMap(), qi = new WeakMap(), to = new WeakMap(), zh = new WeakMap(), eo = new WeakMap(), fr = new WeakMap(), Wh = new WeakMap(), Gh = new WeakMap(), pr = new WeakMap(), gr = new WeakMap(), so = new WeakMap(), wf = new WeakSet(), wA = function(t) {
    var a, o;
    if (r(this, Hh))
      return;
    (o = r(this, ci)).ctx || (o.ctx = E(a = Qe, io, Np).call(a, r(this, dr)));
    const e = r(this, fr), s = r(this, zh);
    for (const h of t) {
      if (e.length > rw) {
        j("Ignoring additional textDivs for performance reasons."), x(this, Hh, !0);
        return;
      }
      if (h.str === void 0) {
        if (h.type === "beginMarkedContentProps" || h.type === "beginMarkedContent") {
          const c = r(this, ke);
          x(this, ke, document.createElement("span")), r(this, ke).classList.add("markedContent"), h.id !== null && r(this, ke).setAttribute("id", `${h.id}`), c.append(r(this, ke));
        } else
          h.type === "endMarkedContent" && x(this, ke, r(this, ke).parentNode);
        continue;
      }
      s.push(h.str), E(this, Sf, SA).call(this, h);
    }
  }, Sf = new WeakSet(), SA = function(t) {
    var M;
    const e = document.createElement("span"), s = {
      angle: 0,
      canvasWidth: 0,
      hasText: t.str !== "",
      hasEOL: t.hasEOL,
      fontSize: 0
    };
    r(this, fr).push(e);
    const a = et.transform(r(this, Gh), t.transform);
    let o = Math.atan2(a[1], a[0]);
    const h = r(this, to)[t.fontName];
    h.vertical && (o += Math.PI / 2);
    const c = r(this, Vh) && h.fontSubstitution || h.fontFamily, p = Math.hypot(a[2], a[3]), g = p * E(M = Qe, xf, xA).call(M, c, r(this, dr));
    let b, S;
    o === 0 ? (b = a[4], S = a[5] - g) : (b = a[4] + g * Math.sin(o), S = a[5] - g * Math.cos(o));
    const T = "calc(var(--scale-factor)*", C = e.style;
    r(this, ke) === r(this, Ja) ? (C.left = `${(100 * b / r(this, Uh)).toFixed(2)}%`, C.top = `${(100 * S / r(this, $h)).toFixed(2)}%`) : (C.left = `${T}${b.toFixed(2)}px)`, C.top = `${T}${S.toFixed(2)}px)`), C.fontSize = `${T}${p.toFixed(2)}px)`, C.fontFamily = c, s.fontSize = p, e.setAttribute("role", "presentation"), e.textContent = t.str, e.dir = t.dir, r(this, Vh) && (e.dataset.fontName = h.fontSubstitutionLoadedName || t.fontName), o !== 0 && (s.angle = o * (180 / Math.PI));
    let R = !1;
    if (t.str.length > 1)
      R = !0;
    else if (t.str !== " " && t.transform[0] !== t.transform[3]) {
      const F = Math.abs(t.transform[0]), O = Math.abs(t.transform[3]);
      F !== O && Math.max(F, O) / Math.min(F, O) > 1.5 && (R = !0);
    }
    if (R && (s.canvasWidth = h.vertical ? t.height : t.width), r(this, Wh).set(e, s), r(this, ci).div = e, r(this, ci).properties = s, E(this, Xh, fv).call(this, r(this, ci)), s.hasText && r(this, ke).append(e), s.hasEOL) {
      const F = document.createElement("br");
      F.setAttribute("role", "presentation"), r(this, ke).append(F);
    }
  }, Xh = new WeakSet(), fv = function(t) {
    const {
      div: e,
      properties: s,
      ctx: a,
      prevFontSize: o,
      prevFontFamily: h
    } = t, {
      style: c
    } = e;
    let p = "";
    if (s.canvasWidth !== 0 && s.hasText) {
      const {
        fontFamily: g
      } = c, {
        canvasWidth: b,
        fontSize: S
      } = s;
      (o !== S || h !== g) && (a.font = `${S * r(this, qi)}px ${g}`, t.prevFontSize = S, t.prevFontFamily = g);
      const {
        width: T
      } = a.measureText(e.textContent);
      T > 0 && (p = `scaleX(${b * r(this, qi) / T})`);
    }
    s.angle !== 0 && (p = `rotate(${s.angle}deg) ${p}`), p.length > 0 && (c.transform = p);
  }, io = new WeakSet(), Np = function(t = null) {
    let e = r(this, gr).get(t || (t = ""));
    if (!e) {
      const s = document.createElement("canvas");
      s.className = "hiddenCanvasElement", s.lang = t, document.body.append(s), e = s.getContext("2d", {
        alpha: !1
      }), r(this, gr).set(t, e);
    }
    return e;
  }, xf = new WeakSet(), xA = function(t, e) {
    const s = r(this, pr).get(t);
    if (s)
      return s;
    const a = E(this, io, Np).call(this, e), o = a.font;
    a.canvas.width = a.canvas.height = Me, a.font = `${Me}px ${t}`;
    const h = a.measureText("");
    let c = h.fontBoundingBoxAscent, p = Math.abs(h.fontBoundingBoxDescent);
    if (c) {
      const S = c / (c + p);
      return r(this, pr).set(t, S), a.canvas.width = a.canvas.height = 0, a.font = o, S;
    }
    a.strokeStyle = "red", a.clearRect(0, 0, Me, Me), a.strokeText("g", 0, 0);
    let g = a.getImageData(0, 0, Me, Me).data;
    p = 0;
    for (let S = g.length - 1 - 3; S >= 0; S -= 4)
      if (g[S] > 0) {
        p = Math.ceil(S / 4 / Me);
        break;
      }
    a.clearRect(0, 0, Me, Me), a.strokeText("A", 0, Me), g = a.getImageData(0, 0, Me, Me).data, c = 0;
    for (let S = 0, T = g.length; S < T; S += 4)
      if (g[S] > 0) {
        c = Me - Math.floor(S / 4 / Me);
        break;
      }
    a.canvas.width = a.canvas.height = 0, a.font = o;
    const b = c ? c / (c + p) : aw;
    return r(this, pr).set(t, b), b;
  }, v(Qe, io), v(Qe, xf), v(Qe, pr, /* @__PURE__ */ new Map()), v(Qe, gr, /* @__PURE__ */ new Map()), v(Qe, so, /* @__PURE__ */ new Set());
  let Ra = Qe;
  function ow() {
    xb("`renderTextLayer`, please use `TextLayer` instead.");
    const {
      textContentSource: A,
      container: t,
      viewport: e,
      ...s
    } = arguments[0], a = Object.keys(s);
    a.length > 0 && j("Ignoring `renderTextLayer` parameters: " + a.join(", "));
    const o = new Ra({
      textContentSource: A,
      container: t,
      viewport: e
    }), {
      textDivs: h,
      textContentItemsStr: c
    } = o;
    return {
      promise: o.render(),
      textDivs: h,
      textContentItemsStr: c
    };
  }
  function lw() {
    xb("`updateTextLayer`, please use `TextLayer` instead.");
  }
  class Dl {
    static textContent(t) {
      const e = [], s = {
        items: e,
        styles: /* @__PURE__ */ Object.create(null)
      };
      function a(o) {
        var p;
        if (!o)
          return;
        let h = null;
        const c = o.name;
        if (c === "#text")
          h = o.value;
        else if (Dl.shouldBuildText(c))
          (p = o == null ? void 0 : o.attributes) != null && p.textContent ? h = o.attributes.textContent : o.value && (h = o.value);
        else
          return;
        if (h !== null && e.push({
          str: h
        }), !!o.children)
          for (const g of o.children)
            a(g);
      }
      return a(t), s;
    }
    static shouldBuildText(t) {
      return !(t === "textarea" || t === "input" || t === "option" || t === "select");
    }
  }
  const hw = 65536, cw = 100, dw = 5e3, uw = u ? S0 : c0, fw = u ? x0 : Eb, pw = u ? w0 : h0, gw = u ? P0 : wb;
  function mw(A) {
    if (typeof A == "string" || A instanceof URL ? A = {
      url: A
    } : (A instanceof ArrayBuffer || ArrayBuffer.isView(A)) && (A = {
      data: A
    }), typeof A != "object")
      throw new Error("Invalid parameter in getDocument, need parameter object.");
    if (!A.url && !A.data && !A.range)
      throw new Error("Invalid parameter object: need either .data, .range or .url");
    const t = new ym(), {
      docId: e
    } = t, s = A.url ? vw(A.url) : null, a = A.data ? bw(A.data) : null, o = A.httpHeaders || null, h = A.withCredentials === !0, c = A.password ?? null, p = A.range instanceof Qb ? A.range : null, g = Number.isInteger(A.rangeChunkSize) && A.rangeChunkSize > 0 ? A.rangeChunkSize : hw;
    let b = A.worker instanceof Ia ? A.worker : null;
    const S = A.verbosity, T = typeof A.docBaseUrl == "string" && !im(A.docBaseUrl) ? A.docBaseUrl : null, C = typeof A.cMapUrl == "string" ? A.cMapUrl : null, R = A.cMapPacked !== !1, M = A.CMapReaderFactory || fw, F = typeof A.standardFontDataUrl == "string" ? A.standardFontDataUrl : null, O = A.StandardFontDataFactory || gw, U = A.stopAtErrors !== !0, Y = Number.isInteger(A.maxImageSize) && A.maxImageSize > -1 ? A.maxImageSize : -1, J = A.isEvalSupported !== !1, rt = typeof A.isOffscreenCanvasSupported == "boolean" ? A.isOffscreenCanvasSupported : !u, st = Number.isInteger(A.canvasMaxAreaInBytes) ? A.canvasMaxAreaInBytes : -1, ot = typeof A.disableFontFace == "boolean" ? A.disableFontFace : u, ft = A.fontExtraProperties === !0, yt = A.enableXfa === !0, St = A.ownerDocument || globalThis.document, gt = A.disableRange === !0, Wt = A.disableStream === !0, Dt = A.disableAutoFetch === !0, $t = A.pdfBug === !0, Ut = p ? p.length : A.length ?? NaN, Ce = typeof A.useSystemFonts == "boolean" ? A.useSystemFonts : !u && !ot, mt = typeof A.useWorkerFetch == "boolean" ? A.useWorkerFetch : M === Eb && O === wb && C && F && Il(C, document.baseURI) && Il(F, document.baseURI), At = A.canvasFactory || new uw({
      ownerDocument: St
    }), Sp = A.filterFactory || new pw({
      docId: e,
      ownerDocument: St
    }), xp = null;
    Z(S);
    const Ko = {
      canvasFactory: At,
      filterFactory: Sp
    };
    if (mt || (Ko.cMapReaderFactory = new M({
      baseUrl: C,
      isCompressed: R
    }), Ko.standardFontDataFactory = new O({
      baseUrl: F
    })), !b) {
      const mn = {
        verbosity: S,
        port: Qs.workerPort
      };
      b = mn.port ? Ia.fromPort(mn) : new Ia(mn), t._worker = b;
    }
    const ze = {
      docId: e,
      apiVersion: "4.3.136",
      data: a,
      password: c,
      disableAutoFetch: Dt,
      rangeChunkSize: g,
      length: Ut,
      docBaseUrl: T,
      enableXfa: yt,
      evaluatorOptions: {
        maxImageSize: Y,
        disableFontFace: ot,
        ignoreErrors: U,
        isEvalSupported: J,
        isOffscreenCanvasSupported: rt,
        canvasMaxAreaInBytes: st,
        fontExtraProperties: ft,
        useSystemFonts: Ce,
        cMapUrl: mt ? C : null,
        standardFontDataUrl: mt ? F : null
      }
    }, me = {
      disableFontFace: ot,
      fontExtraProperties: ft,
      ownerDocument: St,
      pdfBug: $t,
      styleElement: xp,
      loadingParams: {
        disableAutoFetch: Dt,
        enableXfa: yt
      }
    };
    return b.promise.then(function() {
      if (t.destroyed)
        throw new Error("Loading aborted");
      if (b.destroyed)
        throw new Error("Worker was destroyed");
      const mn = b.messageHandler.sendWithPromise("GetDocRequest", ze, a ? [a.buffer] : null);
      let ad;
      return p ? ad = new $0(p, {
        disableRange: gt,
        disableStream: Wt
      }) : a || (ad = ((Nt) => u ? function() {
        return typeof fetch < "u" && typeof Response < "u" && "body" in Response.prototype;
      }() && Il(Nt.url) ? new Wb(Nt) : new tw(Nt) : Il(Nt.url) ? new Wb(Nt) : new Q0(Nt))({
        url: s,
        length: Ut,
        httpHeaders: o,
        withCredentials: h,
        rangeChunkSize: g,
        disableRange: gt,
        disableStream: Wt
      })), mn.then((Jr) => {
        if (t.destroyed)
          throw new Error("Loading aborted");
        if (b.destroyed)
          throw new Error("Worker was destroyed");
        const Nt = new kl(e, Jr, b.port), hy = new ww(Nt, t, ad, me, Ko);
        t._transport = hy, Nt.send("Ready", null);
      });
    }).catch(t._capability.reject), t;
  }
  function vw(A) {
    if (A instanceof URL)
      return A.href;
    try {
      return new URL(A, window.location).href;
    } catch {
      if (u && typeof A == "string")
        return A;
    }
    throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
  }
  function bw(A) {
    if (u && typeof Buffer < "u" && A instanceof Buffer)
      throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
    if (A instanceof Uint8Array && A.byteLength === A.buffer.byteLength)
      return A;
    if (typeof A == "string")
      return be(A);
    if (A instanceof ArrayBuffer || ArrayBuffer.isView(A) || typeof A == "object" && !isNaN(A == null ? void 0 : A.length))
      return new Uint8Array(A);
    throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
  }
  function Yb(A) {
    return typeof A == "object" && Number.isInteger(A == null ? void 0 : A.num) && A.num >= 0 && Number.isInteger(A == null ? void 0 : A.gen) && A.gen >= 0;
  }
  const Tf = class Tf {
    constructor() {
      this._capability = Promise.withResolvers(), this._transport = null, this._worker = null, this.docId = `d${De(Tf, Pf)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
    }
    get promise() {
      return this._capability.promise;
    }
    async destroy() {
      var t, e, s;
      this.destroyed = !0;
      try {
        (t = this._worker) != null && t.port && (this._worker._pendingDestroy = !0), await ((e = this._transport) == null ? void 0 : e.destroy());
      } catch (a) {
        throw (s = this._worker) != null && s.port && delete this._worker._pendingDestroy, a;
      }
      this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
    }
  };
  Pf = new WeakMap(), v(Tf, Pf, 0);
  let ym = Tf;
  class Qb {
    constructor(t, e, s = !1, a = null) {
      this.length = t, this.initialData = e, this.progressiveDone = s, this.contentDispositionFilename = a, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = Promise.withResolvers();
    }
    addRangeListener(t) {
      this._rangeListeners.push(t);
    }
    addProgressListener(t) {
      this._progressListeners.push(t);
    }
    addProgressiveReadListener(t) {
      this._progressiveReadListeners.push(t);
    }
    addProgressiveDoneListener(t) {
      this._progressiveDoneListeners.push(t);
    }
    onDataRange(t, e) {
      for (const s of this._rangeListeners)
        s(t, e);
    }
    onDataProgress(t, e) {
      this._readyCapability.promise.then(() => {
        for (const s of this._progressListeners)
          s(t, e);
      });
    }
    onDataProgressiveRead(t) {
      this._readyCapability.promise.then(() => {
        for (const e of this._progressiveReadListeners)
          e(t);
      });
    }
    onDataProgressiveDone() {
      this._readyCapability.promise.then(() => {
        for (const t of this._progressiveDoneListeners)
          t();
      });
    }
    transportReady() {
      this._readyCapability.resolve();
    }
    requestDataRange(t, e) {
      Q("Abstract method PDFDataRangeTransport.requestDataRange");
    }
    abort() {
    }
  }
  class yw {
    constructor(t, e) {
      this._pdfInfo = t, this._transport = e;
    }
    get annotationStorage() {
      return this._transport.annotationStorage;
    }
    get filterFactory() {
      return this._transport.filterFactory;
    }
    get numPages() {
      return this._pdfInfo.numPages;
    }
    get fingerprints() {
      return this._pdfInfo.fingerprints;
    }
    get isPureXfa() {
      return tt(this, "isPureXfa", !!this._transport._htmlForXfa);
    }
    get allXfaHtml() {
      return this._transport._htmlForXfa;
    }
    getPage(t) {
      return this._transport.getPage(t);
    }
    getPageIndex(t) {
      return this._transport.getPageIndex(t);
    }
    getDestinations() {
      return this._transport.getDestinations();
    }
    getDestination(t) {
      return this._transport.getDestination(t);
    }
    getPageLabels() {
      return this._transport.getPageLabels();
    }
    getPageLayout() {
      return this._transport.getPageLayout();
    }
    getPageMode() {
      return this._transport.getPageMode();
    }
    getViewerPreferences() {
      return this._transport.getViewerPreferences();
    }
    getOpenAction() {
      return this._transport.getOpenAction();
    }
    getAttachments() {
      return this._transport.getAttachments();
    }
    getJSActions() {
      return this._transport.getDocJSActions();
    }
    getOutline() {
      return this._transport.getOutline();
    }
    getOptionalContentConfig({
      intent: t = "display"
    } = {}) {
      const {
        renderingIntent: e
      } = this._transport.getRenderingIntent(t);
      return this._transport.getOptionalContentConfig(e);
    }
    getPermissions() {
      return this._transport.getPermissions();
    }
    getMetadata() {
      return this._transport.getMetadata();
    }
    getMarkInfo() {
      return this._transport.getMarkInfo();
    }
    getData() {
      return this._transport.getData();
    }
    saveDocument() {
      return this._transport.saveDocument();
    }
    getDownloadInfo() {
      return this._transport.downloadInfoCapability.promise;
    }
    cleanup(t = !1) {
      return this._transport.startCleanup(t || this.isPureXfa);
    }
    destroy() {
      return this.loadingTask.destroy();
    }
    cachedPageNumber(t) {
      return this._transport.cachedPageNumber(t);
    }
    get loadingParams() {
      return this._transport.loadingParams;
    }
    get loadingTask() {
      return this._transport.loadingTask;
    }
    getFieldObjects() {
      return this._transport.getFieldObjects();
    }
    hasJSActions() {
      return this._transport.hasJSActions();
    }
    getCalculationOrderIds() {
      return this._transport.getCalculationOrderIds();
    }
  }
  class Aw {
    constructor(t, e, s, a = !1) {
      v(this, en);
      v(this, no);
      v(this, tn, null);
      v(this, di, !1);
      this._pageIndex = t, this._pageInfo = e, this._transport = s, this._stats = a ? new Sb() : null, this._pdfBug = a, this.commonObjs = s.commonObjs, this.objs = new Zb(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
    }
    get pageNumber() {
      return this._pageIndex + 1;
    }
    get rotate() {
      return this._pageInfo.rotate;
    }
    get ref() {
      return this._pageInfo.ref;
    }
    get userUnit() {
      return this._pageInfo.userUnit;
    }
    get view() {
      return this._pageInfo.view;
    }
    getViewport({
      scale: t,
      rotation: e = this.rotate,
      offsetX: s = 0,
      offsetY: a = 0,
      dontFlip: o = !1
    } = {}) {
      return new Rl({
        viewBox: this.view,
        scale: t,
        rotation: e,
        offsetX: s,
        offsetY: a,
        dontFlip: o
      });
    }
    getAnnotations({
      intent: t = "display"
    } = {}) {
      const {
        renderingIntent: e
      } = this._transport.getRenderingIntent(t);
      return this._transport.getAnnotations(this._pageIndex, e);
    }
    getJSActions() {
      return this._transport.getPageJSActions(this._pageIndex);
    }
    get filterFactory() {
      return this._transport.filterFactory;
    }
    get isPureXfa() {
      return tt(this, "isPureXfa", !!this._transport._htmlForXfa);
    }
    async getXfa() {
      var t;
      return ((t = this._transport._htmlForXfa) == null ? void 0 : t.children[this._pageIndex]) || null;
    }
    render({
      canvasContext: t,
      viewport: e,
      intent: s = "display",
      annotationMode: a = m.ENABLE,
      transform: o = null,
      background: h = null,
      optionalContentConfigPromise: c = null,
      annotationCanvasMap: p = null,
      pageColors: g = null,
      printAnnotationStorage: b = null
    }) {
      var Y, J;
      (Y = this._stats) == null || Y.time("Overall");
      const S = this._transport.getRenderingIntent(s, a, b), {
        renderingIntent: T,
        cacheKey: C
      } = S;
      x(this, di, !1), E(this, no, Fp).call(this), c || (c = this._transport.getOptionalContentConfig(T));
      let R = this._intentStates.get(C);
      R || (R = /* @__PURE__ */ Object.create(null), this._intentStates.set(C, R)), R.streamReaderCancelTimeout && (clearTimeout(R.streamReaderCancelTimeout), R.streamReaderCancelTimeout = null);
      const M = !!(T & f.PRINT);
      R.displayReadyCapability || (R.displayReadyCapability = Promise.withResolvers(), R.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: !1,
        separateAnnots: null
      }, (J = this._stats) == null || J.time("Page Request"), this._pumpOperatorList(S));
      const F = (rt) => {
        var st;
        R.renderTasks.delete(O), (this._maybeCleanupAfterRender || M) && x(this, di, !0), E(this, en, Jo).call(this, !M), rt ? (O.capability.reject(rt), this._abortOperatorList({
          intentState: R,
          reason: rt instanceof Error ? rt : new Error(rt)
        })) : O.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"), (st = globalThis.Stats) != null && st.enabled && globalThis.Stats.add(this.pageNumber, this._stats));
      }, O = new Am({
        callback: F,
        params: {
          canvasContext: t,
          viewport: e,
          transform: o,
          background: h
        },
        objs: this.objs,
        commonObjs: this.commonObjs,
        annotationCanvasMap: p,
        operatorList: R.operatorList,
        pageIndex: this._pageIndex,
        canvasFactory: this._transport.canvasFactory,
        filterFactory: this._transport.filterFactory,
        useRequestAnimationFrame: !M,
        pdfBug: this._pdfBug,
        pageColors: g
      });
      (R.renderTasks || (R.renderTasks = /* @__PURE__ */ new Set())).add(O);
      const U = O.task;
      return Promise.all([R.displayReadyCapability.promise, c]).then(([rt, st]) => {
        var ot;
        if (this.destroyed) {
          F();
          return;
        }
        if ((ot = this._stats) == null || ot.time("Rendering"), !(st.renderingIntent & T))
          throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
        O.initializeGraphics({
          transparency: rt,
          optionalContentConfig: st
        }), O.operatorListChanged();
      }).catch(F), U;
    }
    getOperatorList({
      intent: t = "display",
      annotationMode: e = m.ENABLE,
      printAnnotationStorage: s = null
    } = {}) {
      var p;
      function a() {
        h.operatorList.lastChunk && (h.opListReadCapability.resolve(h.operatorList), h.renderTasks.delete(c));
      }
      const o = this._transport.getRenderingIntent(t, e, s, !0);
      let h = this._intentStates.get(o.cacheKey);
      h || (h = /* @__PURE__ */ Object.create(null), this._intentStates.set(o.cacheKey, h));
      let c;
      return h.opListReadCapability || (c = /* @__PURE__ */ Object.create(null), c.operatorListChanged = a, h.opListReadCapability = Promise.withResolvers(), (h.renderTasks || (h.renderTasks = /* @__PURE__ */ new Set())).add(c), h.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: !1,
        separateAnnots: null
      }, (p = this._stats) == null || p.time("Page Request"), this._pumpOperatorList(o)), h.opListReadCapability.promise;
    }
    streamTextContent({
      includeMarkedContent: t = !1,
      disableNormalization: e = !1
    } = {}) {
      return this._transport.messageHandler.sendWithStream("GetTextContent", {
        pageIndex: this._pageIndex,
        includeMarkedContent: t === !0,
        disableNormalization: e === !0
      }, {
        highWaterMark: 100,
        size(a) {
          return a.items.length;
        }
      });
    }
    getTextContent(t = {}) {
      if (this._transport._htmlForXfa)
        return this.getXfa().then((s) => Dl.textContent(s));
      const e = this.streamTextContent(t);
      return new Promise(function(s, a) {
        function o() {
          h.read().then(function({
            value: p,
            done: g
          }) {
            if (g) {
              s(c);
              return;
            }
            c.lang ?? (c.lang = p.lang), Object.assign(c.styles, p.styles), c.items.push(...p.items), o();
          }, a);
        }
        const h = e.getReader(), c = {
          items: [],
          styles: /* @__PURE__ */ Object.create(null),
          lang: null
        };
        o();
      });
    }
    getStructTree() {
      return this._transport.getStructTree(this._pageIndex);
    }
    _destroy() {
      this.destroyed = !0;
      const t = [];
      for (const e of this._intentStates.values())
        if (this._abortOperatorList({
          intentState: e,
          reason: new Error("Page was destroyed."),
          force: !0
        }), !e.opListReadCapability)
          for (const s of e.renderTasks)
            t.push(s.completed), s.cancel();
      return this.objs.clear(), x(this, di, !1), E(this, no, Fp).call(this), Promise.all(t);
    }
    cleanup(t = !1) {
      x(this, di, !0);
      const e = E(this, en, Jo).call(this, !1);
      return t && e && this._stats && (this._stats = new Sb()), e;
    }
    _startRenderPage(t, e) {
      var a, o;
      const s = this._intentStates.get(e);
      s && ((a = this._stats) == null || a.timeEnd("Page Request"), (o = s.displayReadyCapability) == null || o.resolve(t));
    }
    _renderPageChunk(t, e) {
      for (let s = 0, a = t.length; s < a; s++)
        e.operatorList.fnArray.push(t.fnArray[s]), e.operatorList.argsArray.push(t.argsArray[s]);
      e.operatorList.lastChunk = t.lastChunk, e.operatorList.separateAnnots = t.separateAnnots;
      for (const s of e.renderTasks)
        s.operatorListChanged();
      t.lastChunk && E(this, en, Jo).call(this, !0);
    }
    _pumpOperatorList({
      renderingIntent: t,
      cacheKey: e,
      annotationStorageSerializable: s
    }) {
      const {
        map: a,
        transfer: o
      } = s, c = this._transport.messageHandler.sendWithStream("GetOperatorList", {
        pageIndex: this._pageIndex,
        intent: t,
        cacheKey: e,
        annotationStorage: a
      }, o).getReader(), p = this._intentStates.get(e);
      p.streamReader = c;
      const g = () => {
        c.read().then(({
          value: b,
          done: S
        }) => {
          if (S) {
            p.streamReader = null;
            return;
          }
          this._transport.destroyed || (this._renderPageChunk(b, p), g());
        }, (b) => {
          if (p.streamReader = null, !this._transport.destroyed) {
            if (p.operatorList) {
              p.operatorList.lastChunk = !0;
              for (const S of p.renderTasks)
                S.operatorListChanged();
              E(this, en, Jo).call(this, !0);
            }
            if (p.displayReadyCapability)
              p.displayReadyCapability.reject(b);
            else if (p.opListReadCapability)
              p.opListReadCapability.reject(b);
            else
              throw b;
          }
        });
      };
      g();
    }
    _abortOperatorList({
      intentState: t,
      reason: e,
      force: s = !1
    }) {
      if (t.streamReader) {
        if (t.streamReaderCancelTimeout && (clearTimeout(t.streamReaderCancelTimeout), t.streamReaderCancelTimeout = null), !s) {
          if (t.renderTasks.size > 0)
            return;
          if (e instanceof sm) {
            let a = cw;
            e.extraDelay > 0 && e.extraDelay < 1e3 && (a += e.extraDelay), t.streamReaderCancelTimeout = setTimeout(() => {
              t.streamReaderCancelTimeout = null, this._abortOperatorList({
                intentState: t,
                reason: e,
                force: !0
              });
            }, a);
            return;
          }
        }
        if (t.streamReader.cancel(new Ft(e.message)).catch(() => {
        }), t.streamReader = null, !this._transport.destroyed) {
          for (const [a, o] of this._intentStates)
            if (o === t) {
              this._intentStates.delete(a);
              break;
            }
          this.cleanup();
        }
      }
    }
    get stats() {
      return this._stats;
    }
  }
  tn = new WeakMap(), di = new WeakMap(), en = new WeakSet(), Jo = function(t = !1) {
    if (E(this, no, Fp).call(this), !r(this, di) || this.destroyed)
      return !1;
    if (t)
      return x(this, tn, setTimeout(() => {
        x(this, tn, null), E(this, en, Jo).call(this, !1);
      }, dw)), !1;
    for (const {
      renderTasks: e,
      operatorList: s
    } of this._intentStates.values())
      if (e.size > 0 || !s.lastChunk)
        return !1;
    return this._intentStates.clear(), this.objs.clear(), x(this, di, !1), !0;
  }, no = new WeakSet(), Fp = function() {
    r(this, tn) && (clearTimeout(r(this, tn)), x(this, tn, null));
  };
  class Ew {
    constructor() {
      v(this, mr, /* @__PURE__ */ new Set());
      v(this, Cf, Promise.resolve());
    }
    postMessage(t, e) {
      const s = {
        data: structuredClone(t, e ? {
          transfer: e
        } : null)
      };
      r(this, Cf).then(() => {
        for (const a of r(this, mr))
          a.call(this, s);
      });
    }
    addEventListener(t, e) {
      r(this, mr).add(e);
    }
    removeEventListener(t, e) {
      r(this, mr).delete(e);
    }
    terminate() {
      r(this, mr).clear();
    }
  }
  mr = new WeakMap(), Cf = new WeakMap();
  const Zs = {
    isWorkerDisabled: !1,
    fakeWorkerId: 0
  };
  u && (Zs.isWorkerDisabled = !0, Qs.workerSrc || (Qs.workerSrc = "./pdf.worker.mjs")), Zs.isSameOrigin = function(A, t) {
    let e;
    try {
      if (e = new URL(A), !e.origin || e.origin === "null")
        return !1;
    } catch {
      return !1;
    }
    const s = new URL(t, e);
    return e.origin === s.origin;
  }, Zs.createCDNWrapper = function(A) {
    const t = `await import("${A}");`;
    return URL.createObjectURL(new Blob([t], {
      type: "text/javascript"
    }));
  };
  const Be = class Be {
    constructor({
      name: t = null,
      port: e = null,
      verbosity: s = K()
    } = {}) {
      var a;
      if (this.name = t, this.destroyed = !1, this.verbosity = s, this._readyCapability = Promise.withResolvers(), this._port = null, this._webWorker = null, this._messageHandler = null, e) {
        if ((a = r(Be, vr)) != null && a.has(e))
          throw new Error("Cannot use more than one PDFWorker per port.");
        (r(Be, vr) || x(Be, vr, /* @__PURE__ */ new WeakMap())).set(e, this), this._initializeFromPort(e);
        return;
      }
      this._initialize();
    }
    get promise() {
      return u ? Promise.all([Es.promise, this._readyCapability.promise]) : this._readyCapability.promise;
    }
    get port() {
      return this._port;
    }
    get messageHandler() {
      return this._messageHandler;
    }
    _initializeFromPort(t) {
      this._port = t, this._messageHandler = new kl("main", "worker", t), this._messageHandler.on("ready", function() {
      }), this._readyCapability.resolve(), this._messageHandler.send("configure", {
        verbosity: this.verbosity
      });
    }
    _initialize() {
      if (!Zs.isWorkerDisabled && !r(Be, ro, Bp)) {
        let {
          workerSrc: t
        } = Be;
        try {
          Zs.isSameOrigin(window.location.href, t) || (t = Zs.createCDNWrapper(new URL(t, window.location).href));
          const e = new Worker(t, {
            type: "module"
          }), s = new kl("main", "worker", e), a = () => {
            e.removeEventListener("error", o), s.destroy(), e.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
          }, o = () => {
            this._webWorker || a();
          };
          e.addEventListener("error", o), s.on("test", (c) => {
            if (e.removeEventListener("error", o), this.destroyed) {
              a();
              return;
            }
            c ? (this._messageHandler = s, this._port = e, this._webWorker = e, this._readyCapability.resolve(), s.send("configure", {
              verbosity: this.verbosity
            })) : (this._setupFakeWorker(), s.destroy(), e.terminate());
          }), s.on("ready", (c) => {
            if (e.removeEventListener("error", o), this.destroyed) {
              a();
              return;
            }
            try {
              h();
            } catch {
              this._setupFakeWorker();
            }
          });
          const h = () => {
            const c = new Uint8Array();
            s.send("test", c, [c.buffer]);
          };
          h();
          return;
        } catch {
          $("The worker has been disabled.");
        }
      }
      this._setupFakeWorker();
    }
    _setupFakeWorker() {
      Zs.isWorkerDisabled || (j("Setting up fake worker."), Zs.isWorkerDisabled = !0), Be._setupFakeWorkerGlobal.then((t) => {
        if (this.destroyed) {
          this._readyCapability.reject(new Error("Worker was destroyed"));
          return;
        }
        const e = new Ew();
        this._port = e;
        const s = `fake${Zs.fakeWorkerId++}`, a = new kl(s + "_worker", s, e);
        t.setup(a, e);
        const o = new kl(s, s + "_worker", e);
        this._messageHandler = o, this._readyCapability.resolve(), o.send("configure", {
          verbosity: this.verbosity
        });
      }).catch((t) => {
        this._readyCapability.reject(new Error(`Setting up fake worker failed: "${t.message}".`));
      });
    }
    destroy() {
      var t;
      this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), (t = r(Be, vr)) == null || t.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
    }
    static fromPort(t) {
      var s;
      if (!(t != null && t.port))
        throw new Error("PDFWorker.fromPort - invalid method signature.");
      const e = (s = r(this, vr)) == null ? void 0 : s.get(t.port);
      if (e) {
        if (e._pendingDestroy)
          throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
        return e;
      }
      return new Be(t);
    }
    static get workerSrc() {
      if (Qs.workerSrc)
        return Qs.workerSrc;
      throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
    }
    static get _setupFakeWorkerGlobal() {
      return tt(this, "_setupFakeWorkerGlobal", (async () => r(this, ro, Bp) ? r(this, ro, Bp) : (await import(
        /*webpackIgnore: true*/
        this.workerSrc
      )).WorkerMessageHandler)());
    }
  };
  vr = new WeakMap(), ro = new WeakSet(), Bp = function() {
    var t;
    try {
      return ((t = globalThis.pdfjsWorker) == null ? void 0 : t.WorkerMessageHandler) || null;
    } catch {
      return null;
    }
  }, v(Be, ro), v(Be, vr, void 0);
  let Ia = Be;
  class ww {
    constructor(t, e, s, a, o) {
      v(this, br);
      v(this, ui, /* @__PURE__ */ new Map());
      v(this, Ls, /* @__PURE__ */ new Map());
      v(this, ao, /* @__PURE__ */ new Map());
      v(this, oo, /* @__PURE__ */ new Map());
      v(this, _s, null);
      this.messageHandler = t, this.loadingTask = e, this.commonObjs = new Zb(), this.fontLoader = new A0({
        ownerDocument: a.ownerDocument,
        styleElement: a.styleElement
      }), this.loadingParams = a.loadingParams, this._params = a, this.canvasFactory = o.canvasFactory, this.filterFactory = o.filterFactory, this.cMapReaderFactory = o.cMapReaderFactory, this.standardFontDataFactory = o.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = s, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = Promise.withResolvers(), this.setupMessageHandler();
    }
    get annotationStorage() {
      return tt(this, "annotationStorage", new cm());
    }
    getRenderingIntent(t, e = m.ENABLE, s = null, a = !1) {
      let o = f.DISPLAY, h = hm;
      switch (t) {
        case "any":
          o = f.ANY;
          break;
        case "display":
          break;
        case "print":
          o = f.PRINT;
          break;
        default:
          j(`getRenderingIntent - invalid intent: ${t}`);
      }
      switch (e) {
        case m.DISABLE:
          o += f.ANNOTATIONS_DISABLE;
          break;
        case m.ENABLE:
          break;
        case m.ENABLE_FORMS:
          o += f.ANNOTATIONS_FORMS;
          break;
        case m.ENABLE_STORAGE:
          o += f.ANNOTATIONS_STORAGE, h = (o & f.PRINT && s instanceof Ib ? s : this.annotationStorage).serializable;
          break;
        default:
          j(`getRenderingIntent - invalid annotationMode: ${e}`);
      }
      return a && (o += f.OPLIST), {
        renderingIntent: o,
        cacheKey: `${o}_${h.hash}`,
        annotationStorageSerializable: h
      };
    }
    destroy() {
      var s;
      if (this.destroyCapability)
        return this.destroyCapability.promise;
      this.destroyed = !0, this.destroyCapability = Promise.withResolvers(), (s = r(this, _s)) == null || s.reject(new Error("Worker was destroyed during onPassword callback"));
      const t = [];
      for (const a of r(this, Ls).values())
        t.push(a._destroy());
      r(this, Ls).clear(), r(this, ao).clear(), r(this, oo).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
      const e = this.messageHandler.sendWithPromise("Terminate", null);
      return t.push(e), Promise.all(t).then(() => {
        var a;
        this.commonObjs.clear(), this.fontLoader.clear(), r(this, ui).clear(), this.filterFactory.destroy(), Ra.cleanup(), (a = this._networkStream) == null || a.cancelAllRequests(new Ft("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
      }, this.destroyCapability.reject), this.destroyCapability.promise;
    }
    setupMessageHandler() {
      const {
        messageHandler: t,
        loadingTask: e
      } = this;
      t.on("GetReader", (s, a) => {
        B(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (o) => {
          this._lastProgress = {
            loaded: o.loaded,
            total: o.total
          };
        }, a.onPull = () => {
          this._fullReader.read().then(function({
            value: o,
            done: h
          }) {
            if (h) {
              a.close();
              return;
            }
            B(o instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), a.enqueue(new Uint8Array(o), 1, [o]);
          }).catch((o) => {
            a.error(o);
          });
        }, a.onCancel = (o) => {
          this._fullReader.cancel(o), a.ready.catch((h) => {
            if (!this.destroyed)
              throw h;
          });
        };
      }), t.on("ReaderHeadersReady", (s) => {
        const a = Promise.withResolvers(), o = this._fullReader;
        return o.headersReady.then(() => {
          var h;
          (!o.isStreamingSupported || !o.isRangeSupported) && (this._lastProgress && ((h = e.onProgress) == null || h.call(e, this._lastProgress)), o.onProgress = (c) => {
            var p;
            (p = e.onProgress) == null || p.call(e, {
              loaded: c.loaded,
              total: c.total
            });
          }), a.resolve({
            isStreamingSupported: o.isStreamingSupported,
            isRangeSupported: o.isRangeSupported,
            contentLength: o.contentLength
          });
        }, a.reject), a.promise;
      }), t.on("GetRangeReader", (s, a) => {
        B(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
        const o = this._networkStream.getRangeReader(s.begin, s.end);
        if (!o) {
          a.close();
          return;
        }
        a.onPull = () => {
          o.read().then(function({
            value: h,
            done: c
          }) {
            if (c) {
              a.close();
              return;
            }
            B(h instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), a.enqueue(new Uint8Array(h), 1, [h]);
          }).catch((h) => {
            a.error(h);
          });
        }, a.onCancel = (h) => {
          o.cancel(h), a.ready.catch((c) => {
            if (!this.destroyed)
              throw c;
          });
        };
      }), t.on("GetDoc", ({
        pdfInfo: s
      }) => {
        this._numPages = s.numPages, this._htmlForXfa = s.htmlForXfa, delete s.htmlForXfa, e._capability.resolve(new yw(s, this));
      }), t.on("DocException", function(s) {
        let a;
        switch (s.name) {
          case "PasswordException":
            a = new vt(s.message, s.code);
            break;
          case "InvalidPDFException":
            a = new W(s.message);
            break;
          case "MissingPDFException":
            a = new Et(s.message);
            break;
          case "UnexpectedResponseException":
            a = new Pt(s.message, s.status);
            break;
          case "UnknownErrorException":
            a = new dt(s.message, s.details);
            break;
          default:
            Q("DocException - expected a valid Error.");
        }
        e._capability.reject(a);
      }), t.on("PasswordRequest", (s) => {
        if (x(this, _s, Promise.withResolvers()), e.onPassword) {
          const a = (o) => {
            o instanceof Error ? r(this, _s).reject(o) : r(this, _s).resolve({
              password: o
            });
          };
          try {
            e.onPassword(a, s.code);
          } catch (o) {
            r(this, _s).reject(o);
          }
        } else
          r(this, _s).reject(new vt(s.message, s.code));
        return r(this, _s).promise;
      }), t.on("DataLoaded", (s) => {
        var a;
        (a = e.onProgress) == null || a.call(e, {
          loaded: s.length,
          total: s.length
        }), this.downloadInfoCapability.resolve(s);
      }), t.on("StartRenderPage", (s) => {
        if (this.destroyed)
          return;
        r(this, Ls).get(s.pageIndex)._startRenderPage(s.transparency, s.cacheKey);
      }), t.on("commonobj", ([s, a, o]) => {
        var h;
        if (this.destroyed || this.commonObjs.has(s))
          return null;
        switch (a) {
          case "Font":
            const {
              disableFontFace: c,
              fontExtraProperties: p,
              pdfBug: g
            } = this._params;
            if ("error" in o) {
              const C = o.error;
              j(`Error during font loading: ${C}`), this.commonObjs.resolve(s, C);
              break;
            }
            const b = g && ((h = globalThis.FontInspector) != null && h.enabled) ? (C, R) => globalThis.FontInspector.fontAdded(C, R) : null, S = new E0(o, {
              disableFontFace: c,
              inspectFont: b
            });
            this.fontLoader.bind(S).catch(() => t.sendWithPromise("FontFallback", {
              id: s
            })).finally(() => {
              !p && S.data && (S.data = null), this.commonObjs.resolve(s, S);
            });
            break;
          case "CopyLocalImage":
            const {
              imageRef: T
            } = o;
            B(T, "The imageRef must be defined.");
            for (const C of r(this, Ls).values())
              for (const [, R] of C.objs)
                if ((R == null ? void 0 : R.ref) === T)
                  return R.dataLen ? (this.commonObjs.resolve(s, structuredClone(R)), R.dataLen) : null;
            break;
          case "FontPath":
          case "Image":
          case "Pattern":
            this.commonObjs.resolve(s, o);
            break;
          default:
            throw new Error(`Got unknown common object type ${a}`);
        }
        return null;
      }), t.on("obj", ([s, a, o, h]) => {
        var p;
        if (this.destroyed)
          return;
        const c = r(this, Ls).get(a);
        if (!c.objs.has(s)) {
          if (c._intentStates.size === 0) {
            (p = h == null ? void 0 : h.bitmap) == null || p.close();
            return;
          }
          switch (o) {
            case "Image":
              c.objs.resolve(s, h), (h == null ? void 0 : h.dataLen) > l && (c._maybeCleanupAfterRender = !0);
              break;
            case "Pattern":
              c.objs.resolve(s, h);
              break;
            default:
              throw new Error(`Got unknown object type ${o}`);
          }
        }
      }), t.on("DocProgress", (s) => {
        var a;
        this.destroyed || (a = e.onProgress) == null || a.call(e, {
          loaded: s.loaded,
          total: s.total
        });
      }), t.on("FetchBuiltInCMap", (s) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(s) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), t.on("FetchStandardFontData", (s) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(s) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
    }
    getData() {
      return this.messageHandler.sendWithPromise("GetData", null);
    }
    saveDocument() {
      var s;
      this.annotationStorage.size <= 0 && j("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
      const {
        map: t,
        transfer: e
      } = this.annotationStorage.serializable;
      return this.messageHandler.sendWithPromise("SaveDocument", {
        isPureXfa: !!this._htmlForXfa,
        numPages: this._numPages,
        annotationStorage: t,
        filename: ((s = this._fullReader) == null ? void 0 : s.filename) ?? null
      }, e).finally(() => {
        this.annotationStorage.resetModified();
      });
    }
    getPage(t) {
      if (!Number.isInteger(t) || t <= 0 || t > this._numPages)
        return Promise.reject(new Error("Invalid page request."));
      const e = t - 1, s = r(this, ao).get(e);
      if (s)
        return s;
      const a = this.messageHandler.sendWithPromise("GetPage", {
        pageIndex: e
      }).then((o) => {
        if (this.destroyed)
          throw new Error("Transport destroyed");
        o.refStr && r(this, oo).set(o.refStr, t);
        const h = new Aw(e, o, this, this._params.pdfBug);
        return r(this, Ls).set(e, h), h;
      });
      return r(this, ao).set(e, a), a;
    }
    getPageIndex(t) {
      return Yb(t) ? this.messageHandler.sendWithPromise("GetPageIndex", {
        num: t.num,
        gen: t.gen
      }) : Promise.reject(new Error("Invalid pageIndex request."));
    }
    getAnnotations(t, e) {
      return this.messageHandler.sendWithPromise("GetAnnotations", {
        pageIndex: t,
        intent: e
      });
    }
    getFieldObjects() {
      return E(this, br, vd).call(this, "GetFieldObjects");
    }
    hasJSActions() {
      return E(this, br, vd).call(this, "HasJSActions");
    }
    getCalculationOrderIds() {
      return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
    }
    getDestinations() {
      return this.messageHandler.sendWithPromise("GetDestinations", null);
    }
    getDestination(t) {
      return typeof t != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
        id: t
      });
    }
    getPageLabels() {
      return this.messageHandler.sendWithPromise("GetPageLabels", null);
    }
    getPageLayout() {
      return this.messageHandler.sendWithPromise("GetPageLayout", null);
    }
    getPageMode() {
      return this.messageHandler.sendWithPromise("GetPageMode", null);
    }
    getViewerPreferences() {
      return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
    }
    getOpenAction() {
      return this.messageHandler.sendWithPromise("GetOpenAction", null);
    }
    getAttachments() {
      return this.messageHandler.sendWithPromise("GetAttachments", null);
    }
    getDocJSActions() {
      return E(this, br, vd).call(this, "GetDocJSActions");
    }
    getPageJSActions(t) {
      return this.messageHandler.sendWithPromise("GetPageJSActions", {
        pageIndex: t
      });
    }
    getStructTree(t) {
      return this.messageHandler.sendWithPromise("GetStructTree", {
        pageIndex: t
      });
    }
    getOutline() {
      return this.messageHandler.sendWithPromise("GetOutline", null);
    }
    getOptionalContentConfig(t) {
      return E(this, br, vd).call(this, "GetOptionalContentConfig").then((e) => new V0(e, t));
    }
    getPermissions() {
      return this.messageHandler.sendWithPromise("GetPermissions", null);
    }
    getMetadata() {
      const t = "GetMetadata", e = r(this, ui).get(t);
      if (e)
        return e;
      const s = this.messageHandler.sendWithPromise(t, null).then((a) => {
        var o, h;
        return {
          info: a[0],
          metadata: a[1] ? new j0(a[1]) : null,
          contentDispositionFilename: ((o = this._fullReader) == null ? void 0 : o.filename) ?? null,
          contentLength: ((h = this._fullReader) == null ? void 0 : h.contentLength) ?? null
        };
      });
      return r(this, ui).set(t, s), s;
    }
    getMarkInfo() {
      return this.messageHandler.sendWithPromise("GetMarkInfo", null);
    }
    async startCleanup(t = !1) {
      if (!this.destroyed) {
        await this.messageHandler.sendWithPromise("Cleanup", null);
        for (const e of r(this, Ls).values())
          if (!e.cleanup())
            throw new Error(`startCleanup: Page ${e.pageNumber} is currently rendering.`);
        this.commonObjs.clear(), t || this.fontLoader.clear(), r(this, ui).clear(), this.filterFactory.destroy(!0), Ra.cleanup();
      }
    }
    cachedPageNumber(t) {
      if (!Yb(t))
        return null;
      const e = t.gen === 0 ? `${t.num}R` : `${t.num}R${t.gen}`;
      return r(this, oo).get(e) ?? null;
    }
  }
  ui = new WeakMap(), Ls = new WeakMap(), ao = new WeakMap(), oo = new WeakMap(), _s = new WeakMap(), br = new WeakSet(), vd = function(t, e = null) {
    const s = r(this, ui).get(t);
    if (s)
      return s;
    const a = this.messageHandler.sendWithPromise(t, e);
    return r(this, ui).set(t, a), a;
  };
  const Nu = Symbol("INITIAL_DATA");
  class Zb {
    constructor() {
      v(this, Kh);
      v(this, ls, /* @__PURE__ */ Object.create(null));
    }
    get(t, e = null) {
      if (e) {
        const a = E(this, Kh, pv).call(this, t);
        return a.promise.then(() => e(a.data)), null;
      }
      const s = r(this, ls)[t];
      if (!s || s.data === Nu)
        throw new Error(`Requesting object that isn't resolved yet ${t}.`);
      return s.data;
    }
    has(t) {
      const e = r(this, ls)[t];
      return !!e && e.data !== Nu;
    }
    resolve(t, e = null) {
      const s = E(this, Kh, pv).call(this, t);
      s.data = e, s.resolve();
    }
    clear() {
      var t;
      for (const e in r(this, ls)) {
        const {
          data: s
        } = r(this, ls)[e];
        (t = s == null ? void 0 : s.bitmap) == null || t.close();
      }
      x(this, ls, /* @__PURE__ */ Object.create(null));
    }
    *[Symbol.iterator]() {
      for (const t in r(this, ls)) {
        const {
          data: e
        } = r(this, ls)[t];
        e !== Nu && (yield [t, e]);
      }
    }
  }
  ls = new WeakMap(), Kh = new WeakSet(), pv = function(t) {
    var e;
    return (e = r(this, ls))[t] || (e[t] = {
      ...Promise.withResolvers(),
      data: Nu
    });
  };
  class Sw {
    constructor(t) {
      v(this, sn, null);
      x(this, sn, t), this.onContinue = null;
    }
    get promise() {
      return r(this, sn).capability.promise;
    }
    cancel(t = 0) {
      r(this, sn).cancel(null, t);
    }
    get separateAnnots() {
      const {
        separateAnnots: t
      } = r(this, sn).operatorList;
      if (!t)
        return !1;
      const {
        annotationCanvasMap: e
      } = r(this, sn);
      return t.form || t.canvas && (e == null ? void 0 : e.size) > 0;
    }
  }
  sn = new WeakMap();
  const Ar = class Ar {
    constructor({
      callback: t,
      params: e,
      objs: s,
      commonObjs: a,
      annotationCanvasMap: o,
      operatorList: h,
      pageIndex: c,
      canvasFactory: p,
      filterFactory: g,
      useRequestAnimationFrame: b = !1,
      pdfBug: S = !1,
      pageColors: T = null
    }) {
      this.callback = t, this.params = e, this.objs = s, this.commonObjs = a, this.annotationCanvasMap = o, this.operatorListIdx = null, this.operatorList = h, this._pageIndex = c, this.canvasFactory = p, this.filterFactory = g, this._pdfBug = S, this.pageColors = T, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = b === !0 && typeof window < "u", this.cancelled = !1, this.capability = Promise.withResolvers(), this.task = new Sw(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = e.canvasContext.canvas;
    }
    get completed() {
      return this.capability.promise.catch(function() {
      });
    }
    initializeGraphics({
      transparency: t = !1,
      optionalContentConfig: e
    }) {
      var c, p;
      if (this.cancelled)
        return;
      if (this._canvas) {
        if (r(Ar, yr).has(this._canvas))
          throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
        r(Ar, yr).add(this._canvas);
      }
      this._pdfBug && ((c = globalThis.StepperManager) != null && c.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
      const {
        canvasContext: s,
        viewport: a,
        transform: o,
        background: h
      } = this.params;
      this.gfx = new Ca(s, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
        optionalContentConfig: e
      }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
        transform: o,
        viewport: a,
        transparency: t,
        background: h
      }), this.operatorListIdx = 0, this.graphicsReady = !0, (p = this.graphicsReadyCallback) == null || p.call(this);
    }
    cancel(t = null, e = 0) {
      var s;
      this.running = !1, this.cancelled = !0, (s = this.gfx) == null || s.endDrawing(), r(Ar, yr).delete(this._canvas), this.callback(t || new sm(`Rendering cancelled, page ${this._pageIndex + 1}`, e));
    }
    operatorListChanged() {
      var t;
      if (!this.graphicsReady) {
        this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
        return;
      }
      (t = this.stepper) == null || t.updateOperatorList(this.operatorList), !this.running && this._continue();
    }
    _continue() {
      this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
    }
    _scheduleNext() {
      this._useRequestAnimationFrame ? window.requestAnimationFrame(() => {
        this._nextBound().catch(this._cancelBound);
      }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
    }
    async _next() {
      this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), r(Ar, yr).delete(this._canvas), this.callback())));
    }
  };
  yr = new WeakMap(), v(Ar, yr, /* @__PURE__ */ new WeakSet());
  let Am = Ar;
  const xw = "4.3.136", Pw = "0cec64437";
  Ct(670);
  function Jb(A) {
    return Math.floor(Math.max(0, Math.min(1, A)) * 255).toString(16).padStart(2, "0");
  }
  function Nl(A) {
    return Math.max(0, Math.min(255, 255 * A));
  }
  class qb {
    static CMYK_G([t, e, s, a]) {
      return ["G", 1 - Math.min(1, 0.3 * t + 0.59 * s + 0.11 * e + a)];
    }
    static G_CMYK([t]) {
      return ["CMYK", 0, 0, 0, 1 - t];
    }
    static G_RGB([t]) {
      return ["RGB", t, t, t];
    }
    static G_rgb([t]) {
      return t = Nl(t), [t, t, t];
    }
    static G_HTML([t]) {
      const e = Jb(t);
      return `#${e}${e}${e}`;
    }
    static RGB_G([t, e, s]) {
      return ["G", 0.3 * t + 0.59 * e + 0.11 * s];
    }
    static RGB_rgb(t) {
      return t.map(Nl);
    }
    static RGB_HTML(t) {
      return `#${t.map(Jb).join("")}`;
    }
    static T_HTML() {
      return "#00000000";
    }
    static T_rgb() {
      return [null];
    }
    static CMYK_RGB([t, e, s, a]) {
      return ["RGB", 1 - Math.min(1, t + a), 1 - Math.min(1, s + a), 1 - Math.min(1, e + a)];
    }
    static CMYK_rgb([t, e, s, a]) {
      return [Nl(1 - Math.min(1, t + a)), Nl(1 - Math.min(1, s + a)), Nl(1 - Math.min(1, e + a))];
    }
    static CMYK_HTML(t) {
      const e = this.CMYK_RGB(t).slice(1);
      return this.RGB_HTML(e);
    }
    static RGB_CMYK([t, e, s]) {
      const a = 1 - t, o = 1 - e, h = 1 - s, c = Math.min(a, o, h);
      return ["CMYK", a, o, h, c];
    }
  }
  class ty {
    static setupStorage(t, e, s, a, o) {
      const h = a.getValue(e, {
        value: null
      });
      switch (s.name) {
        case "textarea":
          if (h.value !== null && (t.textContent = h.value), o === "print")
            break;
          t.addEventListener("input", (c) => {
            a.setValue(e, {
              value: c.target.value
            });
          });
          break;
        case "input":
          if (s.attributes.type === "radio" || s.attributes.type === "checkbox") {
            if (h.value === s.attributes.xfaOn ? t.setAttribute("checked", !0) : h.value === s.attributes.xfaOff && t.removeAttribute("checked"), o === "print")
              break;
            t.addEventListener("change", (c) => {
              a.setValue(e, {
                value: c.target.checked ? c.target.getAttribute("xfaOn") : c.target.getAttribute("xfaOff")
              });
            });
          } else {
            if (h.value !== null && t.setAttribute("value", h.value), o === "print")
              break;
            t.addEventListener("input", (c) => {
              a.setValue(e, {
                value: c.target.value
              });
            });
          }
          break;
        case "select":
          if (h.value !== null) {
            t.setAttribute("value", h.value);
            for (const c of s.children)
              c.attributes.value === h.value ? c.attributes.selected = !0 : c.attributes.hasOwnProperty("selected") && delete c.attributes.selected;
          }
          t.addEventListener("input", (c) => {
            const p = c.target.options, g = p.selectedIndex === -1 ? "" : p[p.selectedIndex].value;
            a.setValue(e, {
              value: g
            });
          });
          break;
      }
    }
    static setAttributes({
      html: t,
      element: e,
      storage: s = null,
      intent: a,
      linkService: o
    }) {
      const {
        attributes: h
      } = e, c = t instanceof HTMLAnchorElement;
      h.type === "radio" && (h.name = `${h.name}-${a}`);
      for (const [p, g] of Object.entries(h))
        if (g != null)
          switch (p) {
            case "class":
              g.length && t.setAttribute(p, g.join(" "));
              break;
            case "dataId":
              break;
            case "id":
              t.setAttribute("data-element-id", g);
              break;
            case "style":
              Object.assign(t.style, g);
              break;
            case "textContent":
              t.textContent = g;
              break;
            default:
              (!c || p !== "href" && p !== "newWindow") && t.setAttribute(p, g);
          }
      c && o.addLinkAttributes(t, h.href, h.newWindow), s && h.dataId && this.setupStorage(t, h.dataId, e, s);
    }
    static render(t) {
      var S, T;
      const e = t.annotationStorage, s = t.linkService, a = t.xfaHtml, o = t.intent || "display", h = document.createElement(a.name);
      a.attributes && this.setAttributes({
        html: h,
        element: a,
        intent: o,
        linkService: s
      });
      const c = o !== "richText", p = t.div;
      if (p.append(h), t.viewport) {
        const C = `matrix(${t.viewport.transform.join(",")})`;
        p.style.transform = C;
      }
      c && p.setAttribute("class", "xfaLayer xfaFont");
      const g = [];
      if (a.children.length === 0) {
        if (a.value) {
          const C = document.createTextNode(a.value);
          h.append(C), c && Dl.shouldBuildText(a.name) && g.push(C);
        }
        return {
          textDivs: g
        };
      }
      const b = [[a, -1, h]];
      for (; b.length > 0; ) {
        const [C, R, M] = b.at(-1);
        if (R + 1 === C.children.length) {
          b.pop();
          continue;
        }
        const F = C.children[++b.at(-1)[1]];
        if (F === null)
          continue;
        const {
          name: O
        } = F;
        if (O === "#text") {
          const Y = document.createTextNode(F.value);
          g.push(Y), M.append(Y);
          continue;
        }
        const U = (S = F == null ? void 0 : F.attributes) != null && S.xmlns ? document.createElementNS(F.attributes.xmlns, O) : document.createElement(O);
        if (M.append(U), F.attributes && this.setAttributes({
          html: U,
          element: F,
          storage: e,
          intent: o,
          linkService: s
        }), ((T = F.children) == null ? void 0 : T.length) > 0)
          b.push([F, -1, U]);
        else if (F.value) {
          const Y = document.createTextNode(F.value);
          c && Dl.shouldBuildText(O) && g.push(Y), U.append(Y);
        }
      }
      for (const C of p.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
        C.setAttribute("readOnly", !0);
      return {
        textDivs: g
      };
    }
    static update(t) {
      const e = `matrix(${t.viewport.transform.join(",")})`;
      t.div.style.transform = e, t.div.hidden = !1;
    }
  }
  const Fl = 1e3, Tw = 9, Vn = /* @__PURE__ */ new WeakSet();
  function Js(A) {
    return {
      width: A[2] - A[0],
      height: A[3] - A[1]
    };
  }
  class Cw {
    static create(t) {
      switch (t.data.annotationType) {
        case D.LINK:
          return new ey(t);
        case D.TEXT:
          return new Rw(t);
        case D.WIDGET:
          switch (t.data.fieldType) {
            case "Tx":
              return new Iw(t);
            case "Btn":
              return t.data.radioButton ? new sy(t) : t.data.checkBox ? new _w(t) : new Mw(t);
            case "Ch":
              return new Ow(t);
            case "Sig":
              return new Lw(t);
          }
          return new $n(t);
        case D.POPUP:
          return new Em(t);
        case D.FREETEXT:
          return new iy(t);
        case D.LINE:
          return new Dw(t);
        case D.SQUARE:
          return new Nw(t);
        case D.CIRCLE:
          return new Fw(t);
        case D.POLYLINE:
          return new ny(t);
        case D.CARET:
          return new jw(t);
        case D.INK:
          return new ry(t);
        case D.POLYGON:
          return new Bw(t);
        case D.HIGHLIGHT:
          return new Hw(t);
        case D.UNDERLINE:
          return new Vw(t);
        case D.SQUIGGLY:
          return new $w(t);
        case D.STRIKEOUT:
          return new Uw(t);
        case D.STAMP:
          return new ay(t);
        case D.FILEATTACHMENT:
          return new zw(t);
        default:
          return new Yt(t);
      }
    }
  }
  const _m = class _m {
    constructor(t, {
      isRenderable: e = !1,
      ignoreBorder: s = !1,
      createQuadrilaterals: a = !1
    } = {}) {
      v(this, Yh);
      v(this, Er, null);
      v(this, lo, !1);
      v(this, ho, null);
      this.isRenderable = e, this.data = t.data, this.layer = t.layer, this.linkService = t.linkService, this.downloadManager = t.downloadManager, this.imageResourcesPath = t.imageResourcesPath, this.renderForms = t.renderForms, this.svgFactory = t.svgFactory, this.annotationStorage = t.annotationStorage, this.enableScripting = t.enableScripting, this.hasJSActions = t.hasJSActions, this._fieldObjects = t.fieldObjects, this.parent = t.parent, e && (this.container = this._createContainer(s)), a && this._createQuadrilaterals();
    }
    static _hasPopupData({
      titleObj: t,
      contentsObj: e,
      richText: s
    }) {
      return !!(t != null && t.str || e != null && e.str || s != null && s.str);
    }
    get hasPopupData() {
      return _m._hasPopupData(this.data);
    }
    updateEdited(t) {
      var s;
      if (!this.container)
        return;
      r(this, Er) || x(this, Er, {
        rect: this.data.rect.slice(0)
      });
      const {
        rect: e
      } = t;
      e && E(this, Yh, gv).call(this, e), (s = r(this, ho)) == null || s.popup.updateEdited(t);
    }
    resetEdited() {
      var t;
      r(this, Er) && (E(this, Yh, gv).call(this, r(this, Er).rect), (t = r(this, ho)) == null || t.popup.resetEdited(), x(this, Er, null));
    }
    _createContainer(t) {
      const {
        data: e,
        parent: {
          page: s,
          viewport: a
        }
      } = this, o = document.createElement("section");
      o.setAttribute("data-annotation-id", e.id), this instanceof $n || (o.tabIndex = Fl);
      const {
        style: h
      } = o;
      if (h.zIndex = this.parent.zIndex++, e.popupRef && o.setAttribute("aria-haspopup", "dialog"), e.alternativeText && (o.title = e.alternativeText), e.noRotate && o.classList.add("norotate"), !e.rect || this instanceof Em) {
        const {
          rotation: M
        } = e;
        return !e.hasOwnCanvas && M !== 0 && this.setRotation(M, o), o;
      }
      const {
        width: c,
        height: p
      } = Js(e.rect);
      if (!t && e.borderStyle.width > 0) {
        h.borderWidth = `${e.borderStyle.width}px`;
        const M = e.borderStyle.horizontalCornerRadius, F = e.borderStyle.verticalCornerRadius;
        if (M > 0 || F > 0) {
          const U = `calc(${M}px * var(--scale-factor)) / calc(${F}px * var(--scale-factor))`;
          h.borderRadius = U;
        } else if (this instanceof sy) {
          const U = `calc(${c}px * var(--scale-factor)) / calc(${p}px * var(--scale-factor))`;
          h.borderRadius = U;
        }
        switch (e.borderStyle.style) {
          case k.SOLID:
            h.borderStyle = "solid";
            break;
          case k.DASHED:
            h.borderStyle = "dashed";
            break;
          case k.BEVELED:
            j("Unimplemented border style: beveled");
            break;
          case k.INSET:
            j("Unimplemented border style: inset");
            break;
          case k.UNDERLINE:
            h.borderBottomStyle = "solid";
            break;
        }
        const O = e.borderColor || null;
        O ? (x(this, lo, !0), h.borderColor = et.makeHexColor(O[0] | 0, O[1] | 0, O[2] | 0)) : h.borderWidth = 0;
      }
      const g = et.normalizeRect([e.rect[0], s.view[3] - e.rect[1] + s.view[1], e.rect[2], s.view[3] - e.rect[3] + s.view[1]]), {
        pageWidth: b,
        pageHeight: S,
        pageX: T,
        pageY: C
      } = a.rawDims;
      h.left = `${100 * (g[0] - T) / b}%`, h.top = `${100 * (g[1] - C) / S}%`;
      const {
        rotation: R
      } = e;
      return e.hasOwnCanvas || R === 0 ? (h.width = `${100 * c / b}%`, h.height = `${100 * p / S}%`) : this.setRotation(R, o), o;
    }
    setRotation(t, e = this.container) {
      if (!this.data.rect)
        return;
      const {
        pageWidth: s,
        pageHeight: a
      } = this.parent.viewport.rawDims, {
        width: o,
        height: h
      } = Js(this.data.rect);
      let c, p;
      t % 180 === 0 ? (c = 100 * o / s, p = 100 * h / a) : (c = 100 * h / s, p = 100 * o / a), e.style.width = `${c}%`, e.style.height = `${p}%`, e.setAttribute("data-main-rotation", (360 - t) % 360);
    }
    get _commonActions() {
      const t = (e, s, a) => {
        const o = a.detail[e], h = o[0], c = o.slice(1);
        a.target.style[s] = qb[`${h}_HTML`](c), this.annotationStorage.setValue(this.data.id, {
          [s]: qb[`${h}_rgb`](c)
        });
      };
      return tt(this, "_commonActions", {
        display: (e) => {
          const {
            display: s
          } = e.detail, a = s % 2 === 1;
          this.container.style.visibility = a ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
            noView: a,
            noPrint: s === 1 || s === 2
          });
        },
        print: (e) => {
          this.annotationStorage.setValue(this.data.id, {
            noPrint: !e.detail.print
          });
        },
        hidden: (e) => {
          const {
            hidden: s
          } = e.detail;
          this.container.style.visibility = s ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
            noPrint: s,
            noView: s
          });
        },
        focus: (e) => {
          setTimeout(() => e.target.focus({
            preventScroll: !1
          }), 0);
        },
        userName: (e) => {
          e.target.title = e.detail.userName;
        },
        readonly: (e) => {
          e.target.disabled = e.detail.readonly;
        },
        required: (e) => {
          this._setRequired(e.target, e.detail.required);
        },
        bgColor: (e) => {
          t("bgColor", "backgroundColor", e);
        },
        fillColor: (e) => {
          t("fillColor", "backgroundColor", e);
        },
        fgColor: (e) => {
          t("fgColor", "color", e);
        },
        textColor: (e) => {
          t("textColor", "color", e);
        },
        borderColor: (e) => {
          t("borderColor", "borderColor", e);
        },
        strokeColor: (e) => {
          t("strokeColor", "borderColor", e);
        },
        rotation: (e) => {
          const s = e.detail.rotation;
          this.setRotation(s), this.annotationStorage.setValue(this.data.id, {
            rotation: s
          });
        }
      });
    }
    _dispatchEventFromSandbox(t, e) {
      const s = this._commonActions;
      for (const a of Object.keys(e.detail)) {
        const o = t[a] || s[a];
        o == null || o(e);
      }
    }
    _setDefaultPropertiesFromJS(t) {
      if (!this.enableScripting)
        return;
      const e = this.annotationStorage.getRawValue(this.data.id);
      if (!e)
        return;
      const s = this._commonActions;
      for (const [a, o] of Object.entries(e)) {
        const h = s[a];
        if (h) {
          const c = {
            detail: {
              [a]: o
            },
            target: t
          };
          h(c), delete e[a];
        }
      }
    }
    _createQuadrilaterals() {
      if (!this.container)
        return;
      const {
        quadPoints: t
      } = this.data;
      if (!t)
        return;
      const [e, s, a, o] = this.data.rect;
      if (t.length === 1) {
        const [, {
          x: M,
          y: F
        }, {
          x: O,
          y: U
        }] = t[0];
        if (a === M && o === F && e === O && s === U)
          return;
      }
      const {
        style: h
      } = this.container;
      let c;
      if (r(this, lo)) {
        const {
          borderColor: M,
          borderWidth: F
        } = h;
        h.borderWidth = 0, c = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${M}" stroke-width="${F}">`], this.container.classList.add("hasBorder");
      }
      const p = a - e, g = o - s, {
        svgFactory: b
      } = this, S = b.createElement("svg");
      S.classList.add("quadrilateralsContainer"), S.setAttribute("width", 0), S.setAttribute("height", 0);
      const T = b.createElement("defs");
      S.append(T);
      const C = b.createElement("clipPath"), R = `clippath_${this.data.id}`;
      C.setAttribute("id", R), C.setAttribute("clipPathUnits", "objectBoundingBox"), T.append(C);
      for (const [, {
        x: M,
        y: F
      }, {
        x: O,
        y: U
      }] of t) {
        const Y = b.createElement("rect"), J = (O - e) / p, rt = (o - F) / g, st = (M - O) / p, ot = (F - U) / g;
        Y.setAttribute("x", J), Y.setAttribute("y", rt), Y.setAttribute("width", st), Y.setAttribute("height", ot), C.append(Y), c == null || c.push(`<rect vector-effect="non-scaling-stroke" x="${J}" y="${rt}" width="${st}" height="${ot}"/>`);
      }
      r(this, lo) && (c.push("</g></svg>')"), h.backgroundImage = c.join("")), this.container.append(S), this.container.style.clipPath = `url(#${R})`;
    }
    _createPopup() {
      const {
        container: t,
        data: e
      } = this;
      t.setAttribute("aria-haspopup", "dialog");
      const s = x(this, ho, new Em({
        data: {
          color: e.color,
          titleObj: e.titleObj,
          modificationDate: e.modificationDate,
          contentsObj: e.contentsObj,
          richText: e.richText,
          parentRect: e.rect,
          borderStyle: 0,
          id: `popup_${e.id}`,
          rotation: e.rotation
        },
        parent: this.parent,
        elements: [this]
      }));
      this.parent.div.append(s.render());
    }
    render() {
      Q("Abstract method `AnnotationElement.render` called");
    }
    _getElementsByName(t, e = null) {
      const s = [];
      if (this._fieldObjects) {
        const a = this._fieldObjects[t];
        if (a)
          for (const {
            page: o,
            id: h,
            exportValues: c
          } of a) {
            if (o === -1 || h === e)
              continue;
            const p = typeof c == "string" ? c : null, g = document.querySelector(`[data-element-id="${h}"]`);
            if (g && !Vn.has(g)) {
              j(`_getElementsByName - element not allowed: ${h}`);
              continue;
            }
            s.push({
              id: h,
              exportValue: p,
              domElement: g
            });
          }
        return s;
      }
      for (const a of document.getElementsByName(t)) {
        const {
          exportValue: o
        } = a, h = a.getAttribute("data-element-id");
        h !== e && Vn.has(a) && s.push({
          id: h,
          exportValue: o,
          domElement: a
        });
      }
      return s;
    }
    show() {
      var t;
      this.container && (this.container.hidden = !1), (t = this.popup) == null || t.maybeShow();
    }
    hide() {
      var t;
      this.container && (this.container.hidden = !0), (t = this.popup) == null || t.forceHide();
    }
    getElementsToTriggerPopup() {
      return this.container;
    }
    addHighlightArea() {
      const t = this.getElementsToTriggerPopup();
      if (Array.isArray(t))
        for (const e of t)
          e.classList.add("highlightArea");
      else
        t.classList.add("highlightArea");
    }
    get _isEditable() {
      return !1;
    }
    _editOnDoubleClick() {
      if (!this._isEditable)
        return;
      const {
        annotationEditorType: t,
        data: {
          id: e
        }
      } = this;
      this.container.addEventListener("dblclick", () => {
        var s;
        (s = this.linkService.eventBus) == null || s.dispatch("switchannotationeditormode", {
          source: this,
          mode: t,
          editId: e
        });
      });
    }
  };
  Er = new WeakMap(), lo = new WeakMap(), ho = new WeakMap(), Yh = new WeakSet(), gv = function(t) {
    const {
      container: {
        style: e
      },
      data: {
        rect: s,
        rotation: a
      },
      parent: {
        viewport: {
          rawDims: {
            pageWidth: o,
            pageHeight: h,
            pageX: c,
            pageY: p
          }
        }
      }
    } = this;
    s == null || s.splice(0, 4, ...t);
    const {
      width: g,
      height: b
    } = Js(t);
    e.left = `${100 * (t[0] - c) / o}%`, e.top = `${100 * (h - t[3] + p) / h}%`, a === 0 ? (e.width = `${100 * g / o}%`, e.height = `${100 * b / h}%`) : this.setRotation(a);
  };
  let Yt = _m;
  class ey extends Yt {
    constructor(e, s = null) {
      super(e, {
        isRenderable: !0,
        ignoreBorder: !!(s != null && s.ignoreBorder),
        createQuadrilaterals: !0
      });
      v(this, fi);
      v(this, Rf);
      v(this, If);
      this.isTooltipOnly = e.data.isTooltipOnly;
    }
    render() {
      const {
        data: e,
        linkService: s
      } = this, a = document.createElement("a");
      a.setAttribute("data-element-id", e.id);
      let o = !1;
      return e.url ? (s.addLinkAttributes(a, e.url, e.newWindow), o = !0) : e.action ? (this._bindNamedAction(a, e.action), o = !0) : e.attachment ? (E(this, Rf, PA).call(this, a, e.attachment, e.attachmentDest), o = !0) : e.setOCGState ? (E(this, If, TA).call(this, a, e.setOCGState), o = !0) : e.dest ? (this._bindLink(a, e.dest), o = !0) : (e.actions && (e.actions.Action || e.actions["Mouse Up"] || e.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(a, e), o = !0), e.resetForm ? (this._bindResetFormAction(a, e.resetForm), o = !0) : this.isTooltipOnly && !o && (this._bindLink(a, ""), o = !0)), this.container.classList.add("linkAnnotation"), o && this.container.append(a), this.container;
    }
    _bindLink(e, s) {
      e.href = this.linkService.getDestinationHash(s), e.onclick = () => (s && this.linkService.goToDestination(s), !1), (s || s === "") && E(this, fi, qr).call(this);
    }
    _bindNamedAction(e, s) {
      e.href = this.linkService.getAnchorUrl(""), e.onclick = () => (this.linkService.executeNamedAction(s), !1), E(this, fi, qr).call(this);
    }
    _bindJSAction(e, s) {
      e.href = this.linkService.getAnchorUrl("");
      const a = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
      for (const o of Object.keys(s.actions)) {
        const h = a.get(o);
        h && (e[h] = () => {
          var c;
          return (c = this.linkService.eventBus) == null || c.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: s.id,
              name: o
            }
          }), !1;
        });
      }
      e.onclick || (e.onclick = () => !1), E(this, fi, qr).call(this);
    }
    _bindResetFormAction(e, s) {
      const a = e.onclick;
      if (a || (e.href = this.linkService.getAnchorUrl("")), E(this, fi, qr).call(this), !this._fieldObjects) {
        j('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), a || (e.onclick = () => !1);
        return;
      }
      e.onclick = () => {
        var S;
        a == null || a();
        const {
          fields: o,
          refs: h,
          include: c
        } = s, p = [];
        if (o.length !== 0 || h.length !== 0) {
          const T = new Set(h);
          for (const C of o) {
            const R = this._fieldObjects[C] || [];
            for (const {
              id: M
            } of R)
              T.add(M);
          }
          for (const C of Object.values(this._fieldObjects))
            for (const R of C)
              T.has(R.id) === c && p.push(R);
        } else
          for (const T of Object.values(this._fieldObjects))
            p.push(...T);
        const g = this.annotationStorage, b = [];
        for (const T of p) {
          const {
            id: C
          } = T;
          switch (b.push(C), T.type) {
            case "text": {
              const M = T.defaultValue || "";
              g.setValue(C, {
                value: M
              });
              break;
            }
            case "checkbox":
            case "radiobutton": {
              const M = T.defaultValue === T.exportValues;
              g.setValue(C, {
                value: M
              });
              break;
            }
            case "combobox":
            case "listbox": {
              const M = T.defaultValue || "";
              g.setValue(C, {
                value: M
              });
              break;
            }
            default:
              continue;
          }
          const R = document.querySelector(`[data-element-id="${C}"]`);
          if (R) {
            if (!Vn.has(R)) {
              j(`_bindResetFormAction - element not allowed: ${C}`);
              continue;
            }
          } else
            continue;
          R.dispatchEvent(new Event("resetform"));
        }
        return this.enableScripting && ((S = this.linkService.eventBus) == null || S.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: "app",
            ids: b,
            name: "ResetForm"
          }
        })), !1;
      };
    }
  }
  fi = new WeakSet(), qr = function() {
    this.container.setAttribute("data-internal-link", "");
  }, Rf = new WeakSet(), PA = function(e, s, a = null) {
    e.href = this.linkService.getAnchorUrl(""), s.description && (e.title = s.description), e.onclick = () => {
      var o;
      return (o = this.downloadManager) == null || o.openOrDownloadData(s.content, s.filename, a), !1;
    }, E(this, fi, qr).call(this);
  }, If = new WeakSet(), TA = function(e, s) {
    e.href = this.linkService.getAnchorUrl(""), e.onclick = () => (this.linkService.executeSetOCGState(s), !1), E(this, fi, qr).call(this);
  };
  class Rw extends Yt {
    constructor(t) {
      super(t, {
        isRenderable: !0
      });
    }
    render() {
      this.container.classList.add("textAnnotation");
      const t = document.createElement("img");
      return t.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", t.setAttribute("data-l10n-id", "pdfjs-text-annotation-type"), t.setAttribute("data-l10n-args", JSON.stringify({
        type: this.data.name
      })), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(t), this.container;
    }
  }
  class $n extends Yt {
    render() {
      return this.container;
    }
    showElementAndHideCanvas(t) {
      var e;
      this.data.hasOwnCanvas && (((e = t.previousSibling) == null ? void 0 : e.nodeName) === "CANVAS" && (t.previousSibling.hidden = !0), t.hidden = !1);
    }
    _getKeyModifier(t) {
      return nt.platform.isMac ? t.metaKey : t.ctrlKey;
    }
    _setEventListener(t, e, s, a, o) {
      s.includes("mouse") ? t.addEventListener(s, (h) => {
        var c;
        (c = this.linkService.eventBus) == null || c.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: a,
            value: o(h),
            shift: h.shiftKey,
            modifier: this._getKeyModifier(h)
          }
        });
      }) : t.addEventListener(s, (h) => {
        var c;
        if (s === "blur") {
          if (!e.focused || !h.relatedTarget)
            return;
          e.focused = !1;
        } else if (s === "focus") {
          if (e.focused)
            return;
          e.focused = !0;
        }
        o && ((c = this.linkService.eventBus) == null || c.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: a,
            value: o(h)
          }
        }));
      });
    }
    _setEventListeners(t, e, s, a) {
      var o, h, c;
      for (const [p, g] of s)
        (g === "Action" || (o = this.data.actions) != null && o[g]) && ((g === "Focus" || g === "Blur") && (e || (e = {
          focused: !1
        })), this._setEventListener(t, e, p, g, a), g === "Focus" && !((h = this.data.actions) != null && h.Blur) ? this._setEventListener(t, e, "blur", "Blur", null) : g === "Blur" && !((c = this.data.actions) != null && c.Focus) && this._setEventListener(t, e, "focus", "Focus", null));
    }
    _setBackgroundColor(t) {
      const e = this.data.backgroundColor || null;
      t.style.backgroundColor = e === null ? "transparent" : et.makeHexColor(e[0], e[1], e[2]);
    }
    _setTextStyle(t) {
      const e = ["left", "center", "right"], {
        fontColor: s
      } = this.data.defaultAppearanceData, a = this.data.defaultAppearanceData.fontSize || Tw, o = t.style;
      let h;
      const c = 2, p = (g) => Math.round(10 * g) / 10;
      if (this.data.multiLine) {
        const g = Math.abs(this.data.rect[3] - this.data.rect[1] - c), b = Math.round(g / (d * a)) || 1, S = g / b;
        h = Math.min(a, p(S / d));
      } else {
        const g = Math.abs(this.data.rect[3] - this.data.rect[1] - c);
        h = Math.min(a, p(g / d));
      }
      o.fontSize = `calc(${h}px * var(--scale-factor))`, o.color = et.makeHexColor(s[0], s[1], s[2]), this.data.textAlignment !== null && (o.textAlign = e[this.data.textAlignment]);
    }
    _setRequired(t, e) {
      e ? t.setAttribute("required", !0) : t.removeAttribute("required"), t.setAttribute("aria-required", e);
    }
  }
  class Iw extends $n {
    constructor(t) {
      const e = t.renderForms || t.data.hasOwnCanvas || !t.data.hasAppearance && !!t.data.fieldValue;
      super(t, {
        isRenderable: e
      });
    }
    setPropertyOnSiblings(t, e, s, a) {
      const o = this.annotationStorage;
      for (const h of this._getElementsByName(t.name, t.id))
        h.domElement && (h.domElement[e] = s), o.setValue(h.id, {
          [a]: s
        });
    }
    render() {
      var a, o;
      const t = this.annotationStorage, e = this.data.id;
      this.container.classList.add("textWidgetAnnotation");
      let s = null;
      if (this.renderForms) {
        const h = t.getValue(e, {
          value: this.data.fieldValue
        });
        let c = h.value || "";
        const p = t.getValue(e, {
          charLimit: this.data.maxLen
        }).charLimit;
        p && c.length > p && (c = c.slice(0, p));
        let g = h.formattedValue || ((a = this.data.textContent) == null ? void 0 : a.join(`
`)) || null;
        g && this.data.comb && (g = g.replaceAll(/\s+/g, ""));
        const b = {
          userValue: c,
          formattedValue: g,
          lastCommittedValue: null,
          commitKey: 1,
          focused: !1
        };
        this.data.multiLine ? (s = document.createElement("textarea"), s.textContent = g ?? c, this.data.doNotScroll && (s.style.overflowY = "hidden")) : (s = document.createElement("input"), s.type = "text", s.setAttribute("value", g ?? c), this.data.doNotScroll && (s.style.overflowX = "hidden")), this.data.hasOwnCanvas && (s.hidden = !0), Vn.add(s), s.setAttribute("data-element-id", e), s.disabled = this.data.readOnly, s.name = this.data.fieldName, s.tabIndex = Fl, this._setRequired(s, this.data.required), p && (s.maxLength = p), s.addEventListener("input", (T) => {
          t.setValue(e, {
            value: T.target.value
          }), this.setPropertyOnSiblings(s, "value", T.target.value, "value"), b.formattedValue = null;
        }), s.addEventListener("resetform", (T) => {
          const C = this.data.defaultFieldValue ?? "";
          s.value = b.userValue = C, b.formattedValue = null;
        });
        let S = (T) => {
          const {
            formattedValue: C
          } = b;
          C != null && (T.target.value = C), T.target.scrollLeft = 0;
        };
        if (this.enableScripting && this.hasJSActions) {
          s.addEventListener("focus", (C) => {
            var M;
            if (b.focused)
              return;
            const {
              target: R
            } = C;
            b.userValue && (R.value = b.userValue), b.lastCommittedValue = R.value, b.commitKey = 1, (M = this.data.actions) != null && M.Focus || (b.focused = !0);
          }), s.addEventListener("updatefromsandbox", (C) => {
            this.showElementAndHideCanvas(C.target);
            const R = {
              value(M) {
                b.userValue = M.detail.value ?? "", t.setValue(e, {
                  value: b.userValue.toString()
                }), M.target.value = b.userValue;
              },
              formattedValue(M) {
                const {
                  formattedValue: F
                } = M.detail;
                b.formattedValue = F, F != null && M.target !== document.activeElement && (M.target.value = F), t.setValue(e, {
                  formattedValue: F
                });
              },
              selRange(M) {
                M.target.setSelectionRange(...M.detail.selRange);
              },
              charLimit: (M) => {
                var Y;
                const {
                  charLimit: F
                } = M.detail, {
                  target: O
                } = M;
                if (F === 0) {
                  O.removeAttribute("maxLength");
                  return;
                }
                O.setAttribute("maxLength", F);
                let U = b.userValue;
                !U || U.length <= F || (U = U.slice(0, F), O.value = b.userValue = U, t.setValue(e, {
                  value: U
                }), (Y = this.linkService.eventBus) == null || Y.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: e,
                    name: "Keystroke",
                    value: U,
                    willCommit: !0,
                    commitKey: 1,
                    selStart: O.selectionStart,
                    selEnd: O.selectionEnd
                  }
                }));
              }
            };
            this._dispatchEventFromSandbox(R, C);
          }), s.addEventListener("keydown", (C) => {
            var F;
            b.commitKey = 1;
            let R = -1;
            if (C.key === "Escape" ? R = 0 : C.key === "Enter" && !this.data.multiLine ? R = 2 : C.key === "Tab" && (b.commitKey = 3), R === -1)
              return;
            const {
              value: M
            } = C.target;
            b.lastCommittedValue !== M && (b.lastCommittedValue = M, b.userValue = M, (F = this.linkService.eventBus) == null || F.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id: e,
                name: "Keystroke",
                value: M,
                willCommit: !0,
                commitKey: R,
                selStart: C.target.selectionStart,
                selEnd: C.target.selectionEnd
              }
            }));
          });
          const T = S;
          S = null, s.addEventListener("blur", (C) => {
            var M, F;
            if (!b.focused || !C.relatedTarget)
              return;
            (M = this.data.actions) != null && M.Blur || (b.focused = !1);
            const {
              value: R
            } = C.target;
            b.userValue = R, b.lastCommittedValue !== R && ((F = this.linkService.eventBus) == null || F.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id: e,
                name: "Keystroke",
                value: R,
                willCommit: !0,
                commitKey: b.commitKey,
                selStart: C.target.selectionStart,
                selEnd: C.target.selectionEnd
              }
            })), T(C);
          }), (o = this.data.actions) != null && o.Keystroke && s.addEventListener("beforeinput", (C) => {
            var rt;
            b.lastCommittedValue = null;
            const {
              data: R,
              target: M
            } = C, {
              value: F,
              selectionStart: O,
              selectionEnd: U
            } = M;
            let Y = O, J = U;
            switch (C.inputType) {
              case "deleteWordBackward": {
                const st = F.substring(0, O).match(/\w*[^\w]*$/);
                st && (Y -= st[0].length);
                break;
              }
              case "deleteWordForward": {
                const st = F.substring(O).match(/^[^\w]*\w*/);
                st && (J += st[0].length);
                break;
              }
              case "deleteContentBackward":
                O === U && (Y -= 1);
                break;
              case "deleteContentForward":
                O === U && (J += 1);
                break;
            }
            C.preventDefault(), (rt = this.linkService.eventBus) == null || rt.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id: e,
                name: "Keystroke",
                value: F,
                change: R || "",
                willCommit: !1,
                selStart: Y,
                selEnd: J
              }
            });
          }), this._setEventListeners(s, b, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (C) => C.target.value);
        }
        if (S && s.addEventListener("blur", S), this.data.comb) {
          const C = (this.data.rect[2] - this.data.rect[0]) / p;
          s.classList.add("comb"), s.style.letterSpacing = `calc(${C}px * var(--scale-factor) - 1ch)`;
        }
      } else
        s = document.createElement("div"), s.textContent = this.data.fieldValue, s.style.verticalAlign = "middle", s.style.display = "table-cell", this.data.hasOwnCanvas && (s.hidden = !0);
      return this._setTextStyle(s), this._setBackgroundColor(s), this._setDefaultPropertiesFromJS(s), this.container.append(s), this.container;
    }
  }
  class Lw extends $n {
    constructor(t) {
      super(t, {
        isRenderable: !!t.data.hasOwnCanvas
      });
    }
  }
  class _w extends $n {
    constructor(t) {
      super(t, {
        isRenderable: t.renderForms
      });
    }
    render() {
      const t = this.annotationStorage, e = this.data, s = e.id;
      let a = t.getValue(s, {
        value: e.exportValue === e.fieldValue
      }).value;
      typeof a == "string" && (a = a !== "Off", t.setValue(s, {
        value: a
      })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
      const o = document.createElement("input");
      return Vn.add(o), o.setAttribute("data-element-id", s), o.disabled = e.readOnly, this._setRequired(o, this.data.required), o.type = "checkbox", o.name = e.fieldName, a && o.setAttribute("checked", !0), o.setAttribute("exportValue", e.exportValue), o.tabIndex = Fl, o.addEventListener("change", (h) => {
        const {
          name: c,
          checked: p
        } = h.target;
        for (const g of this._getElementsByName(c, s)) {
          const b = p && g.exportValue === e.exportValue;
          g.domElement && (g.domElement.checked = b), t.setValue(g.id, {
            value: b
          });
        }
        t.setValue(s, {
          value: p
        });
      }), o.addEventListener("resetform", (h) => {
        const c = e.defaultFieldValue || "Off";
        h.target.checked = c === e.exportValue;
      }), this.enableScripting && this.hasJSActions && (o.addEventListener("updatefromsandbox", (h) => {
        const c = {
          value(p) {
            p.target.checked = p.detail.value !== "Off", t.setValue(s, {
              value: p.target.checked
            });
          }
        };
        this._dispatchEventFromSandbox(c, h);
      }), this._setEventListeners(o, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (h) => h.target.checked)), this._setBackgroundColor(o), this._setDefaultPropertiesFromJS(o), this.container.append(o), this.container;
    }
  }
  class sy extends $n {
    constructor(t) {
      super(t, {
        isRenderable: t.renderForms
      });
    }
    render() {
      this.container.classList.add("buttonWidgetAnnotation", "radioButton");
      const t = this.annotationStorage, e = this.data, s = e.id;
      let a = t.getValue(s, {
        value: e.fieldValue === e.buttonValue
      }).value;
      if (typeof a == "string" && (a = a !== e.buttonValue, t.setValue(s, {
        value: a
      })), a)
        for (const h of this._getElementsByName(e.fieldName, s))
          t.setValue(h.id, {
            value: !1
          });
      const o = document.createElement("input");
      if (Vn.add(o), o.setAttribute("data-element-id", s), o.disabled = e.readOnly, this._setRequired(o, this.data.required), o.type = "radio", o.name = e.fieldName, a && o.setAttribute("checked", !0), o.tabIndex = Fl, o.addEventListener("change", (h) => {
        const {
          name: c,
          checked: p
        } = h.target;
        for (const g of this._getElementsByName(c, s))
          t.setValue(g.id, {
            value: !1
          });
        t.setValue(s, {
          value: p
        });
      }), o.addEventListener("resetform", (h) => {
        const c = e.defaultFieldValue;
        h.target.checked = c != null && c === e.buttonValue;
      }), this.enableScripting && this.hasJSActions) {
        const h = e.buttonValue;
        o.addEventListener("updatefromsandbox", (c) => {
          const p = {
            value: (g) => {
              const b = h === g.detail.value;
              for (const S of this._getElementsByName(g.target.name)) {
                const T = b && S.id === s;
                S.domElement && (S.domElement.checked = T), t.setValue(S.id, {
                  value: T
                });
              }
            }
          };
          this._dispatchEventFromSandbox(p, c);
        }), this._setEventListeners(o, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (c) => c.target.checked);
      }
      return this._setBackgroundColor(o), this._setDefaultPropertiesFromJS(o), this.container.append(o), this.container;
    }
  }
  class Mw extends ey {
    constructor(t) {
      super(t, {
        ignoreBorder: t.data.hasAppearance
      });
    }
    render() {
      const t = super.render();
      t.classList.add("buttonWidgetAnnotation", "pushButton");
      const e = t.lastChild;
      return this.enableScripting && this.hasJSActions && e && (this._setDefaultPropertiesFromJS(e), e.addEventListener("updatefromsandbox", (s) => {
        this._dispatchEventFromSandbox({}, s);
      })), t;
    }
  }
  class Ow extends $n {
    constructor(t) {
      super(t, {
        isRenderable: t.renderForms
      });
    }
    render() {
      this.container.classList.add("choiceWidgetAnnotation");
      const t = this.annotationStorage, e = this.data.id, s = t.getValue(e, {
        value: this.data.fieldValue
      }), a = document.createElement("select");
      Vn.add(a), a.setAttribute("data-element-id", e), a.disabled = this.data.readOnly, this._setRequired(a, this.data.required), a.name = this.data.fieldName, a.tabIndex = Fl;
      let o = this.data.combo && this.data.options.length > 0;
      this.data.combo || (a.size = this.data.options.length, this.data.multiSelect && (a.multiple = !0)), a.addEventListener("resetform", (b) => {
        const S = this.data.defaultFieldValue;
        for (const T of a.options)
          T.selected = T.value === S;
      });
      for (const b of this.data.options) {
        const S = document.createElement("option");
        S.textContent = b.displayValue, S.value = b.exportValue, s.value.includes(b.exportValue) && (S.setAttribute("selected", !0), o = !1), a.append(S);
      }
      let h = null;
      if (o) {
        const b = document.createElement("option");
        b.value = " ", b.setAttribute("hidden", !0), b.setAttribute("selected", !0), a.prepend(b), h = () => {
          b.remove(), a.removeEventListener("input", h), h = null;
        }, a.addEventListener("input", h);
      }
      const c = (b) => {
        const S = b ? "value" : "textContent", {
          options: T,
          multiple: C
        } = a;
        return C ? Array.prototype.filter.call(T, (R) => R.selected).map((R) => R[S]) : T.selectedIndex === -1 ? null : T[T.selectedIndex][S];
      };
      let p = c(!1);
      const g = (b) => {
        const S = b.target.options;
        return Array.prototype.map.call(S, (T) => ({
          displayValue: T.textContent,
          exportValue: T.value
        }));
      };
      return this.enableScripting && this.hasJSActions ? (a.addEventListener("updatefromsandbox", (b) => {
        const S = {
          value(T) {
            h == null || h();
            const C = T.detail.value, R = new Set(Array.isArray(C) ? C : [C]);
            for (const M of a.options)
              M.selected = R.has(M.value);
            t.setValue(e, {
              value: c(!0)
            }), p = c(!1);
          },
          multipleSelection(T) {
            a.multiple = !0;
          },
          remove(T) {
            const C = a.options, R = T.detail.remove;
            C[R].selected = !1, a.remove(R), C.length > 0 && Array.prototype.findIndex.call(C, (F) => F.selected) === -1 && (C[0].selected = !0), t.setValue(e, {
              value: c(!0),
              items: g(T)
            }), p = c(!1);
          },
          clear(T) {
            for (; a.length !== 0; )
              a.remove(0);
            t.setValue(e, {
              value: null,
              items: []
            }), p = c(!1);
          },
          insert(T) {
            const {
              index: C,
              displayValue: R,
              exportValue: M
            } = T.detail.insert, F = a.children[C], O = document.createElement("option");
            O.textContent = R, O.value = M, F ? F.before(O) : a.append(O), t.setValue(e, {
              value: c(!0),
              items: g(T)
            }), p = c(!1);
          },
          items(T) {
            const {
              items: C
            } = T.detail;
            for (; a.length !== 0; )
              a.remove(0);
            for (const R of C) {
              const {
                displayValue: M,
                exportValue: F
              } = R, O = document.createElement("option");
              O.textContent = M, O.value = F, a.append(O);
            }
            a.options.length > 0 && (a.options[0].selected = !0), t.setValue(e, {
              value: c(!0),
              items: g(T)
            }), p = c(!1);
          },
          indices(T) {
            const C = new Set(T.detail.indices);
            for (const R of T.target.options)
              R.selected = C.has(R.index);
            t.setValue(e, {
              value: c(!0)
            }), p = c(!1);
          },
          editable(T) {
            T.target.disabled = !T.detail.editable;
          }
        };
        this._dispatchEventFromSandbox(S, b);
      }), a.addEventListener("input", (b) => {
        var C;
        const S = c(!0), T = c(!1);
        t.setValue(e, {
          value: S
        }), b.preventDefault(), (C = this.linkService.eventBus) == null || C.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: e,
            name: "Keystroke",
            value: p,
            change: T,
            changeEx: S,
            willCommit: !1,
            commitKey: 1,
            keyDown: !1
          }
        });
      }), this._setEventListeners(a, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (b) => b.target.value)) : a.addEventListener("input", function(b) {
        t.setValue(e, {
          value: c(!0)
        });
      }), this.data.combo && this._setTextStyle(a), this._setBackgroundColor(a), this._setDefaultPropertiesFromJS(a), this.container.append(a), this.container;
    }
  }
  class Em extends Yt {
    constructor(t) {
      const {
        data: e,
        elements: s
      } = t;
      super(t, {
        isRenderable: Yt._hasPopupData(e)
      }), this.elements = s, this.popup = null;
    }
    render() {
      this.container.classList.add("popupAnnotation");
      const t = this.popup = new kw({
        container: this.container,
        color: this.data.color,
        titleObj: this.data.titleObj,
        modificationDate: this.data.modificationDate,
        contentsObj: this.data.contentsObj,
        richText: this.data.richText,
        rect: this.data.rect,
        parentRect: this.data.parentRect || null,
        parent: this.parent,
        elements: this.elements,
        open: this.data.open
      }), e = [];
      for (const s of this.elements)
        s.popup = t, e.push(s.data.id), s.addHighlightArea();
      return this.container.setAttribute("aria-controls", e.map((s) => `${ne}${s}`).join(",")), this.container;
    }
  }
  class kw {
    constructor({
      container: t,
      color: e,
      elements: s,
      titleObj: a,
      modificationDate: o,
      contentsObj: h,
      richText: c,
      parent: p,
      rect: g,
      parentRect: b,
      open: S
    }) {
      v(this, po);
      v(this, tc);
      v(this, Mf);
      v(this, Of);
      v(this, kf);
      v(this, Df);
      v(this, go);
      v(this, mo);
      v(this, ec);
      v(this, co, E(this, kf, IA).bind(this));
      v(this, Lf, E(this, ec, vv).bind(this));
      v(this, _f, E(this, mo, Vp).bind(this));
      v(this, uo, E(this, go, Hp).bind(this));
      v(this, wr, null);
      v(this, Xt, null);
      v(this, pi, null);
      v(this, Sr, null);
      v(this, Qh, null);
      v(this, Zh, null);
      v(this, fo, null);
      v(this, gi, !1);
      v(this, hs, null);
      v(this, mi, null);
      v(this, Jh, null);
      v(this, vi, null);
      v(this, qh, null);
      v(this, xr, null);
      v(this, Pr, !1);
      var T;
      x(this, Xt, t), x(this, qh, a), x(this, pi, h), x(this, vi, c), x(this, Zh, p), x(this, wr, e), x(this, Jh, g), x(this, fo, b), x(this, Qh, s), x(this, Sr, Tb.toDateObject(o)), this.trigger = s.flatMap((C) => C.getElementsToTriggerPopup());
      for (const C of this.trigger)
        C.addEventListener("click", r(this, uo)), C.addEventListener("mouseenter", r(this, _f)), C.addEventListener("mouseleave", r(this, Lf)), C.classList.add("popupTriggerArea");
      for (const C of s)
        (T = C.container) == null || T.addEventListener("keydown", r(this, co));
      r(this, Xt).hidden = !0, S && E(this, go, Hp).call(this);
    }
    render() {
      if (r(this, hs))
        return;
      const t = x(this, hs, document.createElement("div"));
      if (t.className = "popup", r(this, wr)) {
        const o = t.style.outlineColor = et.makeHexColor(...r(this, wr));
        CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? t.style.backgroundColor = `color-mix(in srgb, ${o} 30%, white)` : t.style.backgroundColor = et.makeHexColor(...r(this, wr).map((c) => Math.floor(0.7 * (255 - c) + c)));
      }
      const e = document.createElement("span");
      e.className = "header";
      const s = document.createElement("h1");
      if (e.append(s), {
        dir: s.dir,
        str: s.textContent
      } = r(this, qh), t.append(e), r(this, Sr)) {
        const o = document.createElement("span");
        o.classList.add("popupDate"), o.setAttribute("data-l10n-id", "pdfjs-annotation-date-string"), o.setAttribute("data-l10n-args", JSON.stringify({
          date: r(this, Sr).toLocaleDateString(),
          time: r(this, Sr).toLocaleTimeString()
        })), e.append(o);
      }
      const a = r(this, po, jp);
      if (a)
        ty.render({
          xfaHtml: a,
          intent: "richText",
          div: t
        }), t.lastChild.classList.add("richText", "popupContent");
      else {
        const o = this._formatContents(r(this, pi));
        t.append(o);
      }
      r(this, Xt).append(t);
    }
    _formatContents({
      str: t,
      dir: e
    }) {
      const s = document.createElement("p");
      s.classList.add("popupContent"), s.dir = e;
      const a = t.split(/(?:\r\n?|\n)/);
      for (let o = 0, h = a.length; o < h; ++o) {
        const c = a[o];
        s.append(document.createTextNode(c)), o < h - 1 && s.append(document.createElement("br"));
      }
      return s;
    }
    updateEdited({
      rect: t,
      popupContent: e
    }) {
      var s;
      r(this, xr) || x(this, xr, {
        contentsObj: r(this, pi),
        richText: r(this, vi)
      }), t && x(this, mi, null), e && (x(this, vi, E(this, Of, RA).call(this, e)), x(this, pi, null)), (s = r(this, hs)) == null || s.remove(), x(this, hs, null);
    }
    resetEdited() {
      var t;
      r(this, xr) && ({
        contentsObj: De(this, pi)._,
        richText: De(this, vi)._
      } = r(this, xr), x(this, xr, null), (t = r(this, hs)) == null || t.remove(), x(this, hs, null), x(this, mi, null));
    }
    forceHide() {
      x(this, Pr, this.isVisible), r(this, Pr) && (r(this, Xt).hidden = !0);
    }
    maybeShow() {
      r(this, Pr) && (r(this, hs) || E(this, mo, Vp).call(this), x(this, Pr, !1), r(this, Xt).hidden = !1);
    }
    get isVisible() {
      return r(this, Xt).hidden === !1;
    }
  }
  co = new WeakMap(), Lf = new WeakMap(), _f = new WeakMap(), uo = new WeakMap(), wr = new WeakMap(), Xt = new WeakMap(), pi = new WeakMap(), Sr = new WeakMap(), Qh = new WeakMap(), Zh = new WeakMap(), fo = new WeakMap(), gi = new WeakMap(), hs = new WeakMap(), mi = new WeakMap(), Jh = new WeakMap(), vi = new WeakMap(), qh = new WeakMap(), xr = new WeakMap(), Pr = new WeakMap(), po = new WeakSet(), jp = function() {
    const t = r(this, vi), e = r(this, pi);
    return t != null && t.str && (!(e != null && e.str) || e.str === t.str) && r(this, vi).html || null;
  }, tc = new WeakSet(), mv = function() {
    var t, e, s;
    return ((s = (e = (t = r(this, po, jp)) == null ? void 0 : t.attributes) == null ? void 0 : e.style) == null ? void 0 : s.fontSize) || 0;
  }, Mf = new WeakSet(), CA = function() {
    var t, e, s;
    return ((s = (e = (t = r(this, po, jp)) == null ? void 0 : t.attributes) == null ? void 0 : e.style) == null ? void 0 : s.color) || null;
  }, Of = new WeakSet(), RA = function(t) {
    const e = [], s = {
      str: t,
      html: {
        name: "div",
        attributes: {
          dir: "auto"
        },
        children: [{
          name: "p",
          children: e
        }]
      }
    }, a = {
      style: {
        color: r(this, Mf, CA),
        fontSize: r(this, tc, mv) ? `calc(${r(this, tc, mv)}px * var(--scale-factor))` : ""
      }
    };
    for (const o of t.split(`
`))
      e.push({
        name: "span",
        value: o,
        attributes: a
      });
    return s;
  }, kf = new WeakSet(), IA = function(t) {
    t.altKey || t.shiftKey || t.ctrlKey || t.metaKey || (t.key === "Enter" || t.key === "Escape" && r(this, gi)) && E(this, go, Hp).call(this);
  }, Df = new WeakSet(), LA = function() {
    if (r(this, mi) !== null)
      return;
    const {
      page: {
        view: t
      },
      viewport: {
        rawDims: {
          pageWidth: e,
          pageHeight: s,
          pageX: a,
          pageY: o
        }
      }
    } = r(this, Zh);
    let h = !!r(this, fo), c = h ? r(this, fo) : r(this, Jh);
    for (const R of r(this, Qh))
      if (!c || et.intersect(R.data.rect, c) !== null) {
        c = R.data.rect, h = !0;
        break;
      }
    const p = et.normalizeRect([c[0], t[3] - c[1] + t[1], c[2], t[3] - c[3] + t[1]]), g = 5, b = h ? c[2] - c[0] + g : 0, S = p[0] + b, T = p[1];
    x(this, mi, [100 * (S - a) / e, 100 * (T - o) / s]);
    const {
      style: C
    } = r(this, Xt);
    C.left = `${r(this, mi)[0]}%`, C.top = `${r(this, mi)[1]}%`;
  }, go = new WeakSet(), Hp = function() {
    x(this, gi, !r(this, gi)), r(this, gi) ? (E(this, mo, Vp).call(this), r(this, Xt).addEventListener("click", r(this, uo)), r(this, Xt).addEventListener("keydown", r(this, co))) : (E(this, ec, vv).call(this), r(this, Xt).removeEventListener("click", r(this, uo)), r(this, Xt).removeEventListener("keydown", r(this, co)));
  }, mo = new WeakSet(), Vp = function() {
    r(this, hs) || this.render(), this.isVisible ? r(this, gi) && r(this, Xt).classList.add("focused") : (E(this, Df, LA).call(this), r(this, Xt).hidden = !1, r(this, Xt).style.zIndex = parseInt(r(this, Xt).style.zIndex) + 1e3);
  }, ec = new WeakSet(), vv = function() {
    r(this, Xt).classList.remove("focused"), !(r(this, gi) || !this.isVisible) && (r(this, Xt).hidden = !0, r(this, Xt).style.zIndex = parseInt(r(this, Xt).style.zIndex) - 1e3);
  };
  class iy extends Yt {
    constructor(t) {
      super(t, {
        isRenderable: !0,
        ignoreBorder: !0
      }), this.textContent = t.data.textContent, this.textPosition = t.data.textPosition, this.annotationEditorType = w.FREETEXT;
    }
    render() {
      if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
        const t = document.createElement("div");
        t.classList.add("annotationTextContent"), t.setAttribute("role", "comment");
        for (const e of this.textContent) {
          const s = document.createElement("span");
          s.textContent = e, t.append(s);
        }
        this.container.append(t);
      }
      return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
    }
    get _isEditable() {
      return this.data.hasOwnCanvas;
    }
  }
  class Dw extends Yt {
    constructor(e) {
      super(e, {
        isRenderable: !0,
        ignoreBorder: !0
      });
      v(this, sc, null);
    }
    render() {
      this.container.classList.add("lineAnnotation");
      const e = this.data, {
        width: s,
        height: a
      } = Js(e.rect), o = this.svgFactory.create(s, a, !0), h = x(this, sc, this.svgFactory.createElement("svg:line"));
      return h.setAttribute("x1", e.rect[2] - e.lineCoordinates[0]), h.setAttribute("y1", e.rect[3] - e.lineCoordinates[1]), h.setAttribute("x2", e.rect[2] - e.lineCoordinates[2]), h.setAttribute("y2", e.rect[3] - e.lineCoordinates[3]), h.setAttribute("stroke-width", e.borderStyle.width || 1), h.setAttribute("stroke", "transparent"), h.setAttribute("fill", "transparent"), o.append(h), this.container.append(o), !e.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
    getElementsToTriggerPopup() {
      return r(this, sc);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  sc = new WeakMap();
  class Nw extends Yt {
    constructor(e) {
      super(e, {
        isRenderable: !0,
        ignoreBorder: !0
      });
      v(this, ic, null);
    }
    render() {
      this.container.classList.add("squareAnnotation");
      const e = this.data, {
        width: s,
        height: a
      } = Js(e.rect), o = this.svgFactory.create(s, a, !0), h = e.borderStyle.width, c = x(this, ic, this.svgFactory.createElement("svg:rect"));
      return c.setAttribute("x", h / 2), c.setAttribute("y", h / 2), c.setAttribute("width", s - h), c.setAttribute("height", a - h), c.setAttribute("stroke-width", h || 1), c.setAttribute("stroke", "transparent"), c.setAttribute("fill", "transparent"), o.append(c), this.container.append(o), !e.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
    getElementsToTriggerPopup() {
      return r(this, ic);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  ic = new WeakMap();
  class Fw extends Yt {
    constructor(e) {
      super(e, {
        isRenderable: !0,
        ignoreBorder: !0
      });
      v(this, nc, null);
    }
    render() {
      this.container.classList.add("circleAnnotation");
      const e = this.data, {
        width: s,
        height: a
      } = Js(e.rect), o = this.svgFactory.create(s, a, !0), h = e.borderStyle.width, c = x(this, nc, this.svgFactory.createElement("svg:ellipse"));
      return c.setAttribute("cx", s / 2), c.setAttribute("cy", a / 2), c.setAttribute("rx", s / 2 - h / 2), c.setAttribute("ry", a / 2 - h / 2), c.setAttribute("stroke-width", h || 1), c.setAttribute("stroke", "transparent"), c.setAttribute("fill", "transparent"), o.append(c), this.container.append(o), !e.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
    getElementsToTriggerPopup() {
      return r(this, nc);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  nc = new WeakMap();
  class ny extends Yt {
    constructor(e) {
      super(e, {
        isRenderable: !0,
        ignoreBorder: !0
      });
      v(this, rc, null);
      this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
    }
    render() {
      this.container.classList.add(this.containerClassName);
      const e = this.data, {
        width: s,
        height: a
      } = Js(e.rect), o = this.svgFactory.create(s, a, !0);
      let h = [];
      for (const p of e.vertices) {
        const g = p.x - e.rect[0], b = e.rect[3] - p.y;
        h.push(g + "," + b);
      }
      h = h.join(" ");
      const c = x(this, rc, this.svgFactory.createElement(this.svgElementName));
      return c.setAttribute("points", h), c.setAttribute("stroke-width", e.borderStyle.width || 1), c.setAttribute("stroke", "transparent"), c.setAttribute("fill", "transparent"), o.append(c), this.container.append(o), !e.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
    getElementsToTriggerPopup() {
      return r(this, rc);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  rc = new WeakMap();
  class Bw extends ny {
    constructor(t) {
      super(t), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
    }
  }
  class jw extends Yt {
    constructor(t) {
      super(t, {
        isRenderable: !0,
        ignoreBorder: !0
      });
    }
    render() {
      return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
  }
  class ry extends Yt {
    constructor(e) {
      super(e, {
        isRenderable: !0,
        ignoreBorder: !0
      });
      v(this, ac, []);
      this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = w.INK;
    }
    render() {
      this.container.classList.add(this.containerClassName);
      const e = this.data, {
        width: s,
        height: a
      } = Js(e.rect), o = this.svgFactory.create(s, a, !0);
      for (const h of e.inkLists) {
        let c = [];
        for (const g of h) {
          const b = g.x - e.rect[0], S = e.rect[3] - g.y;
          c.push(`${b},${S}`);
        }
        c = c.join(" ");
        const p = this.svgFactory.createElement(this.svgElementName);
        r(this, ac).push(p), p.setAttribute("points", c), p.setAttribute("stroke-width", e.borderStyle.width || 1), p.setAttribute("stroke", "transparent"), p.setAttribute("fill", "transparent"), !e.popupRef && this.hasPopupData && this._createPopup(), o.append(p);
      }
      return this.container.append(o), this.container;
    }
    getElementsToTriggerPopup() {
      return r(this, ac);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  ac = new WeakMap();
  class Hw extends Yt {
    constructor(t) {
      super(t, {
        isRenderable: !0,
        ignoreBorder: !0,
        createQuadrilaterals: !0
      });
    }
    render() {
      return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this.container;
    }
  }
  class Vw extends Yt {
    constructor(t) {
      super(t, {
        isRenderable: !0,
        ignoreBorder: !0,
        createQuadrilaterals: !0
      });
    }
    render() {
      return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
    }
  }
  class $w extends Yt {
    constructor(t) {
      super(t, {
        isRenderable: !0,
        ignoreBorder: !0,
        createQuadrilaterals: !0
      });
    }
    render() {
      return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
    }
  }
  class Uw extends Yt {
    constructor(t) {
      super(t, {
        isRenderable: !0,
        ignoreBorder: !0,
        createQuadrilaterals: !0
      });
    }
    render() {
      return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
    }
  }
  class ay extends Yt {
    constructor(t) {
      super(t, {
        isRenderable: !0,
        ignoreBorder: !0
      });
    }
    render() {
      return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
  }
  class zw extends Yt {
    constructor(e) {
      var a;
      super(e, {
        isRenderable: !0
      });
      v(this, lc);
      v(this, oc, null);
      const {
        file: s
      } = this.data;
      this.filename = s.filename, this.content = s.content, (a = this.linkService.eventBus) == null || a.dispatch("fileattachmentannotation", {
        source: this,
        ...s
      });
    }
    render() {
      this.container.classList.add("fileAttachmentAnnotation");
      const {
        container: e,
        data: s
      } = this;
      let a;
      s.hasAppearance || s.fillAlpha === 0 ? a = document.createElement("div") : (a = document.createElement("img"), a.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(s.name) ? "paperclip" : "pushpin"}.svg`, s.fillAlpha && s.fillAlpha < 1 && (a.style = `filter: opacity(${Math.round(s.fillAlpha * 100)}%);`)), a.addEventListener("dblclick", E(this, lc, bv).bind(this)), x(this, oc, a);
      const {
        isMac: o
      } = nt.platform;
      return e.addEventListener("keydown", (h) => {
        h.key === "Enter" && (o ? h.metaKey : h.ctrlKey) && E(this, lc, bv).call(this);
      }), !s.popupRef && this.hasPopupData ? this._createPopup() : a.classList.add("popupTriggerArea"), e.append(a), e;
    }
    getElementsToTriggerPopup() {
      return r(this, oc);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  oc = new WeakMap(), lc = new WeakSet(), bv = function() {
    var e;
    (e = this.downloadManager) == null || e.openOrDownloadData(this.content, this.filename);
  };
  class Ww {
    constructor({
      div: t,
      accessibilityManager: e,
      annotationCanvasMap: s,
      annotationEditorUIManager: a,
      page: o,
      viewport: h
    }) {
      v(this, Nf);
      v(this, cc);
      v(this, hc, null);
      v(this, Tr, null);
      v(this, vo, /* @__PURE__ */ new Map());
      this.div = t, x(this, hc, e), x(this, Tr, s), this.page = o, this.viewport = h, this.zIndex = 0, this._annotationEditorUIManager = a;
    }
    async render(t) {
      var h;
      const {
        annotations: e
      } = t, s = this.div;
      jn(s, this.viewport);
      const a = /* @__PURE__ */ new Map(), o = {
        data: null,
        layer: s,
        linkService: t.linkService,
        downloadManager: t.downloadManager,
        imageResourcesPath: t.imageResourcesPath || "",
        renderForms: t.renderForms !== !1,
        svgFactory: new em(),
        annotationStorage: t.annotationStorage || new cm(),
        enableScripting: t.enableScripting === !0,
        hasJSActions: t.hasJSActions,
        fieldObjects: t.fieldObjects,
        parent: this,
        elements: null
      };
      for (const c of e) {
        if (c.noHTML)
          continue;
        const p = c.annotationType === D.POPUP;
        if (p) {
          const S = a.get(c.id);
          if (!S)
            continue;
          o.elements = S;
        } else {
          const {
            width: S,
            height: T
          } = Js(c.rect);
          if (S <= 0 || T <= 0)
            continue;
        }
        o.data = c;
        const g = Cw.create(o);
        if (!g.isRenderable)
          continue;
        if (!p && c.popupRef) {
          const S = a.get(c.popupRef);
          S ? S.push(g) : a.set(c.popupRef, [g]);
        }
        const b = g.render();
        c.hidden && (b.style.visibility = "hidden"), E(this, Nf, _A).call(this, b, c.id), g.annotationEditorType > 0 && (r(this, vo).set(g.data.id, g), (h = this._annotationEditorUIManager) == null || h.renderAnnotationElement(g));
      }
      E(this, cc, yv).call(this);
    }
    update({
      viewport: t
    }) {
      const e = this.div;
      this.viewport = t, jn(e, {
        rotation: t.rotation
      }), E(this, cc, yv).call(this), e.hidden = !1;
    }
    getEditableAnnotations() {
      return Array.from(r(this, vo).values());
    }
    getEditableAnnotation(t) {
      return r(this, vo).get(t);
    }
  }
  hc = new WeakMap(), Tr = new WeakMap(), vo = new WeakMap(), Nf = new WeakSet(), _A = function(t, e) {
    var a;
    const s = t.firstChild || t;
    s.id = `${ne}${e}`, this.div.append(t), (a = r(this, hc)) == null || a.moveElementInDOM(this.div, t, s, !1);
  }, cc = new WeakSet(), yv = function() {
    if (!r(this, Tr))
      return;
    const t = this.div;
    for (const [e, s] of r(this, Tr)) {
      const a = t.querySelector(`[data-annotation-id="${e}"]`);
      if (!a)
        continue;
      s.className = "annotationContent";
      const {
        firstChild: o
      } = a;
      o ? o.nodeName === "CANVAS" ? o.replaceWith(s) : o.classList.contains("annotationContent") ? o.after(s) : o.before(s) : a.append(s);
    }
    r(this, Tr).clear();
  };
  const Fu = /\r\n?|\n/g, kt = class kt extends Rt {
    constructor(e) {
      super({
        ...e,
        name: "freeTextEditor"
      });
      v(this, Ff);
      v(this, Bf);
      v(this, jf);
      v(this, yo);
      v(this, Eo);
      v(this, Hf);
      v(this, Vf);
      v(this, dc, this.editorDivBlur.bind(this));
      v(this, uc, this.editorDivFocus.bind(this));
      v(this, fc, this.editorDivInput.bind(this));
      v(this, pc, this.editorDivKeydown.bind(this));
      v(this, gc, this.editorDivPaste.bind(this));
      v(this, cs, void 0);
      v(this, je, "");
      v(this, mc, `${this.id}-editor`);
      v(this, He, void 0);
      v(this, bo, null);
      x(this, cs, e.color || kt._defaultColor || Rt._defaultLineColor), x(this, He, e.fontSize || kt._defaultFontSize);
    }
    static get _keyboardManager() {
      const e = kt.prototype, s = (h) => h.isEmpty(), a = Hn.TRANSLATE_SMALL, o = Hn.TRANSLATE_BIG;
      return tt(this, "_keyboardManager", new Ll([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], e.commitOrRemove, {
        bubbles: !0
      }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], e.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], e._translateEmpty, {
        args: [-a, 0],
        checker: s
      }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e._translateEmpty, {
        args: [-o, 0],
        checker: s
      }], [["ArrowRight", "mac+ArrowRight"], e._translateEmpty, {
        args: [a, 0],
        checker: s
      }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e._translateEmpty, {
        args: [o, 0],
        checker: s
      }], [["ArrowUp", "mac+ArrowUp"], e._translateEmpty, {
        args: [0, -a],
        checker: s
      }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e._translateEmpty, {
        args: [0, -o],
        checker: s
      }], [["ArrowDown", "mac+ArrowDown"], e._translateEmpty, {
        args: [0, a],
        checker: s
      }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e._translateEmpty, {
        args: [0, o],
        checker: s
      }]]));
    }
    static initialize(e, s) {
      Rt.initialize(e, s, {
        strings: ["pdfjs-free-text-default-content"]
      });
      const a = getComputedStyle(document.documentElement);
      this._internalPadding = parseFloat(a.getPropertyValue("--freetext-padding"));
    }
    static updateDefaultParams(e, s) {
      switch (e) {
        case P.FREETEXT_SIZE:
          kt._defaultFontSize = s;
          break;
        case P.FREETEXT_COLOR:
          kt._defaultColor = s;
          break;
      }
    }
    updateParams(e, s) {
      switch (e) {
        case P.FREETEXT_SIZE:
          E(this, Ff, MA).call(this, s);
          break;
        case P.FREETEXT_COLOR:
          E(this, Bf, OA).call(this, s);
          break;
      }
    }
    static get defaultPropertiesToUpdate() {
      return [[P.FREETEXT_SIZE, kt._defaultFontSize], [P.FREETEXT_COLOR, kt._defaultColor || Rt._defaultLineColor]];
    }
    get propertiesToUpdate() {
      return [[P.FREETEXT_SIZE, r(this, He)], [P.FREETEXT_COLOR, r(this, cs)]];
    }
    _translateEmpty(e, s) {
      this._uiManager.translateSelectedEditors(e, s, !0);
    }
    getInitialTranslation() {
      const e = this.parentScale;
      return [-kt._internalPadding * e, -(kt._internalPadding + r(this, He)) * e];
    }
    rebuild() {
      this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
    }
    enableEditMode() {
      this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(w.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), this.editorDiv.addEventListener("keydown", r(this, pc)), this.editorDiv.addEventListener("focus", r(this, uc)), this.editorDiv.addEventListener("blur", r(this, dc)), this.editorDiv.addEventListener("input", r(this, fc)), this.editorDiv.addEventListener("paste", r(this, gc)));
    }
    disableEditMode() {
      this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", r(this, mc)), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", r(this, pc)), this.editorDiv.removeEventListener("focus", r(this, uc)), this.editorDiv.removeEventListener("blur", r(this, dc)), this.editorDiv.removeEventListener("input", r(this, fc)), this.editorDiv.removeEventListener("paste", r(this, gc)), this.div.focus({
        preventScroll: !0
      }), this.isEditing = !1, this.parent.div.classList.add("freetextEditing"));
    }
    focusin(e) {
      this._focusEventsAllowed && (super.focusin(e), e.target !== this.editorDiv && this.editorDiv.focus());
    }
    onceAdded() {
      var e;
      this.width || (this.enableEditMode(), this.editorDiv.focus(), (e = this._initialOptions) != null && e.isCentered && this.center(), this._initialOptions = null);
    }
    isEmpty() {
      return !this.editorDiv || this.editorDiv.innerText.trim() === "";
    }
    remove() {
      this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freetextEditing")), super.remove();
    }
    commit() {
      if (!this.isInEditMode())
        return;
      super.commit(), this.disableEditMode();
      const e = r(this, je), s = x(this, je, E(this, jf, kA).call(this).trimEnd());
      if (e === s)
        return;
      const a = (o) => {
        if (x(this, je, o), !o) {
          this.remove();
          return;
        }
        E(this, Eo, zp).call(this), this._uiManager.rebuild(this), E(this, yo, $p).call(this);
      };
      this.addCommands({
        cmd: () => {
          a(s);
        },
        undo: () => {
          a(e);
        },
        mustExec: !1
      }), E(this, yo, $p).call(this);
    }
    shouldGetKeyboardEvents() {
      return this.isInEditMode();
    }
    enterInEditMode() {
      this.enableEditMode(), this.editorDiv.focus();
    }
    dblclick(e) {
      this.enterInEditMode();
    }
    keydown(e) {
      e.target === this.div && e.key === "Enter" && (this.enterInEditMode(), e.preventDefault());
    }
    editorDivKeydown(e) {
      kt._keyboardManager.exec(this, e);
    }
    editorDivFocus(e) {
      this.isEditing = !0;
    }
    editorDivBlur(e) {
      this.isEditing = !1;
    }
    editorDivInput(e) {
      this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
    }
    disableEditing() {
      this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
    }
    enableEditing() {
      this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
    }
    render() {
      if (this.div)
        return this.div;
      let e, s;
      this.width && (e = this.x, s = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", r(this, mc)), this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text"), this.enableEditing(), Rt._l10nPromise.get("pdfjs-free-text-default-content").then((o) => {
        var h;
        return (h = this.editorDiv) == null ? void 0 : h.setAttribute("default-content", o);
      }), this.editorDiv.contentEditable = !0;
      const {
        style: a
      } = this.editorDiv;
      if (a.fontSize = `calc(${r(this, He)}px * var(--scale-factor))`, a.color = r(this, cs), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), Iu(this, this.div, ["dblclick", "keydown"]), this.width) {
        const [o, h] = this.parentDimensions;
        if (this.annotationElementId) {
          const {
            position: c
          } = r(this, bo);
          let [p, g] = this.getInitialTranslation();
          [p, g] = this.pageTranslationToScreen(p, g);
          const [b, S] = this.pageDimensions, [T, C] = this.pageTranslation;
          let R, M;
          switch (this.rotation) {
            case 0:
              R = e + (c[0] - T) / b, M = s + this.height - (c[1] - C) / S;
              break;
            case 90:
              R = e + (c[0] - T) / b, M = s - (c[1] - C) / S, [p, g] = [g, -p];
              break;
            case 180:
              R = e - this.width + (c[0] - T) / b, M = s - (c[1] - C) / S, [p, g] = [-p, -g];
              break;
            case 270:
              R = e + (c[0] - T - this.height * S) / b, M = s + (c[1] - C - this.width * b) / S, [p, g] = [-g, p];
              break;
          }
          this.setAt(R * o, M * h, p, g);
        } else
          this.setAt(e * o, s * h, this.width * o, this.height * h);
        E(this, Eo, zp).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
      } else
        this._isDraggable = !1, this.editorDiv.contentEditable = !0;
      return this.div;
    }
    editorDivPaste(e) {
      var R, M, F;
      const s = e.clipboardData || window.clipboardData, {
        types: a
      } = s;
      if (a.length === 1 && a[0] === "text/plain")
        return;
      e.preventDefault();
      const o = E(R = kt, vc, Av).call(R, s.getData("text") || "").replaceAll(Fu, `
`);
      if (!o)
        return;
      const h = window.getSelection();
      if (!h.rangeCount)
        return;
      this.editorDiv.normalize(), h.deleteFromDocument();
      const c = h.getRangeAt(0);
      if (!o.includes(`
`)) {
        c.insertNode(document.createTextNode(o)), this.editorDiv.normalize(), h.collapseToStart();
        return;
      }
      const {
        startContainer: p,
        startOffset: g
      } = c, b = [], S = [];
      if (p.nodeType === Node.TEXT_NODE) {
        const O = p.parentElement;
        if (S.push(p.nodeValue.slice(g).replaceAll(Fu, "")), O !== this.editorDiv) {
          let U = b;
          for (const Y of this.editorDiv.childNodes) {
            if (Y === O) {
              U = S;
              continue;
            }
            U.push(E(M = kt, Ao, Up).call(M, Y));
          }
        }
        b.push(p.nodeValue.slice(0, g).replaceAll(Fu, ""));
      } else if (p === this.editorDiv) {
        let O = b, U = 0;
        for (const Y of this.editorDiv.childNodes)
          U++ === g && (O = S), O.push(E(F = kt, Ao, Up).call(F, Y));
      }
      x(this, je, `${b.join(`
`)}${o}${S.join(`
`)}`), E(this, Eo, zp).call(this);
      const T = new Range();
      let C = b.reduce((O, U) => O + U.length, 0);
      for (const {
        firstChild: O
      } of this.editorDiv.childNodes)
        if (O.nodeType === Node.TEXT_NODE) {
          const U = O.nodeValue.length;
          if (C <= U) {
            T.setStart(O, C), T.setEnd(O, C);
            break;
          }
          C -= U;
        }
      h.removeAllRanges(), h.addRange(T);
    }
    get contentDiv() {
      return this.editorDiv;
    }
    static deserialize(e, s, a) {
      var c;
      let o = null;
      if (e instanceof iy) {
        const {
          data: {
            defaultAppearanceData: {
              fontSize: p,
              fontColor: g
            },
            rect: b,
            rotation: S,
            id: T
          },
          textContent: C,
          textPosition: R,
          parent: {
            page: {
              pageNumber: M
            }
          }
        } = e;
        if (!C || C.length === 0)
          return null;
        o = e = {
          annotationType: w.FREETEXT,
          color: Array.from(g),
          fontSize: p,
          value: C.join(`
`),
          position: R,
          pageIndex: M - 1,
          rect: b.slice(0),
          rotation: S,
          id: T,
          deleted: !1
        };
      }
      const h = super.deserialize(e, s, a);
      return x(h, He, e.fontSize), x(h, cs, et.makeHexColor(...e.color)), x(h, je, E(c = kt, vc, Av).call(c, e.value)), h.annotationElementId = e.id || null, x(h, bo, o), h;
    }
    serialize(e = !1) {
      if (this.isEmpty())
        return null;
      if (this.deleted)
        return {
          pageIndex: this.pageIndex,
          id: this.annotationElementId,
          deleted: !0
        };
      const s = kt._internalPadding * this.parentScale, a = this.getRect(s, s), o = Rt._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : r(this, cs)), h = {
        annotationType: w.FREETEXT,
        color: o,
        fontSize: r(this, He),
        value: E(this, Hf, DA).call(this),
        pageIndex: this.pageIndex,
        rect: a,
        rotation: this.rotation,
        structTreeParentId: this._structTreeParentId
      };
      return e ? h : this.annotationElementId && !E(this, Vf, NA).call(this, h) ? null : (h.id = this.annotationElementId, h);
    }
    renderAnnotationElement(e) {
      const s = super.renderAnnotationElement(e);
      if (this.deleted)
        return s;
      const {
        style: a
      } = s;
      a.fontSize = `calc(${r(this, He)}px * var(--scale-factor))`, a.color = r(this, cs), s.replaceChildren();
      for (const h of r(this, je).split(`
`)) {
        const c = document.createElement("div");
        c.append(h ? document.createTextNode(h) : document.createElement("br")), s.append(c);
      }
      const o = kt._internalPadding * this.parentScale;
      return e.updateEdited({
        rect: this.getRect(o, o),
        popupContent: r(this, je)
      }), s;
    }
    resetAnnotationElement(e) {
      super.resetAnnotationElement(e), e.resetEdited();
    }
  };
  dc = new WeakMap(), uc = new WeakMap(), fc = new WeakMap(), pc = new WeakMap(), gc = new WeakMap(), cs = new WeakMap(), je = new WeakMap(), mc = new WeakMap(), He = new WeakMap(), bo = new WeakMap(), Ff = new WeakSet(), MA = function(e) {
    const s = (o) => {
      this.editorDiv.style.fontSize = `calc(${o}px * var(--scale-factor))`, this.translate(0, -(o - r(this, He)) * this.parentScale), x(this, He, o), E(this, yo, $p).call(this);
    }, a = r(this, He);
    this.addCommands({
      cmd: s.bind(this, e),
      undo: s.bind(this, a),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: !0,
      type: P.FREETEXT_SIZE,
      overwriteIfSameType: !0,
      keepUndo: !0
    });
  }, Bf = new WeakSet(), OA = function(e) {
    const s = (o) => {
      x(this, cs, this.editorDiv.style.color = o);
    }, a = r(this, cs);
    this.addCommands({
      cmd: s.bind(this, e),
      undo: s.bind(this, a),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: !0,
      type: P.FREETEXT_COLOR,
      overwriteIfSameType: !0,
      keepUndo: !0
    });
  }, jf = new WeakSet(), kA = function() {
    var s;
    const e = [];
    this.editorDiv.normalize();
    for (const a of this.editorDiv.childNodes)
      e.push(E(s = kt, Ao, Up).call(s, a));
    return e.join(`
`);
  }, yo = new WeakSet(), $p = function() {
    const [e, s] = this.parentDimensions;
    let a;
    if (this.isAttachedToDOM)
      a = this.div.getBoundingClientRect();
    else {
      const {
        currentLayer: o,
        div: h
      } = this, c = h.style.display, p = h.classList.contains("hidden");
      h.classList.remove("hidden"), h.style.display = "hidden", o.div.append(this.div), a = h.getBoundingClientRect(), h.remove(), h.style.display = c, h.classList.toggle("hidden", p);
    }
    this.rotation % 180 === this.parentRotation % 180 ? (this.width = a.width / e, this.height = a.height / s) : (this.width = a.height / e, this.height = a.width / s), this.fixAndSetPosition();
  }, Ao = new WeakSet(), Up = function(e) {
    return (e.nodeType === Node.TEXT_NODE ? e.nodeValue : e.innerText).replaceAll(Fu, "");
  }, Eo = new WeakSet(), zp = function() {
    if (this.editorDiv.replaceChildren(), !!r(this, je))
      for (const e of r(this, je).split(`
`)) {
        const s = document.createElement("div");
        s.append(e ? document.createTextNode(e) : document.createElement("br")), this.editorDiv.append(s);
      }
  }, Hf = new WeakSet(), DA = function() {
    return r(this, je).replaceAll(" ", " ");
  }, vc = new WeakSet(), Av = function(e) {
    return e.replaceAll(" ", " ");
  }, Vf = new WeakSet(), NA = function(e) {
    const {
      value: s,
      fontSize: a,
      color: o,
      pageIndex: h
    } = r(this, bo);
    return this._hasBeenMoved || e.value !== s || e.fontSize !== a || e.color.some((c, p) => c !== o[p]) || e.pageIndex !== h;
  }, v(kt, Ao), v(kt, vc), bt(kt, "_freeTextDefaultContent", ""), bt(kt, "_internalPadding", 0), bt(kt, "_defaultColor", null), bt(kt, "_defaultFontSize", 10), bt(kt, "_type", "freetext"), bt(kt, "_editorType", w.FREETEXT);
  let wm = kt;
  class Sm {
    constructor(t, e = 0, s = 0, a = !0) {
      v(this, $f);
      v(this, wo);
      v(this, Uf);
      v(this, zf);
      v(this, yc);
      v(this, bc, void 0);
      v(this, nn, []);
      v(this, ds, []);
      let o = 1 / 0, h = -1 / 0, c = 1 / 0, p = -1 / 0;
      const b = 10 ** -4;
      for (const {
        x: O,
        y: U,
        width: Y,
        height: J
      } of t) {
        const rt = Math.floor((O - e) / b) * b, st = Math.ceil((O + Y + e) / b) * b, ot = Math.floor((U - e) / b) * b, ft = Math.ceil((U + J + e) / b) * b, yt = [rt, ot, ft, !0], St = [st, ot, ft, !1];
        r(this, nn).push(yt, St), o = Math.min(o, rt), h = Math.max(h, st), c = Math.min(c, ot), p = Math.max(p, ft);
      }
      const S = h - o + 2 * s, T = p - c + 2 * s, C = o - s, R = c - s, M = r(this, nn).at(a ? -1 : -2), F = [M[0], M[2]];
      for (const O of r(this, nn)) {
        const [U, Y, J] = O;
        O[0] = (U - C) / S, O[1] = (Y - R) / T, O[2] = (J - R) / T;
      }
      x(this, bc, {
        x: C,
        y: R,
        width: S,
        height: T,
        lastPoint: F
      });
    }
    getOutlines() {
      r(this, nn).sort((e, s) => e[0] - s[0] || e[1] - s[1] || e[2] - s[2]);
      const t = [];
      for (const e of r(this, nn))
        e[3] ? (t.push(...E(this, yc, Ev).call(this, e)), E(this, Uf, BA).call(this, e)) : (E(this, zf, jA).call(this, e), t.push(...E(this, yc, Ev).call(this, e)));
      return E(this, $f, FA).call(this, t);
    }
  }
  bc = new WeakMap(), nn = new WeakMap(), ds = new WeakMap(), $f = new WeakSet(), FA = function(t) {
    const e = [], s = /* @__PURE__ */ new Set();
    for (const h of t) {
      const [c, p, g] = h;
      e.push([c, p, h], [c, g, h]);
    }
    e.sort((h, c) => h[1] - c[1] || h[0] - c[0]);
    for (let h = 0, c = e.length; h < c; h += 2) {
      const p = e[h][2], g = e[h + 1][2];
      p.push(g), g.push(p), s.add(p), s.add(g);
    }
    const a = [];
    let o;
    for (; s.size > 0; ) {
      const h = s.values().next().value;
      let [c, p, g, b, S] = h;
      s.delete(h);
      let T = c, C = p;
      for (o = [c, g], a.push(o); ; ) {
        let R;
        if (s.has(b))
          R = b;
        else if (s.has(S))
          R = S;
        else
          break;
        s.delete(R), [c, p, g, b, S] = R, T !== c && (o.push(T, C, c, C === p ? p : g), T = c), C = C === p ? g : p;
      }
      o.push(T, C);
    }
    return new Gw(a, r(this, bc));
  }, wo = new WeakSet(), Wp = function(t) {
    const e = r(this, ds);
    let s = 0, a = e.length - 1;
    for (; s <= a; ) {
      const o = s + a >> 1, h = e[o][0];
      if (h === t)
        return o;
      h < t ? s = o + 1 : a = o - 1;
    }
    return a + 1;
  }, Uf = new WeakSet(), BA = function([, t, e]) {
    const s = E(this, wo, Wp).call(this, t);
    r(this, ds).splice(s, 0, [t, e]);
  }, zf = new WeakSet(), jA = function([, t, e]) {
    const s = E(this, wo, Wp).call(this, t);
    for (let a = s; a < r(this, ds).length; a++) {
      const [o, h] = r(this, ds)[a];
      if (o !== t)
        break;
      if (o === t && h === e) {
        r(this, ds).splice(a, 1);
        return;
      }
    }
    for (let a = s - 1; a >= 0; a--) {
      const [o, h] = r(this, ds)[a];
      if (o !== t)
        break;
      if (o === t && h === e) {
        r(this, ds).splice(a, 1);
        return;
      }
    }
  }, yc = new WeakSet(), Ev = function(t) {
    const [e, s, a] = t, o = [[e, s, a]], h = E(this, wo, Wp).call(this, a);
    for (let c = 0; c < h; c++) {
      const [p, g] = r(this, ds)[c];
      for (let b = 0, S = o.length; b < S; b++) {
        const [, T, C] = o[b];
        if (!(g <= T || C <= p)) {
          if (T >= p) {
            if (C > g)
              o[b][1] = g;
            else {
              if (S === 1)
                return [];
              o.splice(b, 1), b--, S--;
            }
            continue;
          }
          o[b][2] = p, C > g && o.push([e, g, C]);
        }
      }
    }
    return o;
  };
  class oy {
    toSVGPath() {
      throw new Error("Abstract method `toSVGPath` must be implemented.");
    }
    get box() {
      throw new Error("Abstract getter `box` must be implemented.");
    }
    serialize(t, e) {
      throw new Error("Abstract method `serialize` must be implemented.");
    }
    get free() {
      return this instanceof xm;
    }
  }
  class Gw extends oy {
    constructor(e, s) {
      super();
      v(this, Ac, void 0);
      v(this, So, void 0);
      x(this, So, e), x(this, Ac, s);
    }
    toSVGPath() {
      const e = [];
      for (const s of r(this, So)) {
        let [a, o] = s;
        e.push(`M${a} ${o}`);
        for (let h = 2; h < s.length; h += 2) {
          const c = s[h], p = s[h + 1];
          c === a ? (e.push(`V${p}`), o = p) : p === o && (e.push(`H${c}`), a = c);
        }
        e.push("Z");
      }
      return e.join(" ");
    }
    serialize([e, s, a, o], h) {
      const c = [], p = a - e, g = o - s;
      for (const b of r(this, So)) {
        const S = new Array(b.length);
        for (let T = 0; T < b.length; T += 2)
          S[T] = e + b[T] * p, S[T + 1] = o - b[T + 1] * g;
        c.push(S);
      }
      return c;
    }
    get box() {
      return r(this, Ac);
    }
  }
  Ac = new WeakMap(), So = new WeakMap();
  const yi = class yi {
    constructor({
      x: t,
      y: e
    }, s, a, o, h, c = 0) {
      v(this, xc);
      v(this, Ms, void 0);
      v(this, bi, []);
      v(this, xo, void 0);
      v(this, Po, void 0);
      v(this, Os, []);
      v(this, wt, new Float64Array(18));
      v(this, Cr, void 0);
      v(this, Rr, void 0);
      v(this, Ec, void 0);
      v(this, wc, void 0);
      v(this, To, void 0);
      v(this, Co, void 0);
      v(this, rn, []);
      x(this, Ms, s), x(this, Co, o * a), x(this, Po, h), r(this, wt).set([NaN, NaN, NaN, NaN, t, e], 6), x(this, xo, c), x(this, wc, r(yi, Sc) * a), x(this, Ec, r(yi, Gf) * a), x(this, To, a), r(this, rn).push(t, e);
    }
    get free() {
      return !0;
    }
    isEmpty() {
      return isNaN(r(this, wt)[8]);
    }
    add({
      x: t,
      y: e
    }) {
      var yt;
      x(this, Cr, t), x(this, Rr, e);
      const [s, a, o, h] = r(this, Ms);
      let [c, p, g, b] = r(this, wt).subarray(8, 12);
      const S = t - g, T = e - b, C = Math.hypot(S, T);
      if (C < r(this, Ec))
        return !1;
      const R = C - r(this, wc), M = R / C, F = M * S, O = M * T;
      let U = c, Y = p;
      c = g, p = b, g += F, b += O, (yt = r(this, rn)) == null || yt.push(t, e);
      const J = -O / R, rt = F / R, st = J * r(this, Co), ot = rt * r(this, Co);
      return r(this, wt).set(r(this, wt).subarray(2, 8), 0), r(this, wt).set([g + st, b + ot], 4), r(this, wt).set(r(this, wt).subarray(14, 18), 12), r(this, wt).set([g - st, b - ot], 16), isNaN(r(this, wt)[6]) ? (r(this, Os).length === 0 && (r(this, wt).set([c + st, p + ot], 2), r(this, Os).push(NaN, NaN, NaN, NaN, (c + st - s) / o, (p + ot - a) / h), r(this, wt).set([c - st, p - ot], 14), r(this, bi).push(NaN, NaN, NaN, NaN, (c - st - s) / o, (p - ot - a) / h)), r(this, wt).set([U, Y, c, p, g, b], 6), !this.isEmpty()) : (r(this, wt).set([U, Y, c, p, g, b], 6), Math.abs(Math.atan2(Y - p, U - c) - Math.atan2(O, F)) < Math.PI / 2 ? ([c, p, g, b] = r(this, wt).subarray(2, 6), r(this, Os).push(NaN, NaN, NaN, NaN, ((c + g) / 2 - s) / o, ((p + b) / 2 - a) / h), [c, p, U, Y] = r(this, wt).subarray(14, 18), r(this, bi).push(NaN, NaN, NaN, NaN, ((U + c) / 2 - s) / o, ((Y + p) / 2 - a) / h), !0) : ([U, Y, c, p, g, b] = r(this, wt).subarray(0, 6), r(this, Os).push(((U + 5 * c) / 6 - s) / o, ((Y + 5 * p) / 6 - a) / h, ((5 * c + g) / 6 - s) / o, ((5 * p + b) / 6 - a) / h, ((c + g) / 2 - s) / o, ((p + b) / 2 - a) / h), [g, b, c, p, U, Y] = r(this, wt).subarray(12, 18), r(this, bi).push(((U + 5 * c) / 6 - s) / o, ((Y + 5 * p) / 6 - a) / h, ((5 * c + g) / 6 - s) / o, ((5 * p + b) / 6 - a) / h, ((c + g) / 2 - s) / o, ((p + b) / 2 - a) / h), !0));
    }
    toSVGPath() {
      if (this.isEmpty())
        return "";
      const t = r(this, Os), e = r(this, bi), s = r(this, wt).subarray(4, 6), a = r(this, wt).subarray(16, 18), [o, h, c, p] = r(this, Ms), [g, b, S, T] = E(this, xc, wv).call(this);
      if (isNaN(r(this, wt)[6]) && !this.isEmpty())
        return `M${(r(this, wt)[2] - o) / c} ${(r(this, wt)[3] - h) / p} L${(r(this, wt)[4] - o) / c} ${(r(this, wt)[5] - h) / p} L${g} ${b} L${S} ${T} L${(r(this, wt)[16] - o) / c} ${(r(this, wt)[17] - h) / p} L${(r(this, wt)[14] - o) / c} ${(r(this, wt)[15] - h) / p} Z`;
      const C = [];
      C.push(`M${t[4]} ${t[5]}`);
      for (let R = 6; R < t.length; R += 6)
        isNaN(t[R]) ? C.push(`L${t[R + 4]} ${t[R + 5]}`) : C.push(`C${t[R]} ${t[R + 1]} ${t[R + 2]} ${t[R + 3]} ${t[R + 4]} ${t[R + 5]}`);
      C.push(`L${(s[0] - o) / c} ${(s[1] - h) / p} L${g} ${b} L${S} ${T} L${(a[0] - o) / c} ${(a[1] - h) / p}`);
      for (let R = e.length - 6; R >= 6; R -= 6)
        isNaN(e[R]) ? C.push(`L${e[R + 4]} ${e[R + 5]}`) : C.push(`C${e[R]} ${e[R + 1]} ${e[R + 2]} ${e[R + 3]} ${e[R + 4]} ${e[R + 5]}`);
      return C.push(`L${e[4]} ${e[5]} Z`), C.join(" ");
    }
    getOutlines() {
      var O;
      const t = r(this, Os), e = r(this, bi), s = r(this, wt), a = s.subarray(4, 6), o = s.subarray(16, 18), [h, c, p, g] = r(this, Ms), b = new Float64Array((((O = r(this, rn)) == null ? void 0 : O.length) ?? 0) + 2);
      for (let U = 0, Y = b.length - 2; U < Y; U += 2)
        b[U] = (r(this, rn)[U] - h) / p, b[U + 1] = (r(this, rn)[U + 1] - c) / g;
      b[b.length - 2] = (r(this, Cr) - h) / p, b[b.length - 1] = (r(this, Rr) - c) / g;
      const [S, T, C, R] = E(this, xc, wv).call(this);
      if (isNaN(s[6]) && !this.isEmpty()) {
        const U = new Float64Array(36);
        return U.set([NaN, NaN, NaN, NaN, (s[2] - h) / p, (s[3] - c) / g, NaN, NaN, NaN, NaN, (s[4] - h) / p, (s[5] - c) / g, NaN, NaN, NaN, NaN, S, T, NaN, NaN, NaN, NaN, C, R, NaN, NaN, NaN, NaN, (s[16] - h) / p, (s[17] - c) / g, NaN, NaN, NaN, NaN, (s[14] - h) / p, (s[15] - c) / g], 0), new xm(U, b, r(this, Ms), r(this, To), r(this, xo), r(this, Po));
      }
      const M = new Float64Array(r(this, Os).length + 24 + r(this, bi).length);
      let F = t.length;
      for (let U = 0; U < F; U += 2) {
        if (isNaN(t[U])) {
          M[U] = M[U + 1] = NaN;
          continue;
        }
        M[U] = t[U], M[U + 1] = t[U + 1];
      }
      M.set([NaN, NaN, NaN, NaN, (a[0] - h) / p, (a[1] - c) / g, NaN, NaN, NaN, NaN, S, T, NaN, NaN, NaN, NaN, C, R, NaN, NaN, NaN, NaN, (o[0] - h) / p, (o[1] - c) / g], F), F += 24;
      for (let U = e.length - 6; U >= 6; U -= 6)
        for (let Y = 0; Y < 6; Y += 2) {
          if (isNaN(e[U + Y])) {
            M[F] = M[F + 1] = NaN, F += 2;
            continue;
          }
          M[F] = e[U + Y], M[F + 1] = e[U + Y + 1], F += 2;
        }
      return M.set([NaN, NaN, NaN, NaN, e[4], e[5]], F), new xm(M, b, r(this, Ms), r(this, To), r(this, xo), r(this, Po));
    }
  };
  Ms = new WeakMap(), bi = new WeakMap(), xo = new WeakMap(), Po = new WeakMap(), Os = new WeakMap(), wt = new WeakMap(), Cr = new WeakMap(), Rr = new WeakMap(), Ec = new WeakMap(), wc = new WeakMap(), To = new WeakMap(), Co = new WeakMap(), rn = new WeakMap(), Sc = new WeakMap(), Wf = new WeakMap(), Gf = new WeakMap(), xc = new WeakSet(), wv = function() {
    const t = r(this, wt).subarray(4, 6), e = r(this, wt).subarray(16, 18), [s, a, o, h] = r(this, Ms);
    return [(r(this, Cr) + (t[0] - e[0]) / 2 - s) / o, (r(this, Rr) + (t[1] - e[1]) / 2 - a) / h, (r(this, Cr) + (e[0] - t[0]) / 2 - s) / o, (r(this, Rr) + (e[1] - t[1]) / 2 - a) / h];
  }, v(yi, Sc, 8), v(yi, Wf, 2), v(yi, Gf, r(yi, Sc) + r(yi, Wf));
  let Bu = yi;
  class xm extends oy {
    constructor(e, s, a, o, h, c) {
      super();
      v(this, Lr);
      v(this, _r);
      v(this, Xf);
      v(this, Ro, void 0);
      v(this, Ir, null);
      v(this, Ai, void 0);
      v(this, Pc, void 0);
      v(this, Ve, void 0);
      v(this, Tc, void 0);
      v(this, Qt, void 0);
      x(this, Qt, e), x(this, Ve, s), x(this, Ro, a), x(this, Tc, o), x(this, Ai, h), x(this, Pc, c), E(this, Xf, HA).call(this, c);
      const {
        x: p,
        y: g,
        width: b,
        height: S
      } = r(this, Ir);
      for (let T = 0, C = e.length; T < C; T += 2)
        e[T] = (e[T] - p) / b, e[T + 1] = (e[T + 1] - g) / S;
      for (let T = 0, C = s.length; T < C; T += 2)
        s[T] = (s[T] - p) / b, s[T + 1] = (s[T + 1] - g) / S;
    }
    toSVGPath() {
      const e = [`M${r(this, Qt)[4]} ${r(this, Qt)[5]}`];
      for (let s = 6, a = r(this, Qt).length; s < a; s += 6) {
        if (isNaN(r(this, Qt)[s])) {
          e.push(`L${r(this, Qt)[s + 4]} ${r(this, Qt)[s + 5]}`);
          continue;
        }
        e.push(`C${r(this, Qt)[s]} ${r(this, Qt)[s + 1]} ${r(this, Qt)[s + 2]} ${r(this, Qt)[s + 3]} ${r(this, Qt)[s + 4]} ${r(this, Qt)[s + 5]}`);
      }
      return e.push("Z"), e.join(" ");
    }
    serialize([e, s, a, o], h) {
      const c = a - e, p = o - s;
      let g, b;
      switch (h) {
        case 0:
          g = E(this, Lr, bd).call(this, r(this, Qt), e, o, c, -p), b = E(this, Lr, bd).call(this, r(this, Ve), e, o, c, -p);
          break;
        case 90:
          g = E(this, _r, yd).call(this, r(this, Qt), e, s, c, p), b = E(this, _r, yd).call(this, r(this, Ve), e, s, c, p);
          break;
        case 180:
          g = E(this, Lr, bd).call(this, r(this, Qt), a, s, -c, p), b = E(this, Lr, bd).call(this, r(this, Ve), a, s, -c, p);
          break;
        case 270:
          g = E(this, _r, yd).call(this, r(this, Qt), a, o, -c, -p), b = E(this, _r, yd).call(this, r(this, Ve), a, o, -c, -p);
          break;
      }
      return {
        outline: Array.from(g),
        points: [Array.from(b)]
      };
    }
    get box() {
      return r(this, Ir);
    }
    getNewOutline(e, s) {
      const {
        x: a,
        y: o,
        width: h,
        height: c
      } = r(this, Ir), [p, g, b, S] = r(this, Ro), T = h * b, C = c * S, R = a * b + p, M = o * S + g, F = new Bu({
        x: r(this, Ve)[0] * T + R,
        y: r(this, Ve)[1] * C + M
      }, r(this, Ro), r(this, Tc), e, r(this, Pc), s ?? r(this, Ai));
      for (let O = 2; O < r(this, Ve).length; O += 2)
        F.add({
          x: r(this, Ve)[O] * T + R,
          y: r(this, Ve)[O + 1] * C + M
        });
      return F.getOutlines();
    }
  }
  Ro = new WeakMap(), Ir = new WeakMap(), Ai = new WeakMap(), Pc = new WeakMap(), Ve = new WeakMap(), Tc = new WeakMap(), Qt = new WeakMap(), Lr = new WeakSet(), bd = function(e, s, a, o, h) {
    const c = new Float64Array(e.length);
    for (let p = 0, g = e.length; p < g; p += 2)
      c[p] = s + e[p] * o, c[p + 1] = a + e[p + 1] * h;
    return c;
  }, _r = new WeakSet(), yd = function(e, s, a, o, h) {
    const c = new Float64Array(e.length);
    for (let p = 0, g = e.length; p < g; p += 2)
      c[p] = s + e[p + 1] * o, c[p + 1] = a + e[p] * h;
    return c;
  }, Xf = new WeakSet(), HA = function(e) {
    const s = r(this, Qt);
    let a = s[4], o = s[5], h = a, c = o, p = a, g = o, b = a, S = o;
    const T = e ? Math.max : Math.min;
    for (let O = 6, U = s.length; O < U; O += 6) {
      if (isNaN(s[O]))
        h = Math.min(h, s[O + 4]), c = Math.min(c, s[O + 5]), p = Math.max(p, s[O + 4]), g = Math.max(g, s[O + 5]), S < s[O + 5] ? (b = s[O + 4], S = s[O + 5]) : S === s[O + 5] && (b = T(b, s[O + 4]));
      else {
        const Y = et.bezierBoundingBox(a, o, ...s.slice(O, O + 6));
        h = Math.min(h, Y[0]), c = Math.min(c, Y[1]), p = Math.max(p, Y[2]), g = Math.max(g, Y[3]), S < Y[3] ? (b = Y[2], S = Y[3]) : S === Y[3] && (b = T(b, Y[2]));
      }
      a = s[O + 4], o = s[O + 5];
    }
    const C = h - r(this, Ai), R = c - r(this, Ai), M = p - h + 2 * r(this, Ai), F = g - c + 2 * r(this, Ai);
    x(this, Ir, {
      x: C,
      y: R,
      width: M,
      height: F,
      lastPoint: [b, S]
    });
  };
  const wi = class wi {
    constructor({
      editor: t = null,
      uiManager: e = null
    }) {
      v(this, Mc);
      v(this, Oc);
      v(this, Kf);
      v(this, Ei);
      v(this, Yf);
      v(this, ks);
      v(this, Cc, E(this, Kf, VA).bind(this));
      v(this, Rc, E(this, Yf, $A).bind(this));
      v(this, us, null);
      v(this, Mr, null);
      v(this, Io, void 0);
      v(this, te, null);
      v(this, Ic, !1);
      v(this, Lo, !1);
      v(this, Lc, null);
      v(this, _c, void 0);
      v(this, an, null);
      v(this, _o, void 0);
      var s;
      t ? (x(this, Lo, !1), x(this, _o, P.HIGHLIGHT_COLOR), x(this, Lc, t)) : (x(this, Lo, !0), x(this, _o, P.HIGHLIGHT_DEFAULT_COLOR)), x(this, an, (t == null ? void 0 : t._uiManager) || e), x(this, _c, r(this, an)._eventBus), x(this, Io, (t == null ? void 0 : t.color) || ((s = r(this, an)) == null ? void 0 : s.highlightColors.values().next().value) || "#FFFF98");
    }
    static get _keyboardManager() {
      return tt(this, "_keyboardManager", new Ll([[["Escape", "mac+Escape"], wi.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], wi.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], wi.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], wi.prototype._moveToPrevious], [["Home", "mac+Home"], wi.prototype._moveToBeginning], [["End", "mac+End"], wi.prototype._moveToEnd]]));
    }
    renderButton() {
      const t = x(this, us, document.createElement("button"));
      t.className = "colorPicker", t.tabIndex = "0", t.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button"), t.setAttribute("aria-haspopup", !0), t.addEventListener("click", E(this, Ei, ta).bind(this)), t.addEventListener("keydown", r(this, Cc));
      const e = x(this, Mr, document.createElement("span"));
      return e.className = "swatch", e.setAttribute("aria-hidden", !0), e.style.backgroundColor = r(this, Io), t.append(e), t;
    }
    renderMainDropdown() {
      const t = x(this, te, E(this, Mc, Sv).call(this));
      return t.setAttribute("aria-orientation", "horizontal"), t.setAttribute("aria-labelledby", "highlightColorPickerLabel"), t;
    }
    _colorSelectFromKeyboard(t) {
      if (t.target === r(this, us)) {
        E(this, Ei, ta).call(this, t);
        return;
      }
      const e = t.target.getAttribute("data-color");
      e && E(this, Oc, xv).call(this, e, t);
    }
    _moveToNext(t) {
      var e, s;
      if (!r(this, ks, bn)) {
        E(this, Ei, ta).call(this, t);
        return;
      }
      if (t.target === r(this, us)) {
        (e = r(this, te).firstChild) == null || e.focus();
        return;
      }
      (s = t.target.nextSibling) == null || s.focus();
    }
    _moveToPrevious(t) {
      var e, s;
      if (t.target === ((e = r(this, te)) == null ? void 0 : e.firstChild) || t.target === r(this, us)) {
        r(this, ks, bn) && this._hideDropdownFromKeyboard();
        return;
      }
      r(this, ks, bn) || E(this, Ei, ta).call(this, t), (s = t.target.previousSibling) == null || s.focus();
    }
    _moveToBeginning(t) {
      var e;
      if (!r(this, ks, bn)) {
        E(this, Ei, ta).call(this, t);
        return;
      }
      (e = r(this, te).firstChild) == null || e.focus();
    }
    _moveToEnd(t) {
      var e;
      if (!r(this, ks, bn)) {
        E(this, Ei, ta).call(this, t);
        return;
      }
      (e = r(this, te).lastChild) == null || e.focus();
    }
    hideDropdown() {
      var t;
      (t = r(this, te)) == null || t.classList.add("hidden"), window.removeEventListener("pointerdown", r(this, Rc));
    }
    _hideDropdownFromKeyboard() {
      var t;
      if (!r(this, Lo)) {
        if (!r(this, ks, bn)) {
          (t = r(this, Lc)) == null || t.unselect();
          return;
        }
        this.hideDropdown(), r(this, us).focus({
          preventScroll: !0,
          focusVisible: r(this, Ic)
        });
      }
    }
    updateColor(t) {
      if (r(this, Mr) && (r(this, Mr).style.backgroundColor = t), !r(this, te))
        return;
      const e = r(this, an).highlightColors.values();
      for (const s of r(this, te).children)
        s.setAttribute("aria-selected", e.next().value === t);
    }
    destroy() {
      var t, e;
      (t = r(this, us)) == null || t.remove(), x(this, us, null), x(this, Mr, null), (e = r(this, te)) == null || e.remove(), x(this, te, null);
    }
  };
  Cc = new WeakMap(), Rc = new WeakMap(), us = new WeakMap(), Mr = new WeakMap(), Io = new WeakMap(), te = new WeakMap(), Ic = new WeakMap(), Lo = new WeakMap(), Lc = new WeakMap(), _c = new WeakMap(), an = new WeakMap(), _o = new WeakMap(), Mc = new WeakSet(), Sv = function() {
    const t = document.createElement("div");
    t.addEventListener("contextmenu", Le), t.className = "dropdown", t.role = "listbox", t.setAttribute("aria-multiselectable", !1), t.setAttribute("aria-orientation", "vertical"), t.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
    for (const [e, s] of r(this, an).highlightColors) {
      const a = document.createElement("button");
      a.tabIndex = "0", a.role = "option", a.setAttribute("data-color", s), a.title = e, a.setAttribute("data-l10n-id", `pdfjs-editor-colorpicker-${e}`);
      const o = document.createElement("span");
      a.append(o), o.className = "swatch", o.style.backgroundColor = s, a.setAttribute("aria-selected", s === r(this, Io)), a.addEventListener("click", E(this, Oc, xv).bind(this, s)), t.append(a);
    }
    return t.addEventListener("keydown", r(this, Cc)), t;
  }, Oc = new WeakSet(), xv = function(t, e) {
    e.stopPropagation(), r(this, _c).dispatch("switchannotationeditorparams", {
      source: this,
      type: r(this, _o),
      value: t
    });
  }, Kf = new WeakSet(), VA = function(t) {
    wi._keyboardManager.exec(this, t);
  }, Ei = new WeakSet(), ta = function(t) {
    if (r(this, ks, bn)) {
      this.hideDropdown();
      return;
    }
    if (x(this, Ic, t.detail === 0), window.addEventListener("pointerdown", r(this, Rc)), r(this, te)) {
      r(this, te).classList.remove("hidden");
      return;
    }
    const e = x(this, te, E(this, Mc, Sv).call(this));
    r(this, us).append(e);
  }, Yf = new WeakSet(), $A = function(t) {
    var e;
    (e = r(this, te)) != null && e.contains(t.target) || this.hideDropdown();
  }, ks = new WeakSet(), bn = function() {
    return r(this, te) && !r(this, te).classList.contains("hidden");
  };
  let ju = wi;
  const Tt = class Tt extends Rt {
    constructor(e) {
      super({
        ...e,
        name: "highlightEditor"
      });
      v(this, Bc);
      v(this, jc);
      v(this, Zf);
      v(this, Jf);
      v(this, qf);
      v(this, Hc);
      v(this, Nr);
      v(this, tp);
      v(this, No);
      v(this, Fr);
      v(this, ep);
      v(this, sp);
      v(this, Mo, null);
      v(this, kc, 0);
      v(this, on, void 0);
      v(this, Or, null);
      v(this, Oo, null);
      v(this, Ze, null);
      v(this, Dc, null);
      v(this, Nc, 0);
      v(this, kr, null);
      v(this, fs, null);
      v(this, Pe, null);
      v(this, $e, !1);
      v(this, Qf, E(this, tp, GA).bind(this));
      v(this, ko, null);
      v(this, Dr, void 0);
      v(this, ee, null);
      v(this, Do, "");
      v(this, Ds, void 0);
      v(this, Fc, "");
      this.color = e.color || Tt._defaultColor, x(this, Ds, e.thickness || Tt._defaultThickness), x(this, Dr, e.opacity || Tt._defaultOpacity), x(this, on, e.boxes || null), x(this, Fc, e.methodOfCreation || ""), x(this, Do, e.text || ""), this._isDraggable = !1, e.highlightId > -1 ? (x(this, $e, !0), E(this, jc, Tv).call(this, e), E(this, Nr, Ad).call(this)) : (x(this, Mo, e.anchorNode), x(this, kc, e.anchorOffset), x(this, Dc, e.focusNode), x(this, Nc, e.focusOffset), E(this, Bc, Pv).call(this), E(this, Nr, Ad).call(this), this.rotate(this.rotation));
    }
    static get _keyboardManager() {
      const e = Tt.prototype;
      return tt(this, "_keyboardManager", new Ll([[["ArrowLeft", "mac+ArrowLeft"], e._moveCaret, {
        args: [0]
      }], [["ArrowRight", "mac+ArrowRight"], e._moveCaret, {
        args: [1]
      }], [["ArrowUp", "mac+ArrowUp"], e._moveCaret, {
        args: [2]
      }], [["ArrowDown", "mac+ArrowDown"], e._moveCaret, {
        args: [3]
      }]]));
    }
    get telemetryInitialData() {
      return {
        action: "added",
        type: r(this, $e) ? "free_highlight" : "highlight",
        color: this._uiManager.highlightColorNames.get(this.color),
        thickness: r(this, Ds),
        methodOfCreation: r(this, Fc)
      };
    }
    get telemetryFinalData() {
      return {
        type: "highlight",
        color: this._uiManager.highlightColorNames.get(this.color)
      };
    }
    static computeTelemetryFinalData(e) {
      return {
        numberOfColors: e.get("color").size
      };
    }
    static initialize(e, s) {
      var a;
      Rt.initialize(e, s), Tt._defaultColor || (Tt._defaultColor = ((a = s.highlightColors) == null ? void 0 : a.values().next().value) || "#fff066");
    }
    static updateDefaultParams(e, s) {
      switch (e) {
        case P.HIGHLIGHT_DEFAULT_COLOR:
          Tt._defaultColor = s;
          break;
        case P.HIGHLIGHT_THICKNESS:
          Tt._defaultThickness = s;
          break;
      }
    }
    translateInPage(e, s) {
    }
    get toolbarPosition() {
      return r(this, ko);
    }
    updateParams(e, s) {
      switch (e) {
        case P.HIGHLIGHT_COLOR:
          E(this, Zf, UA).call(this, s);
          break;
        case P.HIGHLIGHT_THICKNESS:
          E(this, Jf, zA).call(this, s);
          break;
      }
    }
    static get defaultPropertiesToUpdate() {
      return [[P.HIGHLIGHT_DEFAULT_COLOR, Tt._defaultColor], [P.HIGHLIGHT_THICKNESS, Tt._defaultThickness]];
    }
    get propertiesToUpdate() {
      return [[P.HIGHLIGHT_COLOR, this.color || Tt._defaultColor], [P.HIGHLIGHT_THICKNESS, r(this, Ds) || Tt._defaultThickness], [P.HIGHLIGHT_FREE, r(this, $e)]];
    }
    async addEditToolbar() {
      const e = await super.addEditToolbar();
      return e ? (this._uiManager.highlightColors && (x(this, Oo, new ju({
        editor: this
      })), e.addColorPicker(r(this, Oo))), e) : null;
    }
    disableEditing() {
      super.disableEditing(), this.div.classList.toggle("disabled", !0);
    }
    enableEditing() {
      super.enableEditing(), this.div.classList.toggle("disabled", !1);
    }
    fixAndSetPosition() {
      return super.fixAndSetPosition(E(this, Fr, Ed).call(this));
    }
    getBaseTranslation() {
      return [0, 0];
    }
    getRect(e, s) {
      return super.getRect(e, s, E(this, Fr, Ed).call(this));
    }
    onceAdded() {
      this.parent.addUndoableEditor(this), this.div.focus();
    }
    remove() {
      E(this, Hc, Cv).call(this), this._reportTelemetry({
        action: "deleted"
      }), super.remove();
    }
    rebuild() {
      this.parent && (super.rebuild(), this.div !== null && (E(this, Nr, Ad).call(this), this.isAttachedToDOM || this.parent.add(this)));
    }
    setParent(e) {
      var a;
      let s = !1;
      this.parent && !e ? E(this, Hc, Cv).call(this) : e && (E(this, Nr, Ad).call(this, e), s = !this.parent && ((a = this.div) == null ? void 0 : a.classList.contains("selectedEditor"))), super.setParent(e), this.show(this._isVisible), s && this.select();
    }
    rotate(e) {
      var o, h, c;
      const {
        drawLayer: s
      } = this.parent;
      let a;
      r(this, $e) ? (e = (e - this.rotation + 360) % 360, a = E(o = Tt, ln, qo).call(o, r(this, fs).box, e)) : a = E(h = Tt, ln, qo).call(h, this, e), s.rotate(r(this, Pe), e), s.rotate(r(this, ee), e), s.updateBox(r(this, Pe), a), s.updateBox(r(this, ee), E(c = Tt, ln, qo).call(c, r(this, Ze).box, e));
    }
    render() {
      if (this.div)
        return this.div;
      const e = super.render();
      r(this, Do) && (e.setAttribute("aria-label", r(this, Do)), e.setAttribute("role", "mark")), r(this, $e) ? e.classList.add("free") : this.div.addEventListener("keydown", r(this, Qf));
      const s = x(this, kr, document.createElement("div"));
      e.append(s), s.setAttribute("aria-hidden", "true"), s.className = "internal", s.style.clipPath = r(this, Or);
      const [a, o] = this.parentDimensions;
      return this.setDims(this.width * a, this.height * o), Iu(this, r(this, kr), ["pointerover", "pointerleave"]), this.enableEditing(), e;
    }
    pointerover() {
      this.parent.drawLayer.addClass(r(this, ee), "hovered");
    }
    pointerleave() {
      this.parent.drawLayer.removeClass(r(this, ee), "hovered");
    }
    _moveCaret(e) {
      switch (this.parent.unselect(this), e) {
        case 0:
        case 2:
          E(this, No, Gp).call(this, !0);
          break;
        case 1:
        case 3:
          E(this, No, Gp).call(this, !1);
          break;
      }
    }
    select() {
      var e, s;
      super.select(), r(this, ee) && ((e = this.parent) == null || e.drawLayer.removeClass(r(this, ee), "hovered"), (s = this.parent) == null || s.drawLayer.addClass(r(this, ee), "selected"));
    }
    unselect() {
      var e;
      super.unselect(), r(this, ee) && ((e = this.parent) == null || e.drawLayer.removeClass(r(this, ee), "selected"), r(this, $e) || E(this, No, Gp).call(this, !1));
    }
    get _mustFixPosition() {
      return !r(this, $e);
    }
    show(e = this._isVisible) {
      super.show(e), this.parent && (this.parent.drawLayer.show(r(this, Pe), e), this.parent.drawLayer.show(r(this, ee), e));
    }
    static startHighlighting(e, s, {
      target: a,
      x: o,
      y: h
    }) {
      const {
        x: c,
        y: p,
        width: g,
        height: b
      } = a.getBoundingClientRect(), S = (M) => {
        E(this, ip, YA).call(this, e, M);
      }, T = {
        capture: !0,
        passive: !1
      }, C = (M) => {
        M.preventDefault(), M.stopPropagation();
      }, R = (M) => {
        a.removeEventListener("pointermove", S), window.removeEventListener("blur", R), window.removeEventListener("pointerup", R), window.removeEventListener("pointerdown", C, T), window.removeEventListener("contextmenu", Le), E(this, np, QA).call(this, e, M);
      };
      window.addEventListener("blur", R), window.addEventListener("pointerup", R), window.addEventListener("pointerdown", C, T), window.addEventListener("contextmenu", Le), a.addEventListener("pointermove", S), this._freeHighlight = new Bu({
        x: o,
        y: h
      }, [c, p, g, b], e.scale, this._defaultThickness / 2, s, 1e-3), {
        id: this._freeHighlightId,
        clipPathId: this._freeHighlightClipId
      } = e.drawLayer.highlight(this._freeHighlight, this._defaultColor, this._defaultOpacity, !0);
    }
    static deserialize(e, s, a) {
      var M;
      const o = super.deserialize(e, s, a), {
        rect: [h, c, p, g],
        color: b,
        quadPoints: S
      } = e;
      o.color = et.makeHexColor(...b), x(o, Dr, e.opacity);
      const [T, C] = o.pageDimensions;
      o.width = (p - h) / T, o.height = (g - c) / C;
      const R = x(o, on, []);
      for (let F = 0; F < S.length; F += 8)
        R.push({
          x: (S[4] - p) / T,
          y: (g - (1 - S[F + 5])) / C,
          width: (S[F + 2] - S[F]) / T,
          height: (S[F + 5] - S[F + 1]) / C
        });
      return E(M = o, Bc, Pv).call(M), o;
    }
    serialize(e = !1) {
      if (this.isEmpty() || e)
        return null;
      const s = this.getRect(0, 0), a = Rt._colorManager.convert(this.color);
      return {
        annotationType: w.HIGHLIGHT,
        color: a,
        opacity: r(this, Dr),
        thickness: r(this, Ds),
        quadPoints: E(this, ep, XA).call(this),
        outlines: E(this, sp, KA).call(this, s),
        pageIndex: this.pageIndex,
        rect: s,
        rotation: E(this, Fr, Ed).call(this),
        structTreeParentId: this._structTreeParentId
      };
    }
    static canCreateNewEmptyEditor() {
      return !1;
    }
  };
  Mo = new WeakMap(), kc = new WeakMap(), on = new WeakMap(), Or = new WeakMap(), Oo = new WeakMap(), Ze = new WeakMap(), Dc = new WeakMap(), Nc = new WeakMap(), kr = new WeakMap(), fs = new WeakMap(), Pe = new WeakMap(), $e = new WeakMap(), Qf = new WeakMap(), ko = new WeakMap(), Dr = new WeakMap(), ee = new WeakMap(), Do = new WeakMap(), Ds = new WeakMap(), Fc = new WeakMap(), Bc = new WeakSet(), Pv = function() {
    const e = new Sm(r(this, on), 1e-3);
    x(this, fs, e.getOutlines()), {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    } = r(this, fs).box;
    const s = new Sm(r(this, on), 25e-4, 1e-3, this._uiManager.direction === "ltr");
    x(this, Ze, s.getOutlines());
    const {
      lastPoint: a
    } = r(this, Ze).box;
    x(this, ko, [(a[0] - this.x) / this.width, (a[1] - this.y) / this.height]);
  }, jc = new WeakSet(), Tv = function({
    highlightOutlines: e,
    highlightId: s,
    clipPathId: a
  }) {
    var S, T;
    x(this, fs, e);
    const o = 1.5;
    if (x(this, Ze, e.getNewOutline(r(this, Ds) / 2 + o, 25e-4)), s >= 0)
      x(this, Pe, s), x(this, Or, a), this.parent.drawLayer.finalizeLine(s, e), x(this, ee, this.parent.drawLayer.highlightOutline(r(this, Ze)));
    else if (this.parent) {
      const C = this.parent.viewport.rotation;
      this.parent.drawLayer.updateLine(r(this, Pe), e), this.parent.drawLayer.updateBox(r(this, Pe), E(S = Tt, ln, qo).call(S, r(this, fs).box, (C - this.rotation + 360) % 360)), this.parent.drawLayer.updateLine(r(this, ee), r(this, Ze)), this.parent.drawLayer.updateBox(r(this, ee), E(T = Tt, ln, qo).call(T, r(this, Ze).box, C));
    }
    const {
      x: h,
      y: c,
      width: p,
      height: g
    } = e.box;
    switch (this.rotation) {
      case 0:
        this.x = h, this.y = c, this.width = p, this.height = g;
        break;
      case 90: {
        const [C, R] = this.parentDimensions;
        this.x = c, this.y = 1 - h, this.width = p * R / C, this.height = g * C / R;
        break;
      }
      case 180:
        this.x = 1 - h, this.y = 1 - c, this.width = p, this.height = g;
        break;
      case 270: {
        const [C, R] = this.parentDimensions;
        this.x = 1 - c, this.y = h, this.width = p * R / C, this.height = g * C / R;
        break;
      }
    }
    const {
      lastPoint: b
    } = r(this, Ze).box;
    x(this, ko, [(b[0] - h) / p, (b[1] - c) / g]);
  }, Zf = new WeakSet(), UA = function(e) {
    const s = (o) => {
      var h, c;
      this.color = o, (h = this.parent) == null || h.drawLayer.changeColor(r(this, Pe), o), (c = r(this, Oo)) == null || c.updateColor(o);
    }, a = this.color;
    this.addCommands({
      cmd: s.bind(this, e),
      undo: s.bind(this, a),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: !0,
      type: P.HIGHLIGHT_COLOR,
      overwriteIfSameType: !0,
      keepUndo: !0
    }), this._reportTelemetry({
      action: "color_changed",
      color: this._uiManager.highlightColorNames.get(e)
    }, !0);
  }, Jf = new WeakSet(), zA = function(e) {
    const s = r(this, Ds), a = (o) => {
      x(this, Ds, o), E(this, qf, WA).call(this, o);
    };
    this.addCommands({
      cmd: a.bind(this, e),
      undo: a.bind(this, s),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: !0,
      type: P.INK_THICKNESS,
      overwriteIfSameType: !0,
      keepUndo: !0
    }), this._reportTelemetry({
      action: "thickness_changed",
      thickness: e
    }, !0);
  }, qf = new WeakSet(), WA = function(e) {
    if (!r(this, $e))
      return;
    E(this, jc, Tv).call(this, {
      highlightOutlines: r(this, fs).getNewOutline(e / 2)
    }), this.fixAndSetPosition();
    const [s, a] = this.parentDimensions;
    this.setDims(this.width * s, this.height * a);
  }, Hc = new WeakSet(), Cv = function() {
    r(this, Pe) === null || !this.parent || (this.parent.drawLayer.remove(r(this, Pe)), x(this, Pe, null), this.parent.drawLayer.remove(r(this, ee)), x(this, ee, null));
  }, Nr = new WeakSet(), Ad = function(e = this.parent) {
    r(this, Pe) === null && ({
      id: De(this, Pe)._,
      clipPathId: De(this, Or)._
    } = e.drawLayer.highlight(r(this, fs), this.color, r(this, Dr)), x(this, ee, e.drawLayer.highlightOutline(r(this, Ze))), r(this, kr) && (r(this, kr).style.clipPath = r(this, Or)));
  }, ln = new WeakSet(), qo = function({
    x: e,
    y: s,
    width: a,
    height: o
  }, h) {
    switch (h) {
      case 90:
        return {
          x: 1 - s - o,
          y: e,
          width: o,
          height: a
        };
      case 180:
        return {
          x: 1 - e - a,
          y: 1 - s - o,
          width: a,
          height: o
        };
      case 270:
        return {
          x: s,
          y: 1 - e - a,
          width: o,
          height: a
        };
    }
    return {
      x: e,
      y: s,
      width: a,
      height: o
    };
  }, tp = new WeakSet(), GA = function(e) {
    Tt._keyboardManager.exec(this, e);
  }, No = new WeakSet(), Gp = function(e) {
    if (!r(this, Mo))
      return;
    const s = window.getSelection();
    e ? s.setPosition(r(this, Mo), r(this, kc)) : s.setPosition(r(this, Dc), r(this, Nc));
  }, Fr = new WeakSet(), Ed = function() {
    return r(this, $e) ? this.rotation : 0;
  }, ep = new WeakSet(), XA = function() {
    if (r(this, $e))
      return null;
    const [e, s] = this.pageDimensions, a = r(this, on), o = new Array(a.length * 8);
    let h = 0;
    for (const {
      x: c,
      y: p,
      width: g,
      height: b
    } of a) {
      const S = c * e, T = (1 - p - b) * s;
      o[h] = o[h + 4] = S, o[h + 1] = o[h + 3] = T, o[h + 2] = o[h + 6] = S + g * e, o[h + 5] = o[h + 7] = T + b * s, h += 8;
    }
    return o;
  }, sp = new WeakSet(), KA = function(e) {
    return r(this, fs).serialize(e, E(this, Fr, Ed).call(this));
  }, ip = new WeakSet(), YA = function(e, s) {
    this._freeHighlight.add(s) && e.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
  }, np = new WeakSet(), QA = function(e, s) {
    this._freeHighlight.isEmpty() ? e.drawLayer.removeFreeHighlight(this._freeHighlightId) : e.createAndAddNewEditor(s, !1, {
      highlightId: this._freeHighlightId,
      highlightOutlines: this._freeHighlight.getOutlines(),
      clipPathId: this._freeHighlightClipId,
      methodOfCreation: "main_toolbar"
    }), this._freeHighlightId = -1, this._freeHighlight = null, this._freeHighlightClipId = "";
  }, v(Tt, ln), v(Tt, ip), v(Tt, np), bt(Tt, "_defaultColor", null), bt(Tt, "_defaultOpacity", 1), bt(Tt, "_defaultThickness", 12), bt(Tt, "_l10nPromise"), bt(Tt, "_type", "highlight"), bt(Tt, "_editorType", w.HIGHLIGHT), bt(Tt, "_freeHighlightId", -1), bt(Tt, "_freeHighlight", null), bt(Tt, "_freeHighlightClipId", "");
  let Hu = Tt;
  const jt = class jt extends Rt {
    constructor(e) {
      super({
        ...e,
        name: "inkEditor"
      });
      v(this, rp);
      v(this, ap);
      v(this, op);
      v(this, lp);
      v(this, zc);
      v(this, hp);
      v(this, Wc);
      v(this, cp);
      v(this, dp);
      v(this, up);
      v(this, fp);
      v(this, pp);
      v(this, xi);
      v(this, Gc);
      v(this, Fo);
      v(this, Bo);
      v(this, cn);
      v(this, Xc);
      v(this, jo);
      v(this, vp);
      v(this, Yc);
      v(this, Ho);
      v(this, Gr);
      v(this, Br, 0);
      v(this, jr, 0);
      v(this, Vc, this.canvasPointermove.bind(this));
      v(this, $c, this.canvasPointerleave.bind(this));
      v(this, Uc, this.canvasPointerup.bind(this));
      v(this, Hr, this.canvasPointerdown.bind(this));
      v(this, Ns, null);
      v(this, Si, new Path2D());
      v(this, Je, !1);
      v(this, Vr, !1);
      v(this, $r, !1);
      v(this, Ur, null);
      v(this, zr, 0);
      v(this, Wr, 0);
      v(this, hn, null);
      this.color = e.color || null, this.thickness = e.thickness || null, this.opacity = e.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
    }
    static initialize(e, s) {
      Rt.initialize(e, s);
    }
    static updateDefaultParams(e, s) {
      switch (e) {
        case P.INK_THICKNESS:
          jt._defaultThickness = s;
          break;
        case P.INK_COLOR:
          jt._defaultColor = s;
          break;
        case P.INK_OPACITY:
          jt._defaultOpacity = s / 100;
          break;
      }
    }
    updateParams(e, s) {
      switch (e) {
        case P.INK_THICKNESS:
          E(this, rp, ZA).call(this, s);
          break;
        case P.INK_COLOR:
          E(this, ap, JA).call(this, s);
          break;
        case P.INK_OPACITY:
          E(this, op, qA).call(this, s);
          break;
      }
    }
    static get defaultPropertiesToUpdate() {
      return [[P.INK_THICKNESS, jt._defaultThickness], [P.INK_COLOR, jt._defaultColor || Rt._defaultLineColor], [P.INK_OPACITY, Math.round(jt._defaultOpacity * 100)]];
    }
    get propertiesToUpdate() {
      return [[P.INK_THICKNESS, this.thickness || jt._defaultThickness], [P.INK_COLOR, this.color || jt._defaultColor || Rt._defaultLineColor], [P.INK_OPACITY, Math.round(100 * (this.opacity ?? jt._defaultOpacity))]];
    }
    rebuild() {
      this.parent && (super.rebuild(), this.div !== null && (this.canvas || (E(this, Fo, Xp).call(this), E(this, Bo, Kp).call(this)), this.isAttachedToDOM || (this.parent.add(this), E(this, cn, tl).call(this)), E(this, Gr, wd).call(this)));
    }
    remove() {
      this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, r(this, Ns) && (clearTimeout(r(this, Ns)), x(this, Ns, null)), r(this, Ur).disconnect(), x(this, Ur, null), super.remove());
    }
    setParent(e) {
      !this.parent && e ? this._uiManager.removeShouldRescale(this) : this.parent && e === null && this._uiManager.addShouldRescale(this), super.setParent(e);
    }
    onScaleChanging() {
      const [e, s] = this.parentDimensions, a = this.width * e, o = this.height * s;
      this.setDimensions(a, o);
    }
    enableEditMode() {
      r(this, Je) || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, this.canvas.addEventListener("pointerdown", r(this, Hr)));
    }
    disableEditMode() {
      !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", r(this, Hr)));
    }
    onceAdded() {
      this._isDraggable = !this.isEmpty();
    }
    isEmpty() {
      return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
    }
    commit() {
      r(this, Je) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), x(this, Je, !0), this.div.classList.add("disabled"), E(this, Gr, wd).call(this, !0), this.select(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({
        preventScroll: !0
      }));
    }
    focusin(e) {
      this._focusEventsAllowed && (super.focusin(e), this.enableEditMode());
    }
    canvasPointerdown(e) {
      e.button !== 0 || !this.isInEditMode() || r(this, Je) || (this.setInForeground(), e.preventDefault(), this.div.contains(document.activeElement) || this.div.focus({
        preventScroll: !0
      }), E(this, hp, eE).call(this, e.offsetX, e.offsetY));
    }
    canvasPointermove(e) {
      e.preventDefault(), E(this, Wc, Iv).call(this, e.offsetX, e.offsetY);
    }
    canvasPointerup(e) {
      e.preventDefault(), E(this, Gc, Lv).call(this, e);
    }
    canvasPointerleave(e) {
      E(this, Gc, Lv).call(this, e);
    }
    get isResizable() {
      return !this.isEmpty() && r(this, Je);
    }
    render() {
      if (this.div)
        return this.div;
      let e, s;
      this.width && (e = this.x, s = this.y), super.render(), this.div.setAttribute("data-l10n-id", "pdfjs-ink");
      const [a, o, h, c] = E(this, lp, tE).call(this);
      if (this.setAt(a, o, 0, 0), this.setDims(h, c), E(this, Fo, Xp).call(this), this.width) {
        const [p, g] = this.parentDimensions;
        this.setAspectRatio(this.width * p, this.height * g), this.setAt(e * p, s * g, this.width * p, this.height * g), x(this, $r, !0), E(this, cn, tl).call(this), this.setDims(this.width * p, this.height * g), E(this, xi, ea).call(this), this.div.classList.add("disabled");
      } else
        this.div.classList.add("editing"), this.enableEditMode();
      return E(this, Bo, Kp).call(this), this.div;
    }
    setDimensions(e, s) {
      const a = Math.round(e), o = Math.round(s);
      if (r(this, zr) === a && r(this, Wr) === o)
        return;
      x(this, zr, a), x(this, Wr, o), this.canvas.style.visibility = "hidden";
      const [h, c] = this.parentDimensions;
      this.width = e / h, this.height = s / c, this.fixAndSetPosition(), r(this, Je) && E(this, Xc, _v).call(this, e, s), E(this, cn, tl).call(this), E(this, xi, ea).call(this), this.canvas.style.visibility = "visible", this.fixDims();
    }
    static deserialize(e, s, a) {
      var F, O, U;
      if (e instanceof ry)
        return null;
      const o = super.deserialize(e, s, a);
      o.thickness = e.thickness, o.color = et.makeHexColor(...e.color), o.opacity = e.opacity;
      const [h, c] = o.pageDimensions, p = o.width * h, g = o.height * c, b = o.parentScale, S = e.thickness / 2;
      x(o, Je, !0), x(o, zr, Math.round(p)), x(o, Wr, Math.round(g));
      const {
        paths: T,
        rect: C,
        rotation: R
      } = e;
      for (let {
        bezier: Y
      } of T) {
        Y = E(F = jt, mp, lE).call(F, Y, C, R);
        const J = [];
        o.paths.push(J);
        let rt = b * (Y[0] - S), st = b * (Y[1] - S);
        for (let ft = 2, yt = Y.length; ft < yt; ft += 6) {
          const St = b * (Y[ft] - S), gt = b * (Y[ft + 1] - S), Wt = b * (Y[ft + 2] - S), Dt = b * (Y[ft + 3] - S), $t = b * (Y[ft + 4] - S), Ut = b * (Y[ft + 5] - S);
          J.push([[rt, st], [St, gt], [Wt, Dt], [$t, Ut]]), rt = $t, st = Ut;
        }
        const ot = E(this, gp, oE).call(this, J);
        o.bezierPath2D.push(ot);
      }
      const M = E(O = o, Yc, Ov).call(O);
      return x(o, jr, Math.max(Rt.MIN_SIZE, M[2] - M[0])), x(o, Br, Math.max(Rt.MIN_SIZE, M[3] - M[1])), E(U = o, Xc, _v).call(U, p, g), o;
    }
    serialize() {
      if (this.isEmpty())
        return null;
      const e = this.getRect(0, 0), s = Rt._colorManager.convert(this.ctx.strokeStyle);
      return {
        annotationType: w.INK,
        color: s,
        thickness: this.thickness,
        opacity: this.opacity,
        paths: E(this, vp, hE).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, e),
        pageIndex: this.pageIndex,
        rect: e,
        rotation: this.rotation,
        structTreeParentId: this._structTreeParentId
      };
    }
  };
  Br = new WeakMap(), jr = new WeakMap(), Vc = new WeakMap(), $c = new WeakMap(), Uc = new WeakMap(), Hr = new WeakMap(), Ns = new WeakMap(), Si = new WeakMap(), Je = new WeakMap(), Vr = new WeakMap(), $r = new WeakMap(), Ur = new WeakMap(), zr = new WeakMap(), Wr = new WeakMap(), hn = new WeakMap(), rp = new WeakSet(), ZA = function(e) {
    const s = (o) => {
      this.thickness = o, E(this, Gr, wd).call(this);
    }, a = this.thickness;
    this.addCommands({
      cmd: s.bind(this, e),
      undo: s.bind(this, a),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: !0,
      type: P.INK_THICKNESS,
      overwriteIfSameType: !0,
      keepUndo: !0
    });
  }, ap = new WeakSet(), JA = function(e) {
    const s = (o) => {
      this.color = o, E(this, xi, ea).call(this);
    }, a = this.color;
    this.addCommands({
      cmd: s.bind(this, e),
      undo: s.bind(this, a),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: !0,
      type: P.INK_COLOR,
      overwriteIfSameType: !0,
      keepUndo: !0
    });
  }, op = new WeakSet(), qA = function(e) {
    const s = (o) => {
      this.opacity = o, E(this, xi, ea).call(this);
    };
    e /= 100;
    const a = this.opacity;
    this.addCommands({
      cmd: s.bind(this, e),
      undo: s.bind(this, a),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: !0,
      type: P.INK_OPACITY,
      overwriteIfSameType: !0,
      keepUndo: !0
    });
  }, lp = new WeakSet(), tE = function() {
    const {
      parentRotation: e,
      parentDimensions: [s, a]
    } = this;
    switch (e) {
      case 90:
        return [0, a, a, s];
      case 180:
        return [s, a, s, a];
      case 270:
        return [s, 0, a, s];
      default:
        return [0, 0, s, a];
    }
  }, zc = new WeakSet(), Rv = function() {
    const {
      ctx: e,
      color: s,
      opacity: a,
      thickness: o,
      parentScale: h,
      scaleFactor: c
    } = this;
    e.lineWidth = o * h / c, e.lineCap = "round", e.lineJoin = "round", e.miterLimit = 10, e.strokeStyle = `${s}${m0(a)}`;
  }, hp = new WeakSet(), eE = function(e, s) {
    this.canvas.addEventListener("contextmenu", Le), this.canvas.addEventListener("pointerleave", r(this, $c)), this.canvas.addEventListener("pointermove", r(this, Vc)), this.canvas.addEventListener("pointerup", r(this, Uc)), this.canvas.removeEventListener("pointerdown", r(this, Hr)), this.isEditing = !0, r(this, $r) || (x(this, $r, !0), E(this, cn, tl).call(this), this.thickness || (this.thickness = jt._defaultThickness), this.color || (this.color = jt._defaultColor || Rt._defaultLineColor), this.opacity ?? (this.opacity = jt._defaultOpacity)), this.currentPath.push([e, s]), x(this, Vr, !1), E(this, zc, Rv).call(this), x(this, hn, () => {
      E(this, up, nE).call(this), r(this, hn) && window.requestAnimationFrame(r(this, hn));
    }), window.requestAnimationFrame(r(this, hn));
  }, Wc = new WeakSet(), Iv = function(e, s) {
    const [a, o] = this.currentPath.at(-1);
    if (this.currentPath.length > 1 && e === a && s === o)
      return;
    const h = this.currentPath;
    let c = r(this, Si);
    if (h.push([e, s]), x(this, Vr, !0), h.length <= 2) {
      c.moveTo(...h[0]), c.lineTo(e, s);
      return;
    }
    h.length === 3 && (x(this, Si, c = new Path2D()), c.moveTo(...h[0])), E(this, fp, rE).call(this, c, ...h.at(-3), ...h.at(-2), e, s);
  }, cp = new WeakSet(), sE = function() {
    if (this.currentPath.length === 0)
      return;
    const e = this.currentPath.at(-1);
    r(this, Si).lineTo(...e);
  }, dp = new WeakSet(), iE = function(e, s) {
    x(this, hn, null), e = Math.min(Math.max(e, 0), this.canvas.width), s = Math.min(Math.max(s, 0), this.canvas.height), E(this, Wc, Iv).call(this, e, s), E(this, cp, sE).call(this);
    let a;
    if (this.currentPath.length !== 1)
      a = E(this, pp, aE).call(this);
    else {
      const g = [e, s];
      a = [[g, g.slice(), g.slice(), g]];
    }
    const o = r(this, Si), h = this.currentPath;
    this.currentPath = [], x(this, Si, new Path2D());
    const c = () => {
      this.allRawPaths.push(h), this.paths.push(a), this.bezierPath2D.push(o), this._uiManager.rebuild(this);
    }, p = () => {
      this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (E(this, Fo, Xp).call(this), E(this, Bo, Kp).call(this)), E(this, Gr, wd).call(this));
    };
    this.addCommands({
      cmd: c,
      undo: p,
      mustExec: !0
    });
  }, up = new WeakSet(), nE = function() {
    if (!r(this, Vr))
      return;
    x(this, Vr, !1);
    const e = Math.ceil(this.thickness * this.parentScale), s = this.currentPath.slice(-3), a = s.map((c) => c[0]), o = s.map((c) => c[1]);
    Math.min(...a) - e, Math.max(...a) + e, Math.min(...o) - e, Math.max(...o) + e;
    const {
      ctx: h
    } = this;
    h.save(), h.clearRect(0, 0, this.canvas.width, this.canvas.height);
    for (const c of this.bezierPath2D)
      h.stroke(c);
    h.stroke(r(this, Si)), h.restore();
  }, fp = new WeakSet(), rE = function(e, s, a, o, h, c, p) {
    const g = (s + o) / 2, b = (a + h) / 2, S = (o + c) / 2, T = (h + p) / 2;
    e.bezierCurveTo(g + 2 * (o - g) / 3, b + 2 * (h - b) / 3, S + 2 * (o - S) / 3, T + 2 * (h - T) / 3, S, T);
  }, pp = new WeakSet(), aE = function() {
    const e = this.currentPath;
    if (e.length <= 2)
      return [[e[0], e[0], e.at(-1), e.at(-1)]];
    const s = [];
    let a, [o, h] = e[0];
    for (a = 1; a < e.length - 2; a++) {
      const [C, R] = e[a], [M, F] = e[a + 1], O = (C + M) / 2, U = (R + F) / 2, Y = [o + 2 * (C - o) / 3, h + 2 * (R - h) / 3], J = [O + 2 * (C - O) / 3, U + 2 * (R - U) / 3];
      s.push([[o, h], Y, J, [O, U]]), [o, h] = [O, U];
    }
    const [c, p] = e[a], [g, b] = e[a + 1], S = [o + 2 * (c - o) / 3, h + 2 * (p - h) / 3], T = [g + 2 * (c - g) / 3, b + 2 * (p - b) / 3];
    return s.push([[o, h], S, T, [g, b]]), s;
  }, xi = new WeakSet(), ea = function() {
    if (this.isEmpty()) {
      E(this, jo, Yp).call(this);
      return;
    }
    E(this, zc, Rv).call(this);
    const {
      canvas: e,
      ctx: s
    } = this;
    s.setTransform(1, 0, 0, 1, 0, 0), s.clearRect(0, 0, e.width, e.height), E(this, jo, Yp).call(this);
    for (const a of this.bezierPath2D)
      s.stroke(a);
  }, Gc = new WeakSet(), Lv = function(e) {
    this.canvas.removeEventListener("pointerleave", r(this, $c)), this.canvas.removeEventListener("pointermove", r(this, Vc)), this.canvas.removeEventListener("pointerup", r(this, Uc)), this.canvas.addEventListener("pointerdown", r(this, Hr)), r(this, Ns) && clearTimeout(r(this, Ns)), x(this, Ns, setTimeout(() => {
      x(this, Ns, null), this.canvas.removeEventListener("contextmenu", Le);
    }, 10)), E(this, dp, iE).call(this, e.offsetX, e.offsetY), this.addToAnnotationStorage(), this.setInBackground();
  }, Fo = new WeakSet(), Xp = function() {
    this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", this.canvas.setAttribute("data-l10n-id", "pdfjs-ink-canvas"), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
  }, Bo = new WeakSet(), Kp = function() {
    x(this, Ur, new ResizeObserver((e) => {
      const s = e[0].contentRect;
      s.width && s.height && this.setDimensions(s.width, s.height);
    })), r(this, Ur).observe(this.div);
  }, cn = new WeakSet(), tl = function() {
    if (!r(this, $r))
      return;
    const [e, s] = this.parentDimensions;
    this.canvas.width = Math.ceil(this.width * e), this.canvas.height = Math.ceil(this.height * s), E(this, jo, Yp).call(this);
  }, Xc = new WeakSet(), _v = function(e, s) {
    const a = E(this, Ho, Qp).call(this), o = (e - a) / r(this, jr), h = (s - a) / r(this, Br);
    this.scaleFactor = Math.min(o, h);
  }, jo = new WeakSet(), Yp = function() {
    const e = E(this, Ho, Qp).call(this) / 2;
    this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + e, this.translationY * this.scaleFactor + e);
  }, gp = new WeakSet(), oE = function(e) {
    const s = new Path2D();
    for (let a = 0, o = e.length; a < o; a++) {
      const [h, c, p, g] = e[a];
      a === 0 && s.moveTo(...h), s.bezierCurveTo(c[0], c[1], p[0], p[1], g[0], g[1]);
    }
    return s;
  }, Kc = new WeakSet(), Mv = function(e, s, a) {
    const [o, h, c, p] = s;
    switch (a) {
      case 0:
        for (let g = 0, b = e.length; g < b; g += 2)
          e[g] += o, e[g + 1] = p - e[g + 1];
        break;
      case 90:
        for (let g = 0, b = e.length; g < b; g += 2) {
          const S = e[g];
          e[g] = e[g + 1] + o, e[g + 1] = S + h;
        }
        break;
      case 180:
        for (let g = 0, b = e.length; g < b; g += 2)
          e[g] = c - e[g], e[g + 1] += h;
        break;
      case 270:
        for (let g = 0, b = e.length; g < b; g += 2) {
          const S = e[g];
          e[g] = c - e[g + 1], e[g + 1] = p - S;
        }
        break;
      default:
        throw new Error("Invalid rotation");
    }
    return e;
  }, mp = new WeakSet(), lE = function(e, s, a) {
    const [o, h, c, p] = s;
    switch (a) {
      case 0:
        for (let g = 0, b = e.length; g < b; g += 2)
          e[g] -= o, e[g + 1] = p - e[g + 1];
        break;
      case 90:
        for (let g = 0, b = e.length; g < b; g += 2) {
          const S = e[g];
          e[g] = e[g + 1] - h, e[g + 1] = S - o;
        }
        break;
      case 180:
        for (let g = 0, b = e.length; g < b; g += 2)
          e[g] = c - e[g], e[g + 1] -= h;
        break;
      case 270:
        for (let g = 0, b = e.length; g < b; g += 2) {
          const S = e[g];
          e[g] = p - e[g + 1], e[g + 1] = c - S;
        }
        break;
      default:
        throw new Error("Invalid rotation");
    }
    return e;
  }, vp = new WeakSet(), hE = function(e, s, a, o) {
    var b, S;
    const h = [], c = this.thickness / 2, p = e * s + c, g = e * a + c;
    for (const T of this.paths) {
      const C = [], R = [];
      for (let M = 0, F = T.length; M < F; M++) {
        const [O, U, Y, J] = T[M];
        if (O[0] === J[0] && O[1] === J[1] && F === 1) {
          const Dt = e * O[0] + p, $t = e * O[1] + g;
          C.push(Dt, $t), R.push(Dt, $t);
          break;
        }
        const rt = e * O[0] + p, st = e * O[1] + g, ot = e * U[0] + p, ft = e * U[1] + g, yt = e * Y[0] + p, St = e * Y[1] + g, gt = e * J[0] + p, Wt = e * J[1] + g;
        M === 0 && (C.push(rt, st), R.push(rt, st)), C.push(ot, ft, yt, St, gt, Wt), R.push(ot, ft), M === F - 1 && R.push(gt, Wt);
      }
      h.push({
        bezier: E(b = jt, Kc, Mv).call(b, C, o, this.rotation),
        points: E(S = jt, Kc, Mv).call(S, R, o, this.rotation)
      });
    }
    return h;
  }, Yc = new WeakSet(), Ov = function() {
    let e = 1 / 0, s = -1 / 0, a = 1 / 0, o = -1 / 0;
    for (const h of this.paths)
      for (const [c, p, g, b] of h) {
        const S = et.bezierBoundingBox(...c, ...p, ...g, ...b);
        e = Math.min(e, S[0]), a = Math.min(a, S[1]), s = Math.max(s, S[2]), o = Math.max(o, S[3]);
      }
    return [e, a, s, o];
  }, Ho = new WeakSet(), Qp = function() {
    return r(this, Je) ? Math.ceil(this.thickness * this.parentScale) : 0;
  }, Gr = new WeakSet(), wd = function(e = !1) {
    if (this.isEmpty())
      return;
    if (!r(this, Je)) {
      E(this, xi, ea).call(this);
      return;
    }
    const s = E(this, Yc, Ov).call(this), a = E(this, Ho, Qp).call(this);
    x(this, jr, Math.max(Rt.MIN_SIZE, s[2] - s[0])), x(this, Br, Math.max(Rt.MIN_SIZE, s[3] - s[1]));
    const o = Math.ceil(a + r(this, jr) * this.scaleFactor), h = Math.ceil(a + r(this, Br) * this.scaleFactor), [c, p] = this.parentDimensions;
    this.width = o / c, this.height = h / p, this.setAspectRatio(o, h);
    const g = this.translationX, b = this.translationY;
    this.translationX = -s[0], this.translationY = -s[1], E(this, cn, tl).call(this), E(this, xi, ea).call(this), x(this, zr, o), x(this, Wr, h), this.setDims(o, h);
    const S = e ? a / this.scaleFactor / 2 : 0;
    this.translate(g - this.translationX - S, b - this.translationY - S);
  }, v(jt, gp), v(jt, Kc), v(jt, mp), bt(jt, "_defaultColor", null), bt(jt, "_defaultOpacity", 1), bt(jt, "_defaultThickness", 1), bt(jt, "_type", "ink"), bt(jt, "_editorType", w.INK);
  let Pm = jt;
  const qc = class qc extends Rt {
    constructor(e) {
      super({
        ...e,
        name: "stampEditor"
      });
      v(this, Kr);
      v(this, Yr);
      v(this, $o);
      v(this, Zc);
      v(this, bp);
      v(this, yp);
      v(this, Jc);
      v(this, Uo);
      v(this, Ap);
      v(this, fe, null);
      v(this, pe, null);
      v(this, dn, null);
      v(this, Pi, null);
      v(this, un, null);
      v(this, Vo, "");
      v(this, Fs, null);
      v(this, Xr, null);
      v(this, Bs, null);
      v(this, ps, !1);
      v(this, Qc, !1);
      x(this, Pi, e.bitmapUrl), x(this, un, e.bitmapFile);
    }
    static initialize(e, s) {
      Rt.initialize(e, s);
    }
    static get supportedTypes() {
      return tt(this, "supportedTypes", ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"].map((s) => `image/${s}`));
    }
    static get supportedTypesStr() {
      return tt(this, "supportedTypesStr", this.supportedTypes.join(","));
    }
    static isHandlingMimeForPasting(e) {
      return this.supportedTypes.includes(e);
    }
    static paste(e, s) {
      s.pasteEditor(w.STAMP, {
        bitmapFile: e.getAsFile()
      });
    }
    remove() {
      var e, s;
      r(this, pe) && (x(this, fe, null), this._uiManager.imageManager.deleteId(r(this, pe)), (e = r(this, Fs)) == null || e.remove(), x(this, Fs, null), (s = r(this, Xr)) == null || s.disconnect(), x(this, Xr, null), r(this, Bs) && (clearTimeout(r(this, Bs)), x(this, Bs, null))), super.remove();
    }
    rebuild() {
      if (!this.parent) {
        r(this, pe) && E(this, $o, Zp).call(this);
        return;
      }
      super.rebuild(), this.div !== null && (r(this, pe) && r(this, Fs) === null && E(this, $o, Zp).call(this), this.isAttachedToDOM || this.parent.add(this));
    }
    onceAdded() {
      this._isDraggable = !0, this.div.focus();
    }
    isEmpty() {
      return !(r(this, dn) || r(this, fe) || r(this, Pi) || r(this, un) || r(this, pe));
    }
    get isResizable() {
      return !0;
    }
    render() {
      if (this.div)
        return this.div;
      let e, s;
      if (this.width && (e = this.x, s = this.y), super.render(), this.div.hidden = !0, this.addAltTextButton(), r(this, fe) ? E(this, Zc, kv).call(this) : E(this, $o, Zp).call(this), this.width) {
        const [a, o] = this.parentDimensions;
        this.setAt(e * a, s * o, this.width * a, this.height * o);
      }
      return this.div;
    }
    getImageForAltText() {
      return r(this, Fs);
    }
    static deserialize(e, s, a) {
      if (e instanceof ay)
        return null;
      const o = super.deserialize(e, s, a), {
        rect: h,
        bitmapUrl: c,
        bitmapId: p,
        isSvg: g,
        accessibilityData: b
      } = e;
      p && a.imageManager.isValidId(p) ? x(o, pe, p) : x(o, Pi, c), x(o, ps, g);
      const [S, T] = o.pageDimensions;
      return o.width = (h[2] - h[0]) / S, o.height = (h[3] - h[1]) / T, b && (o.altTextData = b), o;
    }
    serialize(e = !1, s = null) {
      if (this.isEmpty())
        return null;
      const a = {
        annotationType: w.STAMP,
        bitmapId: r(this, pe),
        pageIndex: this.pageIndex,
        rect: this.getRect(0, 0),
        rotation: this.rotation,
        isSvg: r(this, ps),
        structTreeParentId: this._structTreeParentId
      };
      if (e)
        return a.bitmapUrl = E(this, Uo, Jp).call(this, !0), a.accessibilityData = this.altTextData, a;
      const {
        decorative: o,
        altText: h
      } = this.altTextData;
      if (!o && h && (a.accessibilityData = {
        type: "Figure",
        alt: h
      }), s === null)
        return a;
      s.stamps || (s.stamps = /* @__PURE__ */ new Map());
      const c = r(this, ps) ? (a.rect[2] - a.rect[0]) * (a.rect[3] - a.rect[1]) : null;
      if (!s.stamps.has(r(this, pe)))
        s.stamps.set(r(this, pe), {
          area: c,
          serialized: a
        }), a.bitmap = E(this, Uo, Jp).call(this, !1);
      else if (r(this, ps)) {
        const p = s.stamps.get(r(this, pe));
        c > p.area && (p.area = c, p.serialized.bitmap.close(), p.serialized.bitmap = E(this, Uo, Jp).call(this, !1));
      }
      return a;
    }
  };
  fe = new WeakMap(), pe = new WeakMap(), dn = new WeakMap(), Pi = new WeakMap(), un = new WeakMap(), Vo = new WeakMap(), Fs = new WeakMap(), Xr = new WeakMap(), Bs = new WeakMap(), ps = new WeakMap(), Qc = new WeakMap(), Kr = new WeakSet(), Sd = function(e, s = !1) {
    if (!e) {
      this.remove();
      return;
    }
    x(this, fe, e.bitmap), s || (x(this, pe, e.id), x(this, ps, e.isSvg)), e.file && x(this, Vo, e.file.name), E(this, Zc, kv).call(this);
  }, Yr = new WeakSet(), xd = function() {
    x(this, dn, null), this._uiManager.enableWaiting(!1), r(this, Fs) && this.div.focus();
  }, $o = new WeakSet(), Zp = function() {
    if (r(this, pe)) {
      this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(r(this, pe)).then((s) => E(this, Kr, Sd).call(this, s, !0)).finally(() => E(this, Yr, xd).call(this));
      return;
    }
    if (r(this, Pi)) {
      const s = r(this, Pi);
      x(this, Pi, null), this._uiManager.enableWaiting(!0), x(this, dn, this._uiManager.imageManager.getFromUrl(s).then((a) => E(this, Kr, Sd).call(this, a)).finally(() => E(this, Yr, xd).call(this)));
      return;
    }
    if (r(this, un)) {
      const s = r(this, un);
      x(this, un, null), this._uiManager.enableWaiting(!0), x(this, dn, this._uiManager.imageManager.getFromFile(s).then((a) => E(this, Kr, Sd).call(this, a)).finally(() => E(this, Yr, xd).call(this)));
      return;
    }
    const e = document.createElement("input");
    e.type = "file", e.accept = qc.supportedTypesStr, x(this, dn, new Promise((s) => {
      e.addEventListener("change", async () => {
        if (!e.files || e.files.length === 0)
          this.remove();
        else {
          this._uiManager.enableWaiting(!0);
          const a = await this._uiManager.imageManager.getFromFile(e.files[0]);
          E(this, Kr, Sd).call(this, a);
        }
        s();
      }), e.addEventListener("cancel", () => {
        this.remove(), s();
      });
    }).finally(() => E(this, Yr, xd).call(this))), e.click();
  }, Zc = new WeakSet(), kv = function() {
    const {
      div: e
    } = this;
    let {
      width: s,
      height: a
    } = r(this, fe);
    const [o, h] = this.pageDimensions, c = 0.75;
    if (this.width)
      s = this.width * o, a = this.height * h;
    else if (s > c * o || a > c * h) {
      const S = Math.min(c * o / s, c * h / a);
      s *= S, a *= S;
    }
    const [p, g] = this.parentDimensions;
    this.setDims(s * p / o, a * g / h), this._uiManager.enableWaiting(!1);
    const b = x(this, Fs, document.createElement("canvas"));
    e.append(b), e.hidden = !1, E(this, Jc, Dv).call(this, s, a), E(this, Ap, uE).call(this), r(this, Qc) || (this.parent.addUndoableEditor(this), x(this, Qc, !0)), this._reportTelemetry({
      action: "inserted_image"
    }), r(this, Vo) && b.setAttribute("aria-label", r(this, Vo));
  }, bp = new WeakSet(), cE = function(e, s) {
    var c;
    const [a, o] = this.parentDimensions;
    this.width = e / a, this.height = s / o, this.setDims(e, s), (c = this._initialOptions) != null && c.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, r(this, Bs) !== null && clearTimeout(r(this, Bs)), x(this, Bs, setTimeout(() => {
      x(this, Bs, null), E(this, Jc, Dv).call(this, e, s);
    }, 200));
  }, yp = new WeakSet(), dE = function(e, s) {
    const {
      width: a,
      height: o
    } = r(this, fe);
    let h = a, c = o, p = r(this, fe);
    for (; h > 2 * e || c > 2 * s; ) {
      const g = h, b = c;
      h > 2 * e && (h = h >= 16384 ? Math.floor(h / 2) - 1 : Math.ceil(h / 2)), c > 2 * s && (c = c >= 16384 ? Math.floor(c / 2) - 1 : Math.ceil(c / 2));
      const S = new OffscreenCanvas(h, c);
      S.getContext("2d").drawImage(p, 0, 0, g, b, 0, 0, h, c), p = S.transferToImageBitmap();
    }
    return p;
  }, Jc = new WeakSet(), Dv = function(e, s) {
    e = Math.ceil(e), s = Math.ceil(s);
    const a = r(this, Fs);
    if (!a || a.width === e && a.height === s)
      return;
    a.width = e, a.height = s;
    const o = r(this, ps) ? r(this, fe) : E(this, yp, dE).call(this, e, s);
    if (this._uiManager.hasMLManager && !this.hasAltText()) {
      const p = new OffscreenCanvas(e, s).getContext("2d");
      p.drawImage(o, 0, 0, o.width, o.height, 0, 0, e, s), this._uiManager.mlGuess({
        service: "image-to-text",
        request: {
          data: p.getImageData(0, 0, e, s).data,
          width: e,
          height: s,
          channels: 4
        }
      }).then((g) => {
        const b = (g == null ? void 0 : g.output) || "";
        this.parent && b && !this.hasAltText() && (this.altTextData = {
          altText: b,
          decorative: !1
        });
      });
    }
    const h = a.getContext("2d");
    h.filter = this._uiManager.hcmFilter, h.drawImage(o, 0, 0, o.width, o.height, 0, 0, e, s);
  }, Uo = new WeakSet(), Jp = function(e) {
    if (e) {
      if (r(this, ps)) {
        const o = this._uiManager.imageManager.getSvgUrl(r(this, pe));
        if (o)
          return o;
      }
      const s = document.createElement("canvas");
      return {
        width: s.width,
        height: s.height
      } = r(this, fe), s.getContext("2d").drawImage(r(this, fe), 0, 0), s.toDataURL();
    }
    if (r(this, ps)) {
      const [s, a] = this.pageDimensions, o = Math.round(this.width * s * Vi.PDF_TO_CSS_UNITS), h = Math.round(this.height * a * Vi.PDF_TO_CSS_UNITS), c = new OffscreenCanvas(o, h);
      return c.getContext("2d").drawImage(r(this, fe), 0, 0, r(this, fe).width, r(this, fe).height, 0, 0, o, h), c.transferToImageBitmap();
    }
    return structuredClone(r(this, fe));
  }, Ap = new WeakSet(), uE = function() {
    x(this, Xr, new ResizeObserver((e) => {
      const s = e[0].contentRect;
      s.width && s.height && E(this, bp, cE).call(this, s.width, s.height);
    })), r(this, Xr).observe(this.div);
  }, bt(qc, "_type", "stamp"), bt(qc, "_editorType", w.STAMP);
  let Tm = qc;
  const gs = class gs {
    constructor({
      uiManager: t,
      pageIndex: e,
      div: s,
      accessibilityManager: a,
      annotationLayer: o,
      drawLayer: h,
      textLayer: c,
      viewport: p,
      l10n: g
    }) {
      v(this, Ep);
      v(this, td);
      v(this, ed);
      v(this, sd);
      v(this, Xo);
      v(this, Qr, void 0);
      v(this, zo, !1);
      v(this, js, null);
      v(this, Zr, null);
      v(this, Ti, null);
      v(this, Ci, null);
      v(this, Ri, null);
      v(this, Ue, /* @__PURE__ */ new Map());
      v(this, fn, !1);
      v(this, Wo, !1);
      v(this, Go, !1);
      v(this, Te, null);
      v(this, ut, void 0);
      const b = [...r(gs, pn).values()];
      if (!gs._initialized) {
        gs._initialized = !0;
        for (const S of b)
          S.initialize(g, t);
      }
      t.registerEditorTypes(b), x(this, ut, t), this.pageIndex = e, this.div = s, x(this, Qr, a), x(this, js, o), this.viewport = p, x(this, Te, c), this.drawLayer = h, r(this, ut).addLayer(this);
    }
    get isEmpty() {
      return r(this, Ue).size === 0;
    }
    get isInvisible() {
      return this.isEmpty && r(this, ut).getMode() === w.NONE;
    }
    updateToolbar(t) {
      r(this, ut).updateToolbar(t);
    }
    updateMode(t = r(this, ut).getMode()) {
      switch (E(this, Xo, qp).call(this), t) {
        case w.NONE:
          this.disableTextSelection(), this.togglePointerEvents(!1), this.toggleAnnotationLayerPointerEvents(!0), this.disableClick();
          return;
        case w.INK:
          this.addInkEditorIfNeeded(!1), this.disableTextSelection(), this.togglePointerEvents(!0), this.disableClick();
          break;
        case w.HIGHLIGHT:
          this.enableTextSelection(), this.togglePointerEvents(!1), this.disableClick();
          break;
        default:
          this.disableTextSelection(), this.togglePointerEvents(!0), this.enableClick();
      }
      this.toggleAnnotationLayerPointerEvents(!1);
      const {
        classList: e
      } = this.div;
      for (const s of r(gs, pn).values())
        e.toggle(`${s._type}Editing`, t === s._editorType);
      this.div.hidden = !1;
    }
    hasTextLayer(t) {
      var e;
      return t === ((e = r(this, Te)) == null ? void 0 : e.div);
    }
    addInkEditorIfNeeded(t) {
      if (r(this, ut).getMode() !== w.INK)
        return;
      if (!t) {
        for (const s of r(this, Ue).values())
          if (s.isEmpty()) {
            s.setInBackground();
            return;
          }
      }
      this.createAndAddNewEditor({
        offsetX: 0,
        offsetY: 0
      }, !1).setInBackground();
    }
    setEditingState(t) {
      r(this, ut).setEditingState(t);
    }
    addCommands(t) {
      r(this, ut).addCommands(t);
    }
    togglePointerEvents(t = !1) {
      this.div.classList.toggle("disabled", !t);
    }
    toggleAnnotationLayerPointerEvents(t = !1) {
      var e;
      (e = r(this, js)) == null || e.div.classList.toggle("disabled", !t);
    }
    enable() {
      this.div.tabIndex = 0, this.togglePointerEvents(!0);
      const t = /* @__PURE__ */ new Set();
      for (const s of r(this, Ue).values())
        s.enableEditing(), s.show(!0), s.annotationElementId && (r(this, ut).removeChangedExistingAnnotation(s), t.add(s.annotationElementId));
      if (!r(this, js))
        return;
      const e = r(this, js).getEditableAnnotations();
      for (const s of e) {
        if (s.hide(), r(this, ut).isDeletedAnnotationElement(s.data.id) || t.has(s.data.id))
          continue;
        const a = this.deserialize(s);
        a && (this.addOrRebuild(a), a.enableEditing());
      }
    }
    disable() {
      var a;
      x(this, Go, !0), this.div.tabIndex = -1, this.togglePointerEvents(!1);
      const t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map();
      for (const o of r(this, Ue).values())
        if (o.disableEditing(), !!o.annotationElementId) {
          if (o.serialize() !== null) {
            t.set(o.annotationElementId, o);
            continue;
          } else
            e.set(o.annotationElementId, o);
          (a = this.getEditableAnnotation(o.annotationElementId)) == null || a.show(), o.remove();
        }
      if (r(this, js)) {
        const o = r(this, js).getEditableAnnotations();
        for (const h of o) {
          const {
            id: c
          } = h.data;
          if (r(this, ut).isDeletedAnnotationElement(c))
            continue;
          let p = e.get(c);
          if (p) {
            p.resetAnnotationElement(h), p.show(!1), h.show();
            continue;
          }
          p = t.get(c), p && (r(this, ut).addChangedExistingAnnotation(p), p.renderAnnotationElement(h), p.show(!1)), h.show();
        }
      }
      E(this, Xo, qp).call(this), this.isEmpty && (this.div.hidden = !0);
      const {
        classList: s
      } = this.div;
      for (const o of r(gs, pn).values())
        s.remove(`${o._type}Editing`);
      this.disableTextSelection(), this.toggleAnnotationLayerPointerEvents(!0), x(this, Go, !1);
    }
    getEditableAnnotation(t) {
      var e;
      return ((e = r(this, js)) == null ? void 0 : e.getEditableAnnotation(t)) || null;
    }
    setActiveEditor(t) {
      r(this, ut).getActive() !== t && r(this, ut).setActiveEditor(t);
    }
    enableTextSelection() {
      var t;
      this.div.tabIndex = -1, (t = r(this, Te)) != null && t.div && !r(this, Ci) && (x(this, Ci, E(this, Ep, fE).bind(this)), r(this, Te).div.addEventListener("pointerdown", r(this, Ci)), r(this, Te).div.classList.add("highlighting"));
    }
    disableTextSelection() {
      var t;
      this.div.tabIndex = 0, (t = r(this, Te)) != null && t.div && r(this, Ci) && (r(this, Te).div.removeEventListener("pointerdown", r(this, Ci)), x(this, Ci, null), r(this, Te).div.classList.remove("highlighting"));
    }
    enableClick() {
      r(this, Ti) || (x(this, Ti, this.pointerdown.bind(this)), x(this, Zr, this.pointerup.bind(this)), this.div.addEventListener("pointerdown", r(this, Ti)), this.div.addEventListener("pointerup", r(this, Zr)));
    }
    disableClick() {
      r(this, Ti) && (this.div.removeEventListener("pointerdown", r(this, Ti)), this.div.removeEventListener("pointerup", r(this, Zr)), x(this, Ti, null), x(this, Zr, null));
    }
    attach(t) {
      r(this, Ue).set(t.id, t);
      const {
        annotationElementId: e
      } = t;
      e && r(this, ut).isDeletedAnnotationElement(e) && r(this, ut).removeDeletedAnnotationElement(t);
    }
    detach(t) {
      var e;
      r(this, Ue).delete(t.id), (e = r(this, Qr)) == null || e.removePointerInTextLayer(t.contentDiv), !r(this, Go) && t.annotationElementId && r(this, ut).addDeletedAnnotationElement(t);
    }
    remove(t) {
      this.detach(t), r(this, ut).removeEditor(t), t.div.remove(), t.isAttachedToDOM = !1, r(this, Wo) || this.addInkEditorIfNeeded(!1);
    }
    changeParent(t) {
      var e;
      t.parent !== this && (t.parent && t.annotationElementId && (r(this, ut).addDeletedAnnotationElement(t.annotationElementId), Rt.deleteAnnotationElement(t), t.annotationElementId = null), this.attach(t), (e = t.parent) == null || e.detach(t), t.setParent(this), t.div && t.isAttachedToDOM && (t.div.remove(), this.div.append(t.div)));
    }
    add(t) {
      if (!(t.parent === this && t.isAttachedToDOM)) {
        if (this.changeParent(t), r(this, ut).addEditor(t), this.attach(t), !t.isAttachedToDOM) {
          const e = t.render();
          this.div.append(e), t.isAttachedToDOM = !0;
        }
        t.fixAndSetPosition(), t.onceAdded(), r(this, ut).addToAnnotationStorage(t), t._reportTelemetry(t.telemetryInitialData);
      }
    }
    moveEditorInDOM(t) {
      var s;
      if (!t.isAttachedToDOM)
        return;
      const {
        activeElement: e
      } = document;
      t.div.contains(e) && !r(this, Ri) && (t._focusEventsAllowed = !1, x(this, Ri, setTimeout(() => {
        x(this, Ri, null), t.div.contains(document.activeElement) ? t._focusEventsAllowed = !0 : (t.div.addEventListener("focusin", () => {
          t._focusEventsAllowed = !0;
        }, {
          once: !0
        }), e.focus());
      }, 0))), t._structTreeParentId = (s = r(this, Qr)) == null ? void 0 : s.moveElementInDOM(this.div, t.div, t.contentDiv, !0);
    }
    addOrRebuild(t) {
      t.needsToBeRebuilt() ? (t.parent || (t.parent = this), t.rebuild(), t.show()) : this.add(t);
    }
    addUndoableEditor(t) {
      const e = () => t._uiManager.rebuild(t), s = () => {
        t.remove();
      };
      this.addCommands({
        cmd: e,
        undo: s,
        mustExec: !1
      });
    }
    getNextId() {
      return r(this, ut).getId();
    }
    canCreateNewEmptyEditor() {
      var t;
      return (t = r(this, td, Nv)) == null ? void 0 : t.canCreateNewEmptyEditor();
    }
    pasteEditor(t, e) {
      r(this, ut).updateToolbar(t), r(this, ut).updateMode(t);
      const {
        offsetX: s,
        offsetY: a
      } = E(this, sd, Bv).call(this), o = this.getNextId(), h = E(this, ed, Fv).call(this, {
        parent: this,
        id: o,
        x: s,
        y: a,
        uiManager: r(this, ut),
        isCentered: !0,
        ...e
      });
      h && this.add(h);
    }
    deserialize(t) {
      var e;
      return ((e = r(gs, pn).get(t.annotationType ?? t.annotationEditorType)) == null ? void 0 : e.deserialize(t, this, r(this, ut))) || null;
    }
    createAndAddNewEditor(t, e, s = {}) {
      const a = this.getNextId(), o = E(this, ed, Fv).call(this, {
        parent: this,
        id: a,
        x: t.offsetX,
        y: t.offsetY,
        uiManager: r(this, ut),
        isCentered: e,
        ...s
      });
      return o && this.add(o), o;
    }
    addNewEditor() {
      this.createAndAddNewEditor(E(this, sd, Bv).call(this), !0);
    }
    setSelected(t) {
      r(this, ut).setSelected(t);
    }
    toggleSelected(t) {
      r(this, ut).toggleSelected(t);
    }
    isSelected(t) {
      return r(this, ut).isSelected(t);
    }
    unselect(t) {
      r(this, ut).unselect(t);
    }
    pointerup(t) {
      const {
        isMac: e
      } = nt.platform;
      if (!(t.button !== 0 || t.ctrlKey && e) && t.target === this.div && r(this, fn)) {
        if (x(this, fn, !1), !r(this, zo)) {
          x(this, zo, !0);
          return;
        }
        if (r(this, ut).getMode() === w.STAMP) {
          r(this, ut).unselectAll();
          return;
        }
        this.createAndAddNewEditor(t, !1);
      }
    }
    pointerdown(t) {
      if (r(this, ut).getMode() === w.HIGHLIGHT && this.enableTextSelection(), r(this, fn)) {
        x(this, fn, !1);
        return;
      }
      const {
        isMac: e
      } = nt.platform;
      if (t.button !== 0 || t.ctrlKey && e || t.target !== this.div)
        return;
      x(this, fn, !0);
      const s = r(this, ut).getActive();
      x(this, zo, !s || s.isEmpty());
    }
    findNewParent(t, e, s) {
      const a = r(this, ut).findParent(e, s);
      return a === null || a === this ? !1 : (a.changeParent(t), !0);
    }
    destroy() {
      var t, e;
      ((t = r(this, ut).getActive()) == null ? void 0 : t.parent) === this && (r(this, ut).commitOrRemove(), r(this, ut).setActiveEditor(null)), r(this, Ri) && (clearTimeout(r(this, Ri)), x(this, Ri, null));
      for (const s of r(this, Ue).values())
        (e = r(this, Qr)) == null || e.removePointerInTextLayer(s.contentDiv), s.setParent(null), s.isAttachedToDOM = !1, s.div.remove();
      this.div = null, r(this, Ue).clear(), r(this, ut).removeLayer(this);
    }
    render({
      viewport: t
    }) {
      this.viewport = t, jn(this.div, t);
      for (const e of r(this, ut).getEditors(this.pageIndex))
        this.add(e), e.rebuild();
      this.updateMode();
    }
    update({
      viewport: t
    }) {
      r(this, ut).commitOrRemove(), E(this, Xo, qp).call(this);
      const e = this.viewport.rotation, s = t.rotation;
      if (this.viewport = t, jn(this.div, {
        rotation: s
      }), e !== s)
        for (const a of r(this, Ue).values())
          a.rotate(s);
      this.addInkEditorIfNeeded(!1);
    }
    get pageDimensions() {
      const {
        pageWidth: t,
        pageHeight: e
      } = this.viewport.rawDims;
      return [t, e];
    }
    get scale() {
      return r(this, ut).viewParameters.realScale;
    }
  };
  Qr = new WeakMap(), zo = new WeakMap(), js = new WeakMap(), Zr = new WeakMap(), Ti = new WeakMap(), Ci = new WeakMap(), Ri = new WeakMap(), Ue = new WeakMap(), fn = new WeakMap(), Wo = new WeakMap(), Go = new WeakMap(), Te = new WeakMap(), ut = new WeakMap(), pn = new WeakMap(), Ep = new WeakSet(), fE = function(t) {
    if (r(this, ut).unselectAll(), t.target === r(this, Te).div) {
      const {
        isMac: e
      } = nt.platform;
      if (t.button !== 0 || t.ctrlKey && e)
        return;
      r(this, ut).showAllEditors("highlight", !0, !0), r(this, Te).div.classList.add("free"), Hu.startHighlighting(this, r(this, ut).direction === "ltr", t), r(this, Te).div.addEventListener("pointerup", () => {
        r(this, Te).div.classList.remove("free");
      }, {
        once: !0
      }), t.preventDefault();
    }
  }, td = new WeakSet(), Nv = function() {
    return r(gs, pn).get(r(this, ut).getMode());
  }, ed = new WeakSet(), Fv = function(t) {
    const e = r(this, td, Nv);
    return e ? new e.prototype.constructor(t) : null;
  }, sd = new WeakSet(), Bv = function() {
    const {
      x: t,
      y: e,
      width: s,
      height: a
    } = this.div.getBoundingClientRect(), o = Math.max(0, t), h = Math.max(0, e), c = Math.min(window.innerWidth, t + s), p = Math.min(window.innerHeight, e + a), g = (o + c) / 2 - t, b = (h + p) / 2 - e, [S, T] = this.viewport.rotation % 180 === 0 ? [g, b] : [b, g];
    return {
      offsetX: S,
      offsetY: T
    };
  }, Xo = new WeakSet(), qp = function() {
    x(this, Wo, !0);
    for (const t of r(this, Ue).values())
      t.isEmpty() && t.remove();
    x(this, Wo, !1);
  }, bt(gs, "_initialized", !1), v(gs, pn, new Map([wm, Pm, Tm, Hu].map((t) => [t._editorType, t])));
  let Cm = gs;
  const ge = class ge {
    constructor({
      pageIndex: t
    }) {
      v(this, rd);
      v(this, wp);
      v(this, Hs, null);
      v(this, id, 0);
      v(this, se, /* @__PURE__ */ new Map());
      v(this, gn, /* @__PURE__ */ new Map());
      this.pageIndex = t;
    }
    setParent(t) {
      if (!r(this, Hs)) {
        x(this, Hs, t);
        return;
      }
      if (r(this, Hs) !== t) {
        if (r(this, se).size > 0)
          for (const e of r(this, se).values())
            e.remove(), t.append(e);
        x(this, Hs, t);
      }
    }
    static get _svgFactory() {
      return tt(this, "_svgFactory", new em());
    }
    highlight(t, e, s, a = !1) {
      const o = De(this, id)._++, h = E(this, rd, Hv).call(this, t.box);
      h.classList.add("highlight"), t.free && h.classList.add("free");
      const c = ge._svgFactory.createElement("defs");
      h.append(c);
      const p = ge._svgFactory.createElement("path");
      c.append(p);
      const g = `path_p${this.pageIndex}_${o}`;
      p.setAttribute("id", g), p.setAttribute("d", t.toSVGPath()), a && r(this, gn).set(o, p);
      const b = E(this, wp, pE).call(this, c, g), S = ge._svgFactory.createElement("use");
      return h.append(S), h.setAttribute("fill", e), h.setAttribute("fill-opacity", s), S.setAttribute("href", `#${g}`), r(this, se).set(o, h), {
        id: o,
        clipPathId: `url(#${b})`
      };
    }
    highlightOutline(t) {
      const e = De(this, id)._++, s = E(this, rd, Hv).call(this, t.box);
      s.classList.add("highlightOutline");
      const a = ge._svgFactory.createElement("defs");
      s.append(a);
      const o = ge._svgFactory.createElement("path");
      a.append(o);
      const h = `path_p${this.pageIndex}_${e}`;
      o.setAttribute("id", h), o.setAttribute("d", t.toSVGPath()), o.setAttribute("vector-effect", "non-scaling-stroke");
      let c;
      if (t.free) {
        s.classList.add("free");
        const b = ge._svgFactory.createElement("mask");
        a.append(b), c = `mask_p${this.pageIndex}_${e}`, b.setAttribute("id", c), b.setAttribute("maskUnits", "objectBoundingBox");
        const S = ge._svgFactory.createElement("rect");
        b.append(S), S.setAttribute("width", "1"), S.setAttribute("height", "1"), S.setAttribute("fill", "white");
        const T = ge._svgFactory.createElement("use");
        b.append(T), T.setAttribute("href", `#${h}`), T.setAttribute("stroke", "none"), T.setAttribute("fill", "black"), T.setAttribute("fill-rule", "nonzero"), T.classList.add("mask");
      }
      const p = ge._svgFactory.createElement("use");
      s.append(p), p.setAttribute("href", `#${h}`), c && p.setAttribute("mask", `url(#${c})`);
      const g = p.cloneNode();
      return s.append(g), p.classList.add("mainOutline"), g.classList.add("secondaryOutline"), r(this, se).set(e, s), e;
    }
    finalizeLine(t, e) {
      const s = r(this, gn).get(t);
      r(this, gn).delete(t), this.updateBox(t, e.box), s.setAttribute("d", e.toSVGPath());
    }
    updateLine(t, e) {
      r(this, se).get(t).firstChild.firstChild.setAttribute("d", e.toSVGPath());
    }
    removeFreeHighlight(t) {
      this.remove(t), r(this, gn).delete(t);
    }
    updatePath(t, e) {
      r(this, gn).get(t).setAttribute("d", e.toSVGPath());
    }
    updateBox(t, e) {
      var s;
      E(s = ge, nd, jv).call(s, r(this, se).get(t), e);
    }
    show(t, e) {
      r(this, se).get(t).classList.toggle("hidden", !e);
    }
    rotate(t, e) {
      r(this, se).get(t).setAttribute("data-main-rotation", e);
    }
    changeColor(t, e) {
      r(this, se).get(t).setAttribute("fill", e);
    }
    changeOpacity(t, e) {
      r(this, se).get(t).setAttribute("fill-opacity", e);
    }
    addClass(t, e) {
      r(this, se).get(t).classList.add(e);
    }
    removeClass(t, e) {
      r(this, se).get(t).classList.remove(e);
    }
    remove(t) {
      r(this, Hs) !== null && (r(this, se).get(t).remove(), r(this, se).delete(t));
    }
    destroy() {
      x(this, Hs, null);
      for (const t of r(this, se).values())
        t.remove();
      r(this, se).clear();
    }
  };
  Hs = new WeakMap(), id = new WeakMap(), se = new WeakMap(), gn = new WeakMap(), nd = new WeakSet(), jv = function(t, {
    x: e = 0,
    y: s = 0,
    width: a = 1,
    height: o = 1
  } = {}) {
    const {
      style: h
    } = t;
    h.top = `${100 * s}%`, h.left = `${100 * e}%`, h.width = `${100 * a}%`, h.height = `${100 * o}%`;
  }, rd = new WeakSet(), Hv = function(t) {
    var s;
    const e = ge._svgFactory.create(1, 1, !0);
    return r(this, Hs).append(e), e.setAttribute("aria-hidden", !0), E(s = ge, nd, jv).call(s, e, t), e;
  }, wp = new WeakSet(), pE = function(t, e) {
    const s = ge._svgFactory.createElement("clipPath");
    t.append(s);
    const a = `clip_${e}`;
    s.setAttribute("id", a), s.setAttribute("clipPathUnits", "objectBoundingBox");
    const o = ge._svgFactory.createElement("use");
    return s.append(o), o.setAttribute("href", `#${e}`), o.classList.add("clip"), a;
  }, v(ge, nd);
  let Rm = ge;
})();
pt.AbortException;
pt.AnnotationEditorLayer;
pt.AnnotationEditorParamsType;
pt.AnnotationEditorType;
pt.AnnotationEditorUIManager;
var rS = pt.AnnotationLayer;
pt.AnnotationMode;
pt.CMapCompressionType;
pt.ColorPicker;
pt.DOMSVGFactory;
pt.DrawLayer;
pt.FeatureTest;
var jP = pt.GlobalWorkerOptions;
pt.ImageKind;
pt.InvalidPDFException;
pt.MissingPDFException;
pt.OPS;
pt.Outliner;
pt.PDFDataRangeTransport;
pt.PDFDateString;
pt.PDFWorker;
var aS = pt.PasswordResponses;
pt.PermissionFlag;
pt.PixelsPerInch;
pt.RenderingCancelledException;
var oS = pt.TextLayer;
pt.UnexpectedResponseException;
pt.Util;
pt.VerbosityLevel;
pt.XfaLayer;
pt.build;
pt.createValidAbsoluteUrl;
pt.fetchData;
var lS = pt.getDocument;
pt.getFilenameFromUrl;
pt.getPdfFilenameFromUrl;
pt.getXfaPageViewport;
pt.isDataScheme;
pt.isPdfFile;
pt.noContextMenu;
pt.normalizeUnicode;
pt.renderTextLayer;
pt.setLayerDimensions;
pt.shadow;
pt.updateTextLayer;
pt.version;
function hS({
  onError: u,
  onPasswordRequest: n,
  onProgress: i,
  source: l
}) {
  const d = Md(null), f = Md(null);
  return Yw(async () => {
    const m = Qw(l);
    if (m) {
      if (Object.prototype.hasOwnProperty.call(m, "_pdfInfo")) {
        d.value = m;
        return;
      }
      try {
        f.value = lS(
          m
        ), n && (f.value.onPassword = (y, w) => {
          n({
            callback: y,
            isWrongPassword: w === aS.INCORRECT_PASSWORD
          });
        }), i && (f.value.onProgress = i), d.value = await f.value.promise;
      } catch (y) {
        if (d.value = null, u)
          u(y);
        else
          throw y;
      }
    }
  }), Ky(() => {
    var m, y, w;
    (m = f.value) != null && m.onPassword && (f.value.onPassword = null), (y = f.value) != null && y.onProgress && (f.value.onProgress = null), (w = d.value) == null || w.destroy();
  }), {
    doc: d
  };
}
var Od = {};
Od.d = (u, n) => {
  for (var i in n)
    Od.o(n, i) && !Od.o(u, i) && Object.defineProperty(u, i, { enumerable: !0, get: n[i] });
};
Od.o = (u, n) => Object.prototype.hasOwnProperty.call(u, n);
var Gt = globalThis.pdfjsViewer = {};
Od.d(Gt, {
  AnnotationLayerBuilder: () => (
    /* reexport */
    CE
  ),
  DownloadManager: () => (
    /* reexport */
    nx
  ),
  EventBus: () => (
    /* reexport */
    RE
  ),
  FindState: () => (
    /* reexport */
    yn
  ),
  GenericL10n: () => (
    /* reexport */
    Cl
  ),
  LinkTarget: () => (
    /* reexport */
    sa
  ),
  PDFFindController: () => (
    /* reexport */
    WS
  ),
  PDFHistory: () => (
    /* reexport */
    eP
  ),
  PDFLinkService: () => (
    /* reexport */
    dg
  ),
  PDFPageView: () => (
    /* reexport */
    KE
  ),
  PDFScriptingManager: () => (
    /* reexport */
    pP
  ),
  PDFSinglePageViewer: () => (
    /* reexport */
    bP
  ),
  PDFViewer: () => (
    /* reexport */
    qE
  ),
  ProgressBar: () => (
    /* reexport */
    wS
  ),
  RenderingStates: () => (
    /* reexport */
    Kt
  ),
  ScrollMode: () => (
    /* reexport */
    xt
  ),
  SimpleLinkService: () => (
    /* reexport */
    yb
  ),
  SpreadMode: () => (
    /* reexport */
    we
  ),
  StructTreeLayerBuilder: () => (
    /* reexport */
    $E
  ),
  TextLayerBuilder: () => (
    /* reexport */
    pg
  ),
  XfaLayerBuilder: () => (
    /* reexport */
    XE
  ),
  parseQueryString: () => (
    /* reexport */
    Jg
  )
});
const cS = "auto", gE = 1, fy = 1.1, dS = 0.1, uS = 10, km = 0, fS = 1.25, py = 40, gy = 5, Kt = {
  INITIAL: 0,
  RUNNING: 1,
  PAUSED: 2,
  FINISHED: 3
}, rl = {
  UNKNOWN: 0,
  NORMAL: 1,
  CHANGING: 2,
  FULLSCREEN: 3
}, Ws = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_PERMISSIONS: 2
}, xt = {
  UNKNOWN: -1,
  VERTICAL: 0,
  HORIZONTAL: 1,
  WRAPPED: 2,
  PAGE: 3
}, we = {
  UNKNOWN: -1,
  NONE: 0,
  ODD: 1,
  EVEN: 2
};
class pS {
  constructor() {
    const n = window.devicePixelRatio || 1;
    this.sx = n, this.sy = n;
  }
  get scaled() {
    return this.sx !== 1 || this.sy !== 1;
  }
}
function mE(u, n, i = !1) {
  let l = u.offsetParent;
  if (!l) {
    console.error("offsetParent is not set -- cannot scroll");
    return;
  }
  let d = u.offsetTop + u.clientTop, f = u.offsetLeft + u.clientLeft;
  for (; l.clientHeight === l.scrollHeight && l.clientWidth === l.scrollWidth || i && (l.classList.contains("markedContent") || getComputedStyle(l).overflow === "hidden"); )
    if (d += l.offsetTop, f += l.offsetLeft, l = l.offsetParent, !l)
      return;
  n && (n.top !== void 0 && (d += n.top), n.left !== void 0 && (f += n.left, l.scrollLeft = f)), l.scrollTop = d;
}
function gS(u, n) {
  const i = function(f) {
    d || (d = window.requestAnimationFrame(function() {
      d = null;
      const y = u.scrollLeft, w = l.lastX;
      y !== w && (l.right = y > w), l.lastX = y;
      const P = u.scrollTop, I = l.lastY;
      P !== I && (l.down = P > I), l.lastY = P, n(l);
    }));
  }, l = {
    right: !0,
    down: !0,
    lastX: u.scrollLeft,
    lastY: u.scrollTop,
    _eventHandler: i
  };
  let d = null;
  return u.addEventListener("scroll", i, !0), l;
}
function Jg(u) {
  const n = /* @__PURE__ */ new Map();
  for (const [i, l] of new URLSearchParams(u))
    n.set(i.toLowerCase(), l);
  return n;
}
const my = /[\x00-\x1F]/g;
function cg(u, n = !1) {
  return my.test(u) ? n ? u.replaceAll(my, (i) => i === "\0" ? "" : " ") : u.replaceAll("\0", "") : u;
}
function Dd(u, n, i = 0) {
  let l = i, d = u.length - 1;
  if (d < 0 || !n(u[d]))
    return u.length;
  if (n(u[l]))
    return l;
  for (; l < d; ) {
    const f = l + d >> 1, m = u[f];
    n(m) ? d = f : l = f + 1;
  }
  return l;
}
function vy(u) {
  if (Math.floor(u) === u)
    return [u, 1];
  const n = 1 / u, i = 8;
  if (n > i)
    return [1, i];
  if (Math.floor(n) === n)
    return [1, n];
  const l = u > 1 ? n : u;
  let d = 0, f = 1, m = 1, y = 1;
  for (; ; ) {
    const P = d + m, I = f + y;
    if (I > i)
      break;
    l <= P / I ? (m = P, y = I) : (d = P, f = I);
  }
  let w;
  return l - d / f < m / y - l ? w = l === u ? [d, f] : [f, d] : w = l === u ? [m, y] : [y, m], w;
}
function Pp(u, n) {
  const i = u % n;
  return i === 0 ? u : Math.round(u - i + n);
}
function mS(u, n, i) {
  if (u < 2)
    return u;
  let l = n[u].div, d = l.offsetTop + l.clientTop;
  d >= i && (l = n[u - 1].div, d = l.offsetTop + l.clientTop);
  for (let f = u - 2; f >= 0 && (l = n[f].div, !(l.offsetTop + l.clientTop + l.clientHeight <= d)); --f)
    u = f;
  return u;
}
function vS({
  scrollEl: u,
  views: n,
  sortByVisibility: i = !1,
  horizontal: l = !1,
  rtl: d = !1
}) {
  const f = u.scrollTop, m = f + u.clientHeight, y = u.scrollLeft, w = y + u.clientWidth;
  function P(z) {
    const V = z.div;
    return V.offsetTop + V.clientTop + V.clientHeight > f;
  }
  function I(z) {
    const V = z.div, Z = V.offsetLeft + V.clientLeft, K = Z + V.clientWidth;
    return d ? Z < w : K > y;
  }
  const L = [], _ = /* @__PURE__ */ new Set(), D = n.length;
  let k = Dd(n, l ? I : P);
  k > 0 && k < D && !l && (k = mS(k, n, f));
  let H = l ? w : -1;
  for (let z = k; z < D; z++) {
    const V = n[z], Z = V.div, K = Z.offsetLeft + Z.clientLeft, $ = Z.offsetTop + Z.clientTop, j = Z.clientWidth, Q = Z.clientHeight, B = K + j, G = $ + Q;
    if (H === -1)
      G >= m && (H = G);
    else if ((l ? K : $) > H)
      break;
    if (G <= f || $ >= m || B <= y || K >= w)
      continue;
    const q = Math.max(0, f - $) + Math.max(0, G - m), tt = Math.max(0, y - K) + Math.max(0, B - w), lt = (Q - q) / Q, vt = (j - tt) / j, dt = lt * vt * 100 | 0;
    L.push({
      id: V.id,
      x: K,
      y: $,
      view: V,
      percent: dt,
      widthPercent: vt * 100 | 0
    }), _.add(V.id);
  }
  const X = L[0], N = L.at(-1);
  return i && L.sort(function(z, V) {
    const Z = z.percent - V.percent;
    return Math.abs(Z) > 1e-3 ? -Z : z.id - V.id;
  }), {
    first: X,
    last: N,
    views: L,
    ids: _
  };
}
function vE(u) {
  return Number.isInteger(u) && u % 90 === 0;
}
function bS(u) {
  return Number.isInteger(u) && Object.values(xt).includes(u) && u !== xt.UNKNOWN;
}
function yS(u) {
  return Number.isInteger(u) && Object.values(we).includes(u) && u !== we.UNKNOWN;
}
function by(u) {
  return u.width <= u.height;
}
new Promise(function(u) {
  window.requestAnimationFrame(u);
});
const AS = document.documentElement.style;
function ES(u, n, i) {
  return Math.min(Math.max(u, n), i);
}
var Sn, na, ra, al, aa;
class wS {
  constructor(n) {
    v(this, Sn, null);
    v(this, na, null);
    v(this, ra, 0);
    v(this, al, null);
    v(this, aa, !0);
    x(this, Sn, n.classList), x(this, al, n.style);
  }
  get percent() {
    return r(this, ra);
  }
  set percent(n) {
    if (x(this, ra, ES(n, 0, 100)), isNaN(n)) {
      r(this, Sn).add("indeterminate");
      return;
    }
    r(this, Sn).remove("indeterminate"), r(this, al).setProperty("--progressBar-percent", `${r(this, ra)}%`);
  }
  setWidth(n) {
    if (!n)
      return;
    const l = n.parentNode.offsetWidth - n.offsetWidth;
    l > 0 && r(this, al).setProperty("--progressBar-end-offset", `${l}px`);
  }
  setDisableAutoFetch(n = 5e3) {
    isNaN(r(this, ra)) || (r(this, na) && clearTimeout(r(this, na)), this.show(), x(this, na, setTimeout(() => {
      x(this, na, null), this.hide();
    }, n)));
  }
  hide() {
    r(this, aa) && (x(this, aa, !1), r(this, Sn).add("hidden"));
  }
  show() {
    r(this, aa) || (x(this, aa, !0), r(this, Sn).remove("hidden"));
  }
}
Sn = new WeakMap(), na = new WeakMap(), ra = new WeakMap(), al = new WeakMap(), aa = new WeakMap();
function SS(u) {
  let n = xt.VERTICAL, i = we.NONE;
  switch (u) {
    case "SinglePage":
      n = xt.PAGE;
      break;
    case "OneColumn":
      break;
    case "TwoPageLeft":
      n = xt.PAGE;
    case "TwoColumnLeft":
      i = we.ODD;
      break;
    case "TwoPageRight":
      n = xt.PAGE;
    case "TwoColumnRight":
      i = we.EVEN;
      break;
  }
  return {
    scrollMode: n,
    spreadMode: i
  };
}
const ms = {
  SPACE: 0,
  ALPHA_LETTER: 1,
  PUNCT: 2,
  HAN_LETTER: 3,
  KATAKANA_LETTER: 4,
  HIRAGANA_LETTER: 5,
  HALFWIDTH_KATAKANA_LETTER: 6,
  THAI_LETTER: 7
};
function xS(u) {
  return u < 11904;
}
function PS(u) {
  return (u & 65408) === 0;
}
function TS(u) {
  return u >= 97 && u <= 122 || u >= 65 && u <= 90;
}
function CS(u) {
  return u >= 48 && u <= 57;
}
function RS(u) {
  return u === 32 || u === 9 || u === 13 || u === 10;
}
function IS(u) {
  return u >= 13312 && u <= 40959 || u >= 63744 && u <= 64255;
}
function LS(u) {
  return u >= 12448 && u <= 12543;
}
function _S(u) {
  return u >= 12352 && u <= 12447;
}
function MS(u) {
  return u >= 65376 && u <= 65439;
}
function OS(u) {
  return (u & 65408) === 3584;
}
function Tp(u) {
  return xS(u) ? PS(u) ? RS(u) ? ms.SPACE : TS(u) || CS(u) || u === 95 ? ms.ALPHA_LETTER : ms.PUNCT : OS(u) ? ms.THAI_LETTER : u === 160 ? ms.SPACE : ms.ALPHA_LETTER : IS(u) ? ms.HAN_LETTER : LS(u) ? ms.KATAKANA_LETTER : _S(u) ? ms.HIRAGANA_LETTER : MS(u) ? ms.HALFWIDTH_KATAKANA_LETTER : ms.ALPHA_LETTER;
}
let yy;
function kS() {
  return yy || (yy = " ¨ª¯²-µ¸-º¼-¾Ĳ-ĳĿ-ŀŉſǄ-ǌǱ-ǳʰ-ʸ˘-˝ˠ-ˤʹͺ;΄-΅·ϐ-ϖϰ-ϲϴ-ϵϹևٵ-ٸक़-य़ড়-ঢ়য়ਲ਼ਸ਼ਖ਼-ਜ਼ਫ਼ଡ଼-ଢ଼ำຳໜ-ໝ༌གྷཌྷདྷབྷཛྷཀྵჼᴬ-ᴮᴰ-ᴺᴼ-ᵍᵏ-ᵪᵸᶛ-ᶿẚ-ẛάέήίόύώΆ᾽-῁ΈΉ῍-῏ΐΊ῝-῟ΰΎ῭-`ΌΏ´-῾ - ‑‗․-… ″-‴‶-‷‼‾⁇-⁉⁗ ⁰-ⁱ⁴-₎ₐ-ₜ₨℀-℃℅-ℇ℉-ℓℕ-№ℙ-ℝ℠-™ℤΩℨK-ℭℯ-ℱℳ-ℹ℻-⅀ⅅ-ⅉ⅐-ⅿ↉∬-∭∯-∰〈-〉①-⓪⨌⩴-⩶⫝̸ⱼ-ⱽⵯ⺟⻳⼀-⿕　〶〸-〺゛-゜ゟヿㄱ-ㆎ㆒-㆟㈀-㈞㈠-㉇㉐-㉾㊀-㏿ꚜ-ꚝꝰꟲ-ꟴꟸ-ꟹꭜ-ꭟꭩ豈-嗀塚晴凞-羽蘒諸逸-都飯-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-זּטּ-לּמּנּ-סּףּ-פּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-﷼︐-︙︰-﹄﹇-﹒﹔-﹦﹨-﹫ﹰ-ﹲﹴﹶ-ﻼ！-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ￠-￦"), yy;
}
const yn = {
  FOUND: 0,
  NOT_FOUND: 1,
  WRAPPED: 2,
  PENDING: 3
}, DS = 250, NS = -50, FS = -400, Ay = {
  "‐": "-",
  "‘": "'",
  "’": "'",
  "‚": "'",
  "‛": "'",
  "“": '"',
  "”": '"',
  "„": '"',
  "‟": '"',
  "¼": "1/4",
  "½": "1/2",
  "¾": "3/4"
}, Ey = /* @__PURE__ */ new Set([12441, 12442, 2381, 2509, 2637, 2765, 2893, 3021, 3149, 3277, 3387, 3388, 3405, 3530, 3642, 3770, 3972, 4153, 4154, 5908, 5940, 6098, 6752, 6980, 7082, 7083, 7154, 7155, 11647, 43014, 43052, 43204, 43347, 43456, 43766, 44013, 3158, 3953, 3954, 3962, 3963, 3964, 3965, 3968, 3956]);
let wy;
const BS = /\p{M}+/gu, jS = /([.*+?^${}()|[\]\\])|(\p{P})|(\s+)|(\p{M})|(\p{L})/gu, HS = /([^\p{M}])\p{M}*$/u, VS = /^\p{M}*([^\p{M}])/u, $S = /[\uAC00-\uD7AF\uFA6C\uFACF-\uFAD1\uFAD5-\uFAD7]+/g, Sy = /* @__PURE__ */ new Map(), US = "[\\u1100-\\u1112\\ud7a4-\\ud7af\\ud84a\\ud84c\\ud850\\ud854\\ud857\\ud85f]", xy = /* @__PURE__ */ new Map();
let Dm = null, Nm = null;
function Fm(u) {
  const n = [];
  let i;
  for (; (i = $S.exec(u)) !== null; ) {
    let {
      index: D
    } = i;
    for (const k of i[0]) {
      let H = Sy.get(k);
      H || (H = k.normalize("NFD").length, Sy.set(k, H)), n.push([H, D++]);
    }
  }
  let l;
  if (n.length === 0 && Dm)
    l = Dm;
  else if (n.length > 0 && Nm)
    l = Nm;
  else {
    const D = Object.keys(Ay).join(""), k = kS(), N = `([${D}])|([${k}])|((?:゙|゚)\\n)|(\\p{M}+(?:-\\n)?)|(\\S-\\n)|((?:\\p{Ideographic}|[぀-ヿ])\\n)|(\\n)`;
    n.length === 0 ? l = Dm = new RegExp(N + "|(\\u0000)", "gum") : l = Nm = new RegExp(N + `|(${US})`, "gum");
  }
  const d = [];
  for (; (i = BS.exec(u)) !== null; )
    d.push([i[0].length, i.index]);
  let f = u.normalize("NFD");
  const m = [[0, 0]];
  let y = 0, w = 0, P = 0, I = 0, L = 0, _ = !1;
  return f = f.replace(l, (D, k, H, X, N, z, V, Z, K, $) => {
    var j, Q, B;
    if ($ -= I, k) {
      const G = Ay[k], q = G.length;
      for (let tt = 1; tt < q; tt++)
        m.push([$ - P + tt, P - tt]);
      return P -= q - 1, G;
    }
    if (H) {
      let G = xy.get(H);
      G || (G = H.normalize("NFKC"), xy.set(H, G));
      const q = G.length;
      for (let tt = 1; tt < q; tt++)
        m.push([$ - P + tt, P - tt]);
      return P -= q - 1, G;
    }
    if (X)
      return _ = !0, $ + L === ((j = d[y]) == null ? void 0 : j[1]) ? ++y : (m.push([$ - 1 - P + 1, P - 1]), P -= 1, I += 1), m.push([$ - P + 1, P]), I += 1, L += 1, X.charAt(0);
    if (N) {
      const G = N.endsWith(`
`), q = G ? N.length - 2 : N.length;
      _ = !0;
      let tt = q;
      $ + L === ((Q = d[y]) == null ? void 0 : Q[1]) && (tt -= d[y][0], ++y);
      for (let lt = 1; lt <= tt; lt++)
        m.push([$ - 1 - P + lt, P - lt]);
      return P -= tt, I += tt, G ? ($ += q - 1, m.push([$ - P + 1, 1 + P]), P += 1, I += 1, L += 1, N.slice(0, q)) : N;
    }
    if (z) {
      const G = z.length - 2;
      return m.push([$ - P + G, 1 + P]), P += 1, I += 1, L += 1, z.slice(0, -2);
    }
    if (V) {
      const G = V.length - 1;
      return m.push([$ - P + G, P]), I += 1, L += 1, V.slice(0, -1);
    }
    if (Z)
      return m.push([$ - P + 1, P - 1]), P -= 1, I += 1, L += 1, " ";
    if ($ + L === ((B = n[w]) == null ? void 0 : B[1])) {
      const G = n[w][0] - 1;
      ++w;
      for (let q = 1; q <= G; q++)
        m.push([$ - (P - q), P - q]);
      P -= G, I += G;
    }
    return K;
  }), m.push([f.length, P]), [f, m, _];
}
function zS(u, n, i) {
  if (!u)
    return [n, i];
  const l = n, d = n + i - 1;
  let f = Dd(u, (I) => I[0] >= l);
  u[f][0] > l && --f;
  let m = Dd(u, (I) => I[0] >= d, f);
  u[m][0] > d && --m;
  const y = l + u[f][1], P = d + u[m][1] + 1 - y;
  return [y, P];
}
var ve, ol, oa, gg, bE, Bd, Vv, jd, $v, mg, yE, vg, AE, bg, EE, Hd, Uv, yg, wE, Ag, SE, ll, tg, la, Pd, xn, el, Eg, xE, Vd, zv, $d, Wv, hl, eg, wg, PE, Ud, Gv, zd, Xv, ha, Td;
class WS {
  constructor({
    linkService: n,
    eventBus: i,
    updateMatchesCountOnProgress: l = !0
  }) {
    v(this, gg);
    v(this, Bd);
    v(this, jd);
    v(this, mg);
    v(this, vg);
    v(this, bg);
    v(this, Hd);
    v(this, yg);
    v(this, Ag);
    v(this, ll);
    v(this, la);
    v(this, xn);
    v(this, Eg);
    v(this, Vd);
    v(this, $d);
    v(this, hl);
    v(this, wg);
    v(this, Ud);
    v(this, zd);
    v(this, ha);
    v(this, ve, null);
    v(this, ol, !0);
    v(this, oa, 0);
    this._linkService = n, this._eventBus = i, x(this, ol, l), this.onIsPageVisible = null, E(this, Bd, Vv).call(this), i._on("find", E(this, gg, bE).bind(this)), i._on("findbarclose", E(this, wg, PE).bind(this));
  }
  get highlightMatches() {
    return this._highlightMatches;
  }
  get pageMatches() {
    return this._pageMatches;
  }
  get pageMatchesLength() {
    return this._pageMatchesLength;
  }
  get selected() {
    return this._selected;
  }
  get state() {
    return r(this, ve);
  }
  setDocument(n) {
    this._pdfDocument && E(this, Bd, Vv).call(this), n && (this._pdfDocument = n, this._firstPageCapability.resolve());
  }
  scrollMatchIntoView({
    element: n = null,
    selectedLeft: i = 0,
    pageIndex: l = -1,
    matchIndex: d = -1
  }) {
    if (!this._scrollMatches || !n)
      return;
    if (d === -1 || d !== this._selected.matchIdx)
      return;
    if (l === -1 || l !== this._selected.pageIdx)
      return;
    this._scrollMatches = !1;
    const f = {
      top: NS,
      left: i + FS
    };
    mE(n, f, !0);
  }
}
ve = new WeakMap(), ol = new WeakMap(), oa = new WeakMap(), gg = new WeakSet(), bE = function(n) {
  if (!n)
    return;
  const i = this._pdfDocument, {
    type: l
  } = n;
  (r(this, ve) === null || E(this, mg, yE).call(this, n)) && (this._dirtyMatch = !0), x(this, ve, n), l !== "highlightallchange" && E(this, ha, Td).call(this, yn.PENDING), this._firstPageCapability.promise.then(() => {
    if (!this._pdfDocument || i && this._pdfDocument !== i)
      return;
    E(this, Ag, SE).call(this);
    const d = !this._highlightMatches, f = !!this._findTimeout;
    this._findTimeout && (clearTimeout(this._findTimeout), this._findTimeout = null), l ? this._dirtyMatch ? E(this, xn, el).call(this) : l === "again" ? (E(this, xn, el).call(this), d && r(this, ve).highlightAll && E(this, la, Pd).call(this)) : l === "highlightallchange" ? (f ? E(this, xn, el).call(this) : this._highlightMatches = !0, E(this, la, Pd).call(this)) : E(this, xn, el).call(this) : this._findTimeout = setTimeout(() => {
      E(this, xn, el).call(this), this._findTimeout = null;
    }, DS);
  });
}, Bd = new WeakSet(), Vv = function() {
  this._highlightMatches = !1, this._scrollMatches = !1, this._pdfDocument = null, this._pageMatches = [], this._pageMatchesLength = [], x(this, oa, 0), x(this, ve, null), this._selected = {
    pageIdx: -1,
    matchIdx: -1
  }, this._offset = {
    pageIdx: null,
    matchIdx: null,
    wrapped: !1
  }, this._extractTextPromises = [], this._pageContents = [], this._pageDiffs = [], this._hasDiacritics = [], this._matchesCountTotal = 0, this._pagesToSearch = null, this._pendingFindMatches = /* @__PURE__ */ new Set(), this._resumePageIdx = null, this._dirtyMatch = !1, clearTimeout(this._findTimeout), this._findTimeout = null, this._firstPageCapability = Promise.withResolvers();
}, jd = new WeakSet(), $v = function() {
  const {
    query: n
  } = r(this, ve);
  return typeof n == "string" ? (n !== this._rawQuery && (this._rawQuery = n, [this._normalizedQuery] = Fm(n)), this._normalizedQuery) : (n || []).filter((i) => !!i).map((i) => Fm(i)[0]);
}, mg = new WeakSet(), yE = function(n) {
  var m;
  const i = n.query, l = r(this, ve).query, d = typeof i;
  if (d !== typeof l)
    return !0;
  if (d === "string") {
    if (i !== l)
      return !0;
  } else if (JSON.stringify(i) !== JSON.stringify(l))
    return !0;
  switch (n.type) {
    case "again":
      const y = this._selected.pageIdx + 1, w = this._linkService;
      return y >= 1 && y <= w.pagesCount && y !== w.page && !(((m = this.onIsPageVisible) == null ? void 0 : m.call(this, y)) ?? !0);
    case "highlightallchange":
      return !1;
  }
  return !0;
}, vg = new WeakSet(), AE = function(n, i, l) {
  let d = n.slice(0, i).match(HS);
  if (d) {
    const f = n.charCodeAt(i), m = d[1].charCodeAt(0);
    if (Tp(f) === Tp(m))
      return !1;
  }
  if (d = n.slice(i + l).match(VS), d) {
    const f = n.charCodeAt(i + l - 1), m = d[1].charCodeAt(0);
    if (Tp(f) === Tp(m))
      return !1;
  }
  return !0;
}, bg = new WeakSet(), EE = function(n, i, l, d) {
  const f = this._pageMatches[l] = [], m = this._pageMatchesLength[l] = [];
  if (!n)
    return;
  const y = this._pageDiffs[l];
  let w;
  for (; (w = n.exec(d)) !== null; ) {
    if (i && !E(this, vg, AE).call(this, d, w.index, w[0].length))
      continue;
    const [P, I] = zS(y, w.index, w[0].length);
    I && (f.push(P), m.push(I));
  }
}, Hd = new WeakSet(), Uv = function(n, i) {
  const {
    matchDiacritics: l
  } = r(this, ve);
  let d = !1;
  n = n.replaceAll(jS, (m, y, w, P, I, L) => y ? `[ ]*\\${y}[ ]*` : w ? `[ ]*${w}[ ]*` : P ? "[ ]+" : l ? I || L : I ? Ey.has(I.charCodeAt(0)) ? I : "" : i ? (d = !0, `${L}\\p{M}*`) : L);
  const f = "[ ]*";
  return n.endsWith(f) && (n = n.slice(0, n.length - f.length)), l && i && (wy || (wy = String.fromCharCode(...Ey)), d = !0, n = `${n}(?=[${wy}]|[^\\p{M}]|$)`), [d, n];
}, yg = new WeakSet(), wE = function(n) {
  let i = r(this, jd, $v);
  if (i.length === 0)
    return;
  const {
    caseSensitive: l,
    entireWord: d
  } = r(this, ve), f = this._pageContents[n], m = this._hasDiacritics[n];
  let y = !1;
  typeof i == "string" ? [y, i] = E(this, Hd, Uv).call(this, i, m) : i = i.sort().reverse().map((I) => {
    const [L, _] = E(this, Hd, Uv).call(this, I, m);
    return y || (y = L), `(${_})`;
  }).join("|");
  const w = `g${y ? "u" : ""}${l ? "" : "i"}`;
  i = i ? new RegExp(i, w) : null, E(this, bg, EE).call(this, i, d, n, f), r(this, ve).highlightAll && E(this, ll, tg).call(this, n), this._resumePageIdx === n && (this._resumePageIdx = null, E(this, Vd, zv).call(this));
  const P = this._pageMatches[n].length;
  this._matchesCountTotal += P, r(this, ol) ? P > 0 && E(this, zd, Xv).call(this) : ++De(this, oa)._ === this._linkService.pagesCount && E(this, zd, Xv).call(this);
}, Ag = new WeakSet(), SE = function() {
  if (this._extractTextPromises.length > 0)
    return;
  let n = Promise.resolve();
  const i = {
    disableNormalization: !0
  };
  for (let l = 0, d = this._linkService.pagesCount; l < d; l++) {
    const {
      promise: f,
      resolve: m
    } = Promise.withResolvers();
    this._extractTextPromises[l] = f, n = n.then(() => this._pdfDocument.getPage(l + 1).then((y) => y.getTextContent(i)).then((y) => {
      const w = [];
      for (const P of y.items)
        w.push(P.str), P.hasEOL && w.push(`
`);
      [this._pageContents[l], this._pageDiffs[l], this._hasDiacritics[l]] = Fm(w.join("")), m();
    }, (y) => {
      console.error(`Unable to get text content for page ${l + 1}`, y), this._pageContents[l] = "", this._pageDiffs[l] = null, this._hasDiacritics[l] = !1, m();
    }));
  }
}, ll = new WeakSet(), tg = function(n) {
  this._scrollMatches && this._selected.pageIdx === n && (this._linkService.page = n + 1), this._eventBus.dispatch("updatetextlayermatches", {
    source: this,
    pageIndex: n
  });
}, la = new WeakSet(), Pd = function() {
  this._eventBus.dispatch("updatetextlayermatches", {
    source: this,
    pageIndex: -1
  });
}, xn = new WeakSet(), el = function() {
  const n = r(this, ve).findPrevious, i = this._linkService.page - 1, l = this._linkService.pagesCount;
  if (this._highlightMatches = !0, this._dirtyMatch) {
    this._dirtyMatch = !1, this._selected.pageIdx = this._selected.matchIdx = -1, this._offset.pageIdx = i, this._offset.matchIdx = null, this._offset.wrapped = !1, this._resumePageIdx = null, this._pageMatches.length = 0, this._pageMatchesLength.length = 0, x(this, oa, 0), this._matchesCountTotal = 0, E(this, la, Pd).call(this);
    for (let m = 0; m < l; m++)
      this._pendingFindMatches.has(m) || (this._pendingFindMatches.add(m), this._extractTextPromises[m].then(() => {
        this._pendingFindMatches.delete(m), E(this, yg, wE).call(this, m);
      }));
  }
  if (r(this, jd, $v).length === 0) {
    E(this, ha, Td).call(this, yn.FOUND);
    return;
  }
  if (this._resumePageIdx)
    return;
  const f = this._offset;
  if (this._pagesToSearch = l, f.matchIdx !== null) {
    const m = this._pageMatches[f.pageIdx].length;
    if (!n && f.matchIdx + 1 < m || n && f.matchIdx > 0) {
      f.matchIdx = n ? f.matchIdx - 1 : f.matchIdx + 1, E(this, hl, eg).call(this, !0);
      return;
    }
    E(this, $d, Wv).call(this, n);
  }
  E(this, Vd, zv).call(this);
}, Eg = new WeakSet(), xE = function(n) {
  const i = this._offset, l = n.length, d = r(this, ve).findPrevious;
  return l ? (i.matchIdx = d ? l - 1 : 0, E(this, hl, eg).call(this, !0), !0) : (E(this, $d, Wv).call(this, d), i.wrapped && (i.matchIdx = null, this._pagesToSearch < 0) ? (E(this, hl, eg).call(this, !1), !0) : !1);
}, Vd = new WeakSet(), zv = function() {
  this._resumePageIdx !== null && console.error("There can only be one pending page.");
  let n = null;
  do {
    const i = this._offset.pageIdx;
    if (n = this._pageMatches[i], !n) {
      this._resumePageIdx = i;
      break;
    }
  } while (!E(this, Eg, xE).call(this, n));
}, $d = new WeakSet(), Wv = function(n) {
  const i = this._offset, l = this._linkService.pagesCount;
  i.pageIdx = n ? i.pageIdx - 1 : i.pageIdx + 1, i.matchIdx = null, this._pagesToSearch--, (i.pageIdx >= l || i.pageIdx < 0) && (i.pageIdx = n ? l - 1 : 0, i.wrapped = !0);
}, hl = new WeakSet(), eg = function(n = !1) {
  let i = yn.NOT_FOUND;
  const l = this._offset.wrapped;
  if (this._offset.wrapped = !1, n) {
    const d = this._selected.pageIdx;
    this._selected.pageIdx = this._offset.pageIdx, this._selected.matchIdx = this._offset.matchIdx, i = l ? yn.WRAPPED : yn.FOUND, d !== -1 && d !== this._selected.pageIdx && E(this, ll, tg).call(this, d);
  }
  E(this, ha, Td).call(this, i, r(this, ve).findPrevious), this._selected.pageIdx !== -1 && (this._scrollMatches = !0, E(this, ll, tg).call(this, this._selected.pageIdx));
}, wg = new WeakSet(), PE = function(n) {
  const i = this._pdfDocument;
  this._firstPageCapability.promise.then(() => {
    !this._pdfDocument || i && this._pdfDocument !== i || (this._findTimeout && (clearTimeout(this._findTimeout), this._findTimeout = null), this._resumePageIdx && (this._resumePageIdx = null, this._dirtyMatch = !0), E(this, ha, Td).call(this, yn.FOUND), this._highlightMatches = !1, E(this, la, Pd).call(this));
  });
}, Ud = new WeakSet(), Gv = function() {
  var f;
  const {
    pageIdx: n,
    matchIdx: i
  } = this._selected;
  let l = 0, d = this._matchesCountTotal;
  if (i !== -1) {
    for (let m = 0; m < n; m++)
      l += ((f = this._pageMatches[m]) == null ? void 0 : f.length) || 0;
    l += i + 1;
  }
  return (l < 1 || l > d) && (l = d = 0), {
    current: l,
    total: d
  };
}, zd = new WeakSet(), Xv = function() {
  this._eventBus.dispatch("updatefindmatchescount", {
    source: this,
    matchesCount: E(this, Ud, Gv).call(this)
  });
}, ha = new WeakSet(), Td = function(n, i = !1) {
  var l;
  !r(this, ol) && (r(this, oa) !== this._linkService.pagesCount || n === yn.PENDING) || this._eventBus.dispatch("updatefindcontrolstate", {
    source: this,
    state: n,
    previous: i,
    matchesCount: E(this, Ud, Gv).call(this),
    rawQuery: ((l = r(this, ve)) == null ? void 0 : l.query) ?? null
  });
};
const GS = "noopener noreferrer nofollow", sa = {
  NONE: 0,
  SELF: 1,
  BLANK: 2,
  PARENT: 3,
  TOP: 4
};
var Sg, TE;
const xg = class xg {
  constructor({
    eventBus: n,
    externalLinkTarget: i = null,
    externalLinkRel: l = null,
    ignoreDestinationZoom: d = !1
  } = {}) {
    bt(this, "externalLinkEnabled", !0);
    this.eventBus = n, this.externalLinkTarget = i, this.externalLinkRel = l, this._ignoreDestinationZoom = d, this.baseUrl = null, this.pdfDocument = null, this.pdfViewer = null, this.pdfHistory = null;
  }
  setDocument(n, i = null) {
    this.baseUrl = i, this.pdfDocument = n;
  }
  setViewer(n) {
    this.pdfViewer = n;
  }
  setHistory(n) {
    this.pdfHistory = n;
  }
  get pagesCount() {
    return this.pdfDocument ? this.pdfDocument.numPages : 0;
  }
  get page() {
    return this.pdfDocument ? this.pdfViewer.currentPageNumber : 1;
  }
  set page(n) {
    this.pdfDocument && (this.pdfViewer.currentPageNumber = n);
  }
  get rotation() {
    return this.pdfDocument ? this.pdfViewer.pagesRotation : 0;
  }
  set rotation(n) {
    this.pdfDocument && (this.pdfViewer.pagesRotation = n);
  }
  get isInPresentationMode() {
    return this.pdfDocument ? this.pdfViewer.isInPresentationMode : !1;
  }
  async goToDestination(n) {
    if (!this.pdfDocument)
      return;
    let i, l, d;
    if (typeof n == "string" ? (i = n, l = await this.pdfDocument.getDestination(n)) : (i = null, l = await n), !Array.isArray(l)) {
      console.error(`goToDestination: "${l}" is not a valid destination array, for dest="${n}".`);
      return;
    }
    const [f] = l;
    if (f && typeof f == "object") {
      if (d = this.pdfDocument.cachedPageNumber(f), !d)
        try {
          d = await this.pdfDocument.getPageIndex(f) + 1;
        } catch {
          console.error(`goToDestination: "${f}" is not a valid page reference, for dest="${n}".`);
          return;
        }
    } else
      Number.isInteger(f) && (d = f + 1);
    if (!d || d < 1 || d > this.pagesCount) {
      console.error(`goToDestination: "${d}" is not a valid page number, for dest="${n}".`);
      return;
    }
    this.pdfHistory && (this.pdfHistory.pushCurrentPosition(), this.pdfHistory.push({
      namedDest: i,
      explicitDest: l,
      pageNumber: d
    })), this.pdfViewer.scrollPageIntoView({
      pageNumber: d,
      destArray: l,
      ignoreDestinationZoom: this._ignoreDestinationZoom
    });
  }
  goToPage(n) {
    if (!this.pdfDocument)
      return;
    const i = typeof n == "string" && this.pdfViewer.pageLabelToPageNumber(n) || n | 0;
    if (!(Number.isInteger(i) && i > 0 && i <= this.pagesCount)) {
      console.error(`PDFLinkService.goToPage: "${n}" is not a valid page.`);
      return;
    }
    this.pdfHistory && (this.pdfHistory.pushCurrentPosition(), this.pdfHistory.pushPage(i)), this.pdfViewer.scrollPageIntoView({
      pageNumber: i
    });
  }
  addLinkAttributes(n, i, l = !1) {
    if (!i || typeof i != "string")
      throw new Error('A valid "url" parameter must provided.');
    const d = l ? sa.BLANK : this.externalLinkTarget, f = this.externalLinkRel;
    this.externalLinkEnabled ? n.href = n.title = i : (n.href = "", n.title = `Disabled: ${i}`, n.onclick = () => !1);
    let m = "";
    switch (d) {
      case sa.NONE:
        break;
      case sa.SELF:
        m = "_self";
        break;
      case sa.BLANK:
        m = "_blank";
        break;
      case sa.PARENT:
        m = "_parent";
        break;
      case sa.TOP:
        m = "_top";
        break;
    }
    n.target = m, n.rel = typeof f == "string" ? f : GS;
  }
  getDestinationHash(n) {
    if (typeof n == "string") {
      if (n.length > 0)
        return this.getAnchorUrl("#" + escape(n));
    } else if (Array.isArray(n)) {
      const i = JSON.stringify(n);
      if (i.length > 0)
        return this.getAnchorUrl("#" + escape(i));
    }
    return this.getAnchorUrl("");
  }
  getAnchorUrl(n) {
    return this.baseUrl ? this.baseUrl + n : n;
  }
  setHash(n) {
    var d;
    if (!this.pdfDocument)
      return;
    let i, l;
    if (n.includes("=")) {
      const f = Jg(n);
      if (f.has("search")) {
        const m = f.get("search").replaceAll('"', ""), y = f.get("phrase") === "true";
        this.eventBus.dispatch("findfromurlhash", {
          source: this,
          query: y ? m : m.match(/\S+/g)
        });
      }
      if (f.has("page") && (i = f.get("page") | 0 || 1), f.has("zoom")) {
        const m = f.get("zoom").split(","), y = m[0], w = parseFloat(y);
        y.includes("Fit") ? y === "Fit" || y === "FitB" ? l = [null, {
          name: y
        }] : y === "FitH" || y === "FitBH" || y === "FitV" || y === "FitBV" ? l = [null, {
          name: y
        }, m.length > 1 ? m[1] | 0 : null] : y === "FitR" ? m.length !== 5 ? console.error('PDFLinkService.setHash: Not enough parameters for "FitR".') : l = [null, {
          name: y
        }, m[1] | 0, m[2] | 0, m[3] | 0, m[4] | 0] : console.error(`PDFLinkService.setHash: "${y}" is not a valid zoom value.`) : l = [null, {
          name: "XYZ"
        }, m.length > 1 ? m[1] | 0 : null, m.length > 2 ? m[2] | 0 : null, w ? w / 100 : y];
      }
      l ? this.pdfViewer.scrollPageIntoView({
        pageNumber: i || this.page,
        destArray: l,
        allowNegativeOffset: !0
      }) : i && (this.page = i), f.has("pagemode") && this.eventBus.dispatch("pagemode", {
        source: this,
        mode: f.get("pagemode")
      }), f.has("nameddest") && this.goToDestination(f.get("nameddest"));
      return;
    }
    l = unescape(n);
    try {
      l = JSON.parse(l), Array.isArray(l) || (l = l.toString());
    } catch {
    }
    if (typeof l == "string" || E(d = xg, Sg, TE).call(d, l)) {
      this.goToDestination(l);
      return;
    }
    console.error(`PDFLinkService.setHash: "${unescape(n)}" is not a valid destination.`);
  }
  executeNamedAction(n) {
    var i, l;
    if (this.pdfDocument) {
      switch (n) {
        case "GoBack":
          (i = this.pdfHistory) == null || i.back();
          break;
        case "GoForward":
          (l = this.pdfHistory) == null || l.forward();
          break;
        case "NextPage":
          this.pdfViewer.nextPage();
          break;
        case "PrevPage":
          this.pdfViewer.previousPage();
          break;
        case "LastPage":
          this.page = this.pagesCount;
          break;
        case "FirstPage":
          this.page = 1;
          break;
      }
      this.eventBus.dispatch("namedaction", {
        source: this,
        action: n
      });
    }
  }
  async executeSetOCGState(n) {
    if (!this.pdfDocument)
      return;
    const i = this.pdfDocument, l = await this.pdfViewer.optionalContentConfigPromise;
    i === this.pdfDocument && (l.setOCGState(n), this.pdfViewer.optionalContentConfigPromise = Promise.resolve(l));
  }
};
Sg = new WeakSet(), TE = function(n) {
  if (!Array.isArray(n) || n.length < 2)
    return !1;
  const [i, l, ...d] = n;
  if (!(typeof i == "object" && Number.isInteger(i == null ? void 0 : i.num) && Number.isInteger(i == null ? void 0 : i.gen)) && !Number.isInteger(i) || !(typeof l == "object" && typeof (l == null ? void 0 : l.name) == "string"))
    return !1;
  let f = !0;
  switch (l.name) {
    case "XYZ":
      if (d.length !== 3)
        return !1;
      break;
    case "Fit":
    case "FitB":
      return d.length === 0;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (d.length !== 1)
        return !1;
      break;
    case "FitR":
      if (d.length !== 4)
        return !1;
      f = !1;
      break;
    default:
      return !1;
  }
  for (const m of d)
    if (!(typeof m == "number" || f && m === null))
      return !1;
  return !0;
}, v(xg, Sg);
let dg = xg;
class yb extends dg {
  setDocument(n, i = null) {
  }
}
const {
  AbortException: XS,
  AnnotationEditorLayer: KS,
  AnnotationEditorParamsType: HP,
  AnnotationEditorType: wn,
  AnnotationEditorUIManager: YS,
  AnnotationLayer: QS,
  AnnotationMode: Bi,
  build: VP,
  CMapCompressionType: $P,
  ColorPicker: UP,
  createValidAbsoluteUrl: ZS,
  DOMSVGFactory: zP,
  DrawLayer: JS,
  FeatureTest: WP,
  fetchData: Py,
  getDocument: GP,
  getFilenameFromUrl: XP,
  getPdfFilenameFromUrl: qS,
  getXfaPageViewport: KP,
  GlobalWorkerOptions: YP,
  ImageKind: QP,
  InvalidPDFException: ZP,
  isDataScheme: JP,
  isPdfFile: tx,
  MissingPDFException: qP,
  noContextMenu: tT,
  normalizeUnicode: ex,
  OPS: eT,
  Outliner: sT,
  PasswordResponses: iT,
  PDFDataRangeTransport: nT,
  PDFDateString: rT,
  PDFWorker: aT,
  PermissionFlag: Cp,
  PixelsPerInch: _i,
  RenderingCancelledException: Kv,
  renderTextLayer: oT,
  setLayerDimensions: sx,
  shadow: ug,
  TextLayer: ix,
  UnexpectedResponseException: lT,
  updateTextLayer: hT,
  Util: cT,
  VerbosityLevel: dT,
  version: Ty,
  XfaLayer: Bm
} = globalThis.pdfjsLib;
var Wd, Pn, Gd, Yv;
class CE {
  constructor({
    pdfPage: n,
    linkService: i,
    downloadManager: l,
    annotationStorage: d = null,
    imageResourcesPath: f = "",
    renderForms: m = !0,
    enableScripting: y = !1,
    hasJSActionsPromise: w = null,
    fieldObjectsPromise: P = null,
    annotationCanvasMap: I = null,
    accessibilityManager: L = null,
    annotationEditorUIManager: _ = null,
    onAppend: D = null
  }) {
    v(this, Gd);
    v(this, Wd, null);
    v(this, Pn, null);
    this.pdfPage = n, this.linkService = i, this.downloadManager = l, this.imageResourcesPath = f, this.renderForms = m, this.annotationStorage = d, this.enableScripting = y, this._hasJSActionsPromise = w || Promise.resolve(!1), this._fieldObjectsPromise = P || Promise.resolve(null), this._annotationCanvasMap = I, this._accessibilityManager = L, this._annotationEditorUIManager = _, x(this, Wd, D), this.annotationLayer = null, this.div = null, this._cancelled = !1, this._eventBus = i.eventBus;
  }
  async render(n, i = "display") {
    var y, w;
    if (this.div) {
      if (this._cancelled || !this.annotationLayer)
        return;
      this.annotationLayer.update({
        viewport: n.clone({
          dontFlip: !0
        })
      });
      return;
    }
    const [l, d, f] = await Promise.all([this.pdfPage.getAnnotations({
      intent: i
    }), this._hasJSActionsPromise, this._fieldObjectsPromise]);
    if (this._cancelled)
      return;
    const m = this.div = document.createElement("div");
    if (m.className = "annotationLayer", (y = r(this, Wd)) == null || y.call(this, m), l.length === 0) {
      this.hide();
      return;
    }
    this.annotationLayer = new QS({
      div: m,
      accessibilityManager: this._accessibilityManager,
      annotationCanvasMap: this._annotationCanvasMap,
      annotationEditorUIManager: this._annotationEditorUIManager,
      page: this.pdfPage,
      viewport: n.clone({
        dontFlip: !0
      })
    }), await this.annotationLayer.render({
      annotations: l,
      imageResourcesPath: this.imageResourcesPath,
      renderForms: this.renderForms,
      linkService: this.linkService,
      downloadManager: this.downloadManager,
      annotationStorage: this.annotationStorage,
      enableScripting: this.enableScripting,
      hasJSActions: d,
      fieldObjects: f
    }), this.linkService.isInPresentationMode && E(this, Gd, Yv).call(this, rl.FULLSCREEN), r(this, Pn) || (x(this, Pn, new AbortController()), (w = this._eventBus) == null || w._on("presentationmodechanged", (P) => {
      E(this, Gd, Yv).call(this, P.state);
    }, {
      signal: r(this, Pn).signal
    }));
  }
  cancel() {
    var n;
    this._cancelled = !0, (n = r(this, Pn)) == null || n.abort(), x(this, Pn, null);
  }
  hide() {
    this.div && (this.div.hidden = !0);
  }
}
Wd = new WeakMap(), Pn = new WeakMap(), Gd = new WeakSet(), Yv = function(n) {
  if (!this.div)
    return;
  let i = !1;
  switch (n) {
    case rl.FULLSCREEN:
      i = !0;
      break;
    case rl.NORMAL:
      break;
    default:
      return;
  }
  for (const l of this.div.childNodes)
    l.hasAttribute("data-internal-link") || (l.inert = i);
};
function jm(u, n) {
  const i = document.createElement("a");
  if (!i.click)
    throw new Error('DownloadManager: "a.click()" is not supported.');
  i.href = u, i.target = "_parent", "download" in i && (i.download = n), (document.body || document.documentElement).append(i), i.click(), i.remove();
}
var bb;
class nx {
  constructor() {
    v(this, bb, /* @__PURE__ */ new WeakMap());
  }
  downloadUrl(n, i, l) {
    if (!ZS(n, "http://example.com")) {
      console.error(`downloadUrl - not a valid URL: ${n}`);
      return;
    }
    jm(n + "#pdfjs.action=download", i);
  }
  downloadData(n, i, l) {
    const d = URL.createObjectURL(new Blob([n], {
      type: l
    }));
    jm(d, i);
  }
  openOrDownloadData(n, i, l = null) {
    const f = tx(i) ? "application/pdf" : "";
    return this.downloadData(n, i, f), !1;
  }
  download(n, i, l, d) {
    const f = URL.createObjectURL(n);
    jm(f, l);
  }
}
bb = new WeakMap();
const Cy = {
  EVENT: "event",
  TIMEOUT: "timeout"
};
async function rx({
  target: u,
  name: n,
  delay: i = 0
}) {
  if (typeof u != "object" || !(n && typeof n == "string") || !(Number.isInteger(i) && i >= 0))
    throw new Error("waitOnEventOrTimeout - invalid parameters.");
  const {
    promise: l,
    resolve: d
  } = Promise.withResolvers(), f = new AbortController();
  function m(P) {
    f.abort(), clearTimeout(w), d(P);
  }
  const y = u instanceof RE ? "_on" : "addEventListener";
  u[y](n, m.bind(null, Cy.EVENT), {
    signal: f.signal
  });
  const w = setTimeout(m.bind(null, Cy.TIMEOUT), i);
  return l;
}
var cl;
class RE {
  constructor() {
    v(this, cl, /* @__PURE__ */ Object.create(null));
  }
  on(n, i, l = null) {
    this._on(n, i, {
      external: !0,
      once: l == null ? void 0 : l.once,
      signal: l == null ? void 0 : l.signal
    });
  }
  off(n, i, l = null) {
    this._off(n, i);
  }
  dispatch(n, i) {
    const l = r(this, cl)[n];
    if (!l || l.length === 0)
      return;
    let d;
    for (const {
      listener: f,
      external: m,
      once: y
    } of l.slice(0)) {
      if (y && this._off(n, f), m) {
        (d || (d = [])).push(f);
        continue;
      }
      f(i);
    }
    if (d) {
      for (const f of d)
        f(i);
      d = null;
    }
  }
  _on(n, i, l = null) {
    var m;
    let d = null;
    if ((l == null ? void 0 : l.signal) instanceof AbortSignal) {
      const {
        signal: y
      } = l;
      if (y.aborted) {
        console.error("Cannot use an `aborted` signal.");
        return;
      }
      const w = () => this._off(n, i);
      d = () => y.removeEventListener("abort", w), y.addEventListener("abort", w);
    }
    ((m = r(this, cl))[n] || (m[n] = [])).push({
      listener: i,
      external: (l == null ? void 0 : l.external) === !0,
      once: (l == null ? void 0 : l.once) === !0,
      rmAbort: d
    });
  }
  _off(n, i, l = null) {
    var f;
    const d = r(this, cl)[n];
    if (d)
      for (let m = 0, y = d.length; m < y; m++) {
        const w = d[m];
        if (w.listener === i) {
          (f = w.rmAbort) == null || f.call(w), d.splice(m, 1);
          return;
        }
      }
  }
}
cl = new WeakMap();
class qg {
  constructor(n) {
    this.value = n;
  }
  valueOf() {
    return this.value;
  }
}
class Jt extends qg {
  constructor(n = "???") {
    super(n);
  }
  toString(n) {
    return `{${this.value}}`;
  }
}
class ji extends qg {
  constructor(n, i = {}) {
    super(n), this.opts = i;
  }
  toString(n) {
    try {
      return n.memoizeIntlObject(Intl.NumberFormat, this.opts).format(this.value);
    } catch (i) {
      return n.reportError(i), this.value.toString(10);
    }
  }
}
class kd extends qg {
  constructor(n, i = {}) {
    super(n), this.opts = i;
  }
  toString(n) {
    try {
      return n.memoizeIntlObject(Intl.DateTimeFormat, this.opts).format(this.value);
    } catch (i) {
      return n.reportError(i), new Date(this.value).toISOString();
    }
  }
}
const Ry = 100, ax = "⁨", ox = "⁩";
function lx(u, n, i) {
  if (i === n || i instanceof ji && n instanceof ji && i.value === n.value)
    return !0;
  if (n instanceof ji && typeof i == "string") {
    let l = u.memoizeIntlObject(Intl.PluralRules, n.opts).select(n.value);
    if (i === l)
      return !0;
  }
  return !1;
}
function Iy(u, n, i) {
  return n[i] ? Tl(u, n[i].value) : (u.reportError(new RangeError("No default")), new Jt());
}
function Qv(u, n) {
  const i = [], l = /* @__PURE__ */ Object.create(null);
  for (const d of n)
    d.type === "narg" ? l[d.name] = Nd(u, d.value) : i.push(Nd(u, d));
  return {
    positional: i,
    named: l
  };
}
function Nd(u, n) {
  switch (n.type) {
    case "str":
      return n.value;
    case "num":
      return new ji(n.value, {
        minimumFractionDigits: n.precision
      });
    case "var":
      return hx(u, n);
    case "mesg":
      return cx(u, n);
    case "term":
      return dx(u, n);
    case "func":
      return ux(u, n);
    case "select":
      return fx(u, n);
    default:
      return new Jt();
  }
}
function hx(u, {
  name: n
}) {
  let i;
  if (u.params)
    if (Object.prototype.hasOwnProperty.call(u.params, n))
      i = u.params[n];
    else
      return new Jt(`$${n}`);
  else if (u.args && Object.prototype.hasOwnProperty.call(u.args, n))
    i = u.args[n];
  else
    return u.reportError(new ReferenceError(`Unknown variable: $${n}`)), new Jt(`$${n}`);
  if (i instanceof qg)
    return i;
  switch (typeof i) {
    case "string":
      return i;
    case "number":
      return new ji(i);
    case "object":
      if (i instanceof Date)
        return new kd(i.getTime());
    default:
      return u.reportError(new TypeError(`Variable type not supported: $${n}, ${typeof i}`)), new Jt(`$${n}`);
  }
}
function cx(u, {
  name: n,
  attr: i
}) {
  const l = u.bundle._messages.get(n);
  if (!l)
    return u.reportError(new ReferenceError(`Unknown message: ${n}`)), new Jt(n);
  if (i) {
    const d = l.attributes[i];
    return d ? Tl(u, d) : (u.reportError(new ReferenceError(`Unknown attribute: ${i}`)), new Jt(`${n}.${i}`));
  }
  return l.value ? Tl(u, l.value) : (u.reportError(new ReferenceError(`No value: ${n}`)), new Jt(n));
}
function dx(u, {
  name: n,
  attr: i,
  args: l
}) {
  const d = `-${n}`, f = u.bundle._terms.get(d);
  if (!f)
    return u.reportError(new ReferenceError(`Unknown term: ${d}`)), new Jt(d);
  if (i) {
    const y = f.attributes[i];
    if (y) {
      u.params = Qv(u, l).named;
      const w = Tl(u, y);
      return u.params = null, w;
    }
    return u.reportError(new ReferenceError(`Unknown attribute: ${i}`)), new Jt(`${d}.${i}`);
  }
  u.params = Qv(u, l).named;
  const m = Tl(u, f.value);
  return u.params = null, m;
}
function ux(u, {
  name: n,
  args: i
}) {
  let l = u.bundle._functions[n];
  if (!l)
    return u.reportError(new ReferenceError(`Unknown function: ${n}()`)), new Jt(`${n}()`);
  if (typeof l != "function")
    return u.reportError(new TypeError(`Function ${n}() is not callable`)), new Jt(`${n}()`);
  try {
    let d = Qv(u, i);
    return l(d.positional, d.named);
  } catch (d) {
    return u.reportError(d), new Jt(`${n}()`);
  }
}
function fx(u, {
  selector: n,
  variants: i,
  star: l
}) {
  let d = Nd(u, n);
  if (d instanceof Jt)
    return Iy(u, i, l);
  for (const f of i) {
    const m = Nd(u, f.key);
    if (lx(u, d, m))
      return Tl(u, f.value);
  }
  return Iy(u, i, l);
}
function IE(u, n) {
  if (u.dirty.has(n))
    return u.reportError(new RangeError("Cyclic reference")), new Jt();
  u.dirty.add(n);
  const i = [], l = u.bundle._useIsolating && n.length > 1;
  for (const d of n) {
    if (typeof d == "string") {
      i.push(u.bundle._transform(d));
      continue;
    }
    if (u.placeables++, u.placeables > Ry)
      throw u.dirty.delete(n), new RangeError(`Too many placeables expanded: ${u.placeables}, max allowed is ${Ry}`);
    l && i.push(ax), i.push(Nd(u, d).toString(u)), l && i.push(ox);
  }
  return u.dirty.delete(n), i.join("");
}
function Tl(u, n) {
  return typeof n == "string" ? u.bundle._transform(n) : IE(u, n);
}
class px {
  constructor(n, i, l) {
    this.dirty = /* @__PURE__ */ new WeakSet(), this.params = null, this.placeables = 0, this.bundle = n, this.errors = i, this.args = l;
  }
  reportError(n) {
    if (!this.errors || !(n instanceof Error))
      throw n;
    this.errors.push(n);
  }
  memoizeIntlObject(n, i) {
    let l = this.bundle._intls.get(n);
    l || (l = {}, this.bundle._intls.set(n, l));
    let d = JSON.stringify(i);
    return l[d] || (l[d] = new n(this.bundle.locales, i)), l[d];
  }
}
function fg(u, n) {
  const i = /* @__PURE__ */ Object.create(null);
  for (const [l, d] of Object.entries(u))
    n.includes(l) && (i[l] = d.valueOf());
  return i;
}
const Ly = ["unitDisplay", "currencyDisplay", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits"];
function gx(u, n) {
  let i = u[0];
  if (i instanceof Jt)
    return new Jt(`NUMBER(${i.valueOf()})`);
  if (i instanceof ji)
    return new ji(i.valueOf(), {
      ...i.opts,
      ...fg(n, Ly)
    });
  if (i instanceof kd)
    return new ji(i.valueOf(), {
      ...fg(n, Ly)
    });
  throw new TypeError("Invalid argument to NUMBER");
}
const _y = ["dateStyle", "timeStyle", "fractionalSecondDigits", "dayPeriod", "hour12", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName"];
function mx(u, n) {
  let i = u[0];
  if (i instanceof Jt)
    return new Jt(`DATETIME(${i.valueOf()})`);
  if (i instanceof kd)
    return new kd(i.valueOf(), {
      ...i.opts,
      ...fg(n, _y)
    });
  if (i instanceof ji)
    return new kd(i.valueOf(), {
      ...fg(n, _y)
    });
  throw new TypeError("Invalid argument to DATETIME");
}
const My = /* @__PURE__ */ new Map();
function vx(u) {
  const n = Array.isArray(u) ? u.join(" ") : u;
  let i = My.get(n);
  return i === void 0 && (i = /* @__PURE__ */ new Map(), My.set(n, i)), i;
}
class bx {
  constructor(n, {
    functions: i,
    useIsolating: l = !0,
    transform: d = (f) => f
  } = {}) {
    this._terms = /* @__PURE__ */ new Map(), this._messages = /* @__PURE__ */ new Map(), this.locales = Array.isArray(n) ? n : [n], this._functions = {
      NUMBER: gx,
      DATETIME: mx,
      ...i
    }, this._useIsolating = l, this._transform = d, this._intls = vx(n);
  }
  hasMessage(n) {
    return this._messages.has(n);
  }
  getMessage(n) {
    return this._messages.get(n);
  }
  addResource(n, {
    allowOverrides: i = !1
  } = {}) {
    const l = [];
    for (let d = 0; d < n.body.length; d++) {
      let f = n.body[d];
      if (f.id.startsWith("-")) {
        if (i === !1 && this._terms.has(f.id)) {
          l.push(new Error(`Attempt to override an existing term: "${f.id}"`));
          continue;
        }
        this._terms.set(f.id, f);
      } else {
        if (i === !1 && this._messages.has(f.id)) {
          l.push(new Error(`Attempt to override an existing message: "${f.id}"`));
          continue;
        }
        this._messages.set(f.id, f);
      }
    }
    return l;
  }
  formatPattern(n, i = null, l = null) {
    if (typeof n == "string")
      return this._transform(n);
    let d = new px(this, l, i);
    try {
      return IE(d, n).toString(d);
    } catch (f) {
      if (d.errors && f instanceof Error)
        return d.errors.push(f), new Jt().toString(d);
      throw f;
    }
  }
}
const Hm = /^(-?[a-zA-Z][\w-]*) *= */gm, Oy = /\.([a-zA-Z][\w-]*) *= */y, yx = /\*?\[/y, Vm = /(-?[0-9]+(?:\.([0-9]+))?)/y, Ax = /([a-zA-Z][\w-]*)/y, ky = /([$-])?([a-zA-Z][\w-]*)(?:\.([a-zA-Z][\w-]*))?/y, Ex = /^[A-Z][A-Z0-9_-]*$/, Rp = /([^{}\n\r]+)/y, wx = /([^\\"\n\r]*)/y, Dy = /\\([\\"])/y, Ny = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{6})/y, Sx = /^\n+/, Fy = / +$/, xx = / *\r?\n/g, Px = /( *)$/, Tx = /{\s*/y, By = /\s*}/y, Cx = /\[\s*/y, Rx = /\s*] */y, Ix = /\s*\(\s*/y, Lx = /\s*->\s*/y, _x = /\s*:\s*/y, Mx = /\s*,?\s*/y, Ox = /\s+/y;
class kx {
  constructor(n) {
    this.body = [], Hm.lastIndex = 0;
    let i = 0;
    for (; ; ) {
      let B = Hm.exec(n);
      if (B === null)
        break;
      i = Hm.lastIndex;
      try {
        this.body.push(w(B[1]));
      } catch (G) {
        if (G instanceof SyntaxError)
          continue;
        throw G;
      }
    }
    function l(B) {
      return B.lastIndex = i, B.test(n);
    }
    function d(B, G) {
      if (n[i] === B)
        return i++, !0;
      if (G)
        throw new G(`Expected ${B}`);
      return !1;
    }
    function f(B, G) {
      if (l(B))
        return i = B.lastIndex, !0;
      if (G)
        throw new G(`Expected ${B.toString()}`);
      return !1;
    }
    function m(B) {
      B.lastIndex = i;
      let G = B.exec(n);
      if (G === null)
        throw new SyntaxError(`Expected ${B.toString()}`);
      return i = B.lastIndex, G;
    }
    function y(B) {
      return m(B)[1];
    }
    function w(B) {
      let G = I(), q = P();
      if (G === null && Object.keys(q).length === 0)
        throw new SyntaxError("Expected message value or attributes");
      return {
        id: B,
        value: G,
        attributes: q
      };
    }
    function P() {
      let B = /* @__PURE__ */ Object.create(null);
      for (; l(Oy); ) {
        let G = y(Oy), q = I();
        if (q === null)
          throw new SyntaxError("Expected attribute value");
        B[G] = q;
      }
      return B;
    }
    function I() {
      let B;
      if (l(Rp) && (B = y(Rp)), n[i] === "{" || n[i] === "}")
        return L(B ? [B] : [], 1 / 0);
      let G = $();
      return G ? B ? L([B, G], G.length) : (G.value = j(G.value, Sx), L([G], G.length)) : B ? j(B, Fy) : null;
    }
    function L(B = [], G) {
      for (; ; ) {
        if (l(Rp)) {
          B.push(y(Rp));
          continue;
        }
        if (n[i] === "{") {
          B.push(_());
          continue;
        }
        if (n[i] === "}")
          throw new SyntaxError("Unbalanced closing brace");
        let vt = $();
        if (vt) {
          B.push(vt), G = Math.min(G, vt.length);
          continue;
        }
        break;
      }
      let q = B.length - 1, tt = B[q];
      typeof tt == "string" && (B[q] = j(tt, Fy));
      let lt = [];
      for (let vt of B)
        vt instanceof jy && (vt = vt.value.slice(0, vt.value.length - G)), vt && lt.push(vt);
      return lt;
    }
    function _() {
      f(Tx, SyntaxError);
      let B = D();
      if (f(By))
        return B;
      if (f(Lx)) {
        let G = X();
        return f(By, SyntaxError), {
          type: "select",
          selector: B,
          ...G
        };
      }
      throw new SyntaxError("Unclosed placeable");
    }
    function D() {
      if (n[i] === "{")
        return _();
      if (l(ky)) {
        let [, B, G, q = null] = m(ky);
        if (B === "$")
          return {
            type: "var",
            name: G
          };
        if (f(Ix)) {
          let tt = k();
          if (B === "-")
            return {
              type: "term",
              name: G,
              attr: q,
              args: tt
            };
          if (Ex.test(G))
            return {
              type: "func",
              name: G,
              args: tt
            };
          throw new SyntaxError("Function names must be all upper-case");
        }
        return B === "-" ? {
          type: "term",
          name: G,
          attr: q,
          args: []
        } : {
          type: "mesg",
          name: G,
          attr: q
        };
      }
      return z();
    }
    function k() {
      let B = [];
      for (; ; ) {
        switch (n[i]) {
          case ")":
            return i++, B;
          case void 0:
            throw new SyntaxError("Unclosed argument list");
        }
        B.push(H()), f(Mx);
      }
    }
    function H() {
      let B = D();
      return B.type !== "mesg" ? B : f(_x) ? {
        type: "narg",
        name: B.name,
        value: z()
      } : B;
    }
    function X() {
      let B = [], G = 0, q;
      for (; l(yx); ) {
        d("*") && (q = G);
        let tt = N(), lt = I();
        if (lt === null)
          throw new SyntaxError("Expected variant value");
        B[G++] = {
          key: tt,
          value: lt
        };
      }
      if (G === 0)
        return null;
      if (q === void 0)
        throw new SyntaxError("Expected default variant");
      return {
        variants: B,
        star: q
      };
    }
    function N() {
      f(Cx, SyntaxError);
      let B;
      return l(Vm) ? B = V() : B = {
        type: "str",
        value: y(Ax)
      }, f(Rx, SyntaxError), B;
    }
    function z() {
      if (l(Vm))
        return V();
      if (n[i] === '"')
        return Z();
      throw new SyntaxError("Invalid expression");
    }
    function V() {
      let [, B, G = ""] = m(Vm), q = G.length;
      return {
        type: "num",
        value: parseFloat(B),
        precision: q
      };
    }
    function Z() {
      d('"', SyntaxError);
      let B = "";
      for (; ; ) {
        if (B += y(wx), n[i] === "\\") {
          B += K();
          continue;
        }
        if (d('"'))
          return {
            type: "str",
            value: B
          };
        throw new SyntaxError("Unclosed string literal");
      }
    }
    function K() {
      if (l(Dy))
        return y(Dy);
      if (l(Ny)) {
        let [, B, G] = m(Ny), q = parseInt(B || G, 16);
        return q <= 55295 || 57344 <= q ? String.fromCodePoint(q) : "�";
      }
      throw new SyntaxError("Unknown escape sequence");
    }
    function $() {
      let B = i;
      switch (f(Ox), n[i]) {
        case ".":
        case "[":
        case "*":
        case "}":
        case void 0:
          return !1;
        case "{":
          return Q(n.slice(B, i));
      }
      return n[i - 1] === " " ? Q(n.slice(B, i)) : !1;
    }
    function j(B, G) {
      return B.replace(G, "");
    }
    function Q(B) {
      let G = B.replace(xx, `
`), q = Px.exec(B)[1].length;
      return new jy(G, q);
    }
  }
}
class jy {
  constructor(n, i) {
    this.value = n, this.length = i;
  }
}
const Dx = /<|&#?\w+;/, Nx = {
  "http://www.w3.org/1999/xhtml": ["em", "strong", "small", "s", "cite", "q", "dfn", "abbr", "data", "time", "code", "var", "samp", "kbd", "sub", "sup", "i", "b", "u", "mark", "bdi", "bdo", "span", "br", "wbr"]
}, Fx = {
  "http://www.w3.org/1999/xhtml": {
    global: ["title", "aria-label", "aria-valuetext"],
    a: ["download"],
    area: ["download", "alt"],
    input: ["alt", "placeholder"],
    menuitem: ["label"],
    menu: ["label"],
    optgroup: ["label"],
    option: ["label"],
    track: ["label"],
    img: ["alt"],
    textarea: ["placeholder"],
    th: ["abbr"]
  },
  "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul": {
    global: ["accesskey", "aria-label", "aria-valuetext", "label", "title", "tooltiptext"],
    description: ["value"],
    key: ["key", "keycode"],
    label: ["value"],
    textbox: ["placeholder", "value"]
  }
};
function Bx(u, n) {
  const {
    value: i
  } = n;
  if (typeof i == "string")
    if (u.localName === "title" && u.namespaceURI === "http://www.w3.org/1999/xhtml")
      u.textContent = i;
    else if (!Dx.test(i))
      u.textContent = i;
    else {
      const l = u.ownerDocument.createElementNS("http://www.w3.org/1999/xhtml", "template");
      l.innerHTML = i, jx(l.content, u);
    }
  LE(n, u);
}
function jx(u, n) {
  for (const i of u.childNodes)
    if (i.nodeType !== i.TEXT_NODE) {
      if (i.hasAttribute("data-l10n-name")) {
        const l = Vx(n, i);
        u.replaceChild(l, i);
        continue;
      }
      if (Ux(i)) {
        const l = $x(i);
        u.replaceChild(l, i);
        continue;
      }
      console.warn(`An element of forbidden type "${i.localName}" was found in the translation. Only safe text-level elements and elements with data-l10n-name are allowed.`), u.replaceChild(Zv(i), i);
    }
  n.textContent = "", n.appendChild(u);
}
function Hx(u, n) {
  if (!u)
    return !1;
  for (let i of u)
    if (i.name === n)
      return !0;
  return !1;
}
function LE(u, n) {
  const i = n.hasAttribute("data-l10n-attrs") ? n.getAttribute("data-l10n-attrs").split(",").map((l) => l.trim()) : null;
  for (const l of Array.from(n.attributes))
    Hy(l.name, n, i) && !Hx(u.attributes, l.name) && n.removeAttribute(l.name);
  if (u.attributes)
    for (const l of Array.from(u.attributes))
      Hy(l.name, n, i) && n.getAttribute(l.name) !== l.value && n.setAttribute(l.name, l.value);
}
function Vx(u, n) {
  const i = n.getAttribute("data-l10n-name"), l = u.querySelector(`[data-l10n-name="${i}"]`);
  if (!l)
    return console.warn(`An element named "${i}" wasn't found in the source.`), Zv(n);
  if (l.localName !== n.localName)
    return console.warn(`An element named "${i}" was found in the translation but its type ${n.localName} didn't match the element found in the source (${l.localName}).`), Zv(n);
  u.removeChild(l);
  const d = l.cloneNode(!1);
  return _E(n, d);
}
function $x(u) {
  const n = u.ownerDocument.createElement(u.localName);
  return _E(u, n);
}
function Zv(u) {
  return u.ownerDocument.createTextNode(u.textContent);
}
function Ux(u) {
  const n = Nx[u.namespaceURI];
  return n && n.includes(u.localName);
}
function Hy(u, n, i = null) {
  if (i && i.includes(u))
    return !0;
  const l = Fx[n.namespaceURI];
  if (!l)
    return !1;
  const d = u.toLowerCase(), f = n.localName;
  if (l.global.includes(d))
    return !0;
  if (!l[f])
    return !1;
  if (l[f].includes(d))
    return !0;
  if (n.namespaceURI === "http://www.w3.org/1999/xhtml" && f === "input" && d === "value") {
    const m = n.type.toLowerCase();
    if (m === "submit" || m === "button" || m === "reset")
      return !0;
  }
  return !1;
}
function _E(u, n) {
  return n.textContent = u.textContent, LE(u, n), n;
}
class zx extends Array {
  static from(n) {
    return n instanceof this ? n : new this(n);
  }
}
class Wx extends zx {
  constructor(n) {
    if (super(), Symbol.asyncIterator in Object(n))
      this.iterator = n[Symbol.asyncIterator]();
    else if (Symbol.iterator in Object(n))
      this.iterator = n[Symbol.iterator]();
    else
      throw new TypeError("Argument must implement the iteration protocol.");
  }
  [Symbol.asyncIterator]() {
    const n = this;
    let i = 0;
    return {
      async next() {
        return n.length <= i && n.push(n.iterator.next()), n[i++];
      }
    };
  }
  async touchNext(n = 1) {
    let i = 0;
    for (; i++ < n; ) {
      const l = this[this.length - 1];
      if (l && (await l).done)
        break;
      this.push(this.iterator.next());
    }
    return this[this.length - 1];
  }
}
class Gx {
  constructor(n = [], i) {
    this.resourceIds = n, this.generateBundles = i, this.onChange(!0);
  }
  addResourceIds(n, i = !1) {
    return this.resourceIds.push(...n), this.onChange(i), this.resourceIds.length;
  }
  removeResourceIds(n) {
    return this.resourceIds = this.resourceIds.filter((i) => !n.includes(i)), this.onChange(), this.resourceIds.length;
  }
  async formatWithFallback(n, i) {
    const l = [];
    let d = !1;
    for await (const f of this.bundles) {
      d = !0;
      const m = Yx(i, f, n, l);
      if (m.size === 0)
        break;
      if (typeof console < "u") {
        const y = f.locales[0], w = Array.from(m).join(", ");
        console.warn(`[fluent] Missing translations in ${y}: ${w}`);
      }
    }
    return !d && typeof console < "u" && console.warn(`[fluent] Request for keys failed because no resource bundles got generated.
  keys: ${JSON.stringify(n)}.
  resourceIds: ${JSON.stringify(this.resourceIds)}.`), l;
  }
  formatMessages(n) {
    return this.formatWithFallback(n, Kx);
  }
  formatValues(n) {
    return this.formatWithFallback(n, Xx);
  }
  async formatValue(n, i) {
    const [l] = await this.formatValues([{
      id: n,
      args: i
    }]);
    return l;
  }
  handleEvent() {
    this.onChange();
  }
  onChange(n = !1) {
    this.bundles = Wx.from(this.generateBundles(this.resourceIds)), n && this.bundles.touchNext(2);
  }
}
function Xx(u, n, i, l) {
  return i.value ? u.formatPattern(i.value, l, n) : null;
}
function Kx(u, n, i, l) {
  const d = {
    value: null,
    attributes: null
  };
  i.value && (d.value = u.formatPattern(i.value, l, n));
  let f = Object.keys(i.attributes);
  if (f.length > 0) {
    d.attributes = new Array(f.length);
    for (let [m, y] of f.entries()) {
      let w = u.formatPattern(i.attributes[y], l, n);
      d.attributes[m] = {
        name: y,
        value: w
      };
    }
  }
  return d;
}
function Yx(u, n, i, l) {
  const d = [], f = /* @__PURE__ */ new Set();
  return i.forEach(({
    id: m,
    args: y
  }, w) => {
    if (l[w] !== void 0)
      return;
    let P = n.getMessage(m);
    if (P) {
      if (d.length = 0, l[w] = u(n, d, P, y), d.length > 0 && typeof console < "u") {
        const I = n.locales[0], L = d.join(", ");
        console.warn(`[fluent][resolver] errors in ${I}/${m}: ${L}.`);
      }
    } else
      f.add(m);
  }), f;
}
const ia = "data-l10n-id", hd = "data-l10n-args", Qx = `[${ia}]`;
class Zx extends Gx {
  constructor(n, i) {
    super(n, i), this.roots = /* @__PURE__ */ new Set(), this.pendingrAF = null, this.pendingElements = /* @__PURE__ */ new Set(), this.windowElement = null, this.mutationObserver = null, this.observerConfig = {
      attributes: !0,
      characterData: !1,
      childList: !0,
      subtree: !0,
      attributeFilter: [ia, hd]
    };
  }
  onChange(n = !1) {
    super.onChange(n), this.roots && this.translateRoots();
  }
  setAttributes(n, i, l) {
    return n.setAttribute(ia, i), l ? n.setAttribute(hd, JSON.stringify(l)) : n.removeAttribute(hd), n;
  }
  getAttributes(n) {
    return {
      id: n.getAttribute(ia),
      args: JSON.parse(n.getAttribute(hd) || null)
    };
  }
  connectRoot(n) {
    for (const i of this.roots)
      if (i === n || i.contains(n) || n.contains(i))
        throw new Error("Cannot add a root that overlaps with existing root.");
    if (this.windowElement) {
      if (this.windowElement !== n.ownerDocument.defaultView)
        throw new Error(`Cannot connect a root:
          DOMLocalization already has a root from a different window.`);
    } else
      this.windowElement = n.ownerDocument.defaultView, this.mutationObserver = new this.windowElement.MutationObserver((i) => this.translateMutations(i));
    this.roots.add(n), this.mutationObserver.observe(n, this.observerConfig);
  }
  disconnectRoot(n) {
    return this.roots.delete(n), this.pauseObserving(), this.roots.size === 0 ? (this.mutationObserver = null, this.windowElement = null, this.pendingrAF = null, this.pendingElements.clear(), !0) : (this.resumeObserving(), !1);
  }
  translateRoots() {
    const n = Array.from(this.roots);
    return Promise.all(n.map((i) => this.translateFragment(i)));
  }
  pauseObserving() {
    this.mutationObserver && (this.translateMutations(this.mutationObserver.takeRecords()), this.mutationObserver.disconnect());
  }
  resumeObserving() {
    if (this.mutationObserver)
      for (const n of this.roots)
        this.mutationObserver.observe(n, this.observerConfig);
  }
  translateMutations(n) {
    for (const i of n)
      switch (i.type) {
        case "attributes":
          i.target.hasAttribute("data-l10n-id") && this.pendingElements.add(i.target);
          break;
        case "childList":
          for (const l of i.addedNodes)
            if (l.nodeType === l.ELEMENT_NODE)
              if (l.childElementCount)
                for (const d of this.getTranslatables(l))
                  this.pendingElements.add(d);
              else
                l.hasAttribute(ia) && this.pendingElements.add(l);
          break;
      }
    this.pendingElements.size > 0 && this.pendingrAF === null && (this.pendingrAF = this.windowElement.requestAnimationFrame(() => {
      this.translateElements(Array.from(this.pendingElements)), this.pendingElements.clear(), this.pendingrAF = null;
    }));
  }
  translateFragment(n) {
    return this.translateElements(this.getTranslatables(n));
  }
  async translateElements(n) {
    if (!n.length)
      return;
    const i = n.map(this.getKeysForElement), l = await this.formatMessages(i);
    return this.applyTranslations(n, l);
  }
  applyTranslations(n, i) {
    this.pauseObserving();
    for (let l = 0; l < n.length; l++)
      i[l] !== void 0 && Bx(n[l], i[l]);
    this.resumeObserving();
  }
  getTranslatables(n) {
    const i = Array.from(n.querySelectorAll(Qx));
    return typeof n.hasAttribute == "function" && n.hasAttribute(ia) && i.push(n), i;
  }
  getKeysForElement(n) {
    return {
      id: n.getAttribute(ia),
      args: JSON.parse(n.getAttribute(hd) || null)
    };
  }
}
var Xd, dl, bs, Pg, ME, Tg, OE;
const il = class il {
  constructor({
    lang: n,
    isRTL: i
  }, l = null) {
    v(this, Xd, void 0);
    v(this, dl, void 0);
    v(this, bs, void 0);
    var d, f;
    x(this, dl, E(d = il, Pg, ME).call(d, n)), x(this, bs, l), x(this, Xd, i ?? E(f = il, Tg, OE).call(f, r(this, dl)) ? "rtl" : "ltr");
  }
  _setL10n(n) {
    x(this, bs, n);
  }
  getLanguage() {
    return r(this, dl);
  }
  getDirection() {
    return r(this, Xd);
  }
  async get(n, i = null, l) {
    if (Array.isArray(n))
      return n = n.map((m) => ({
        id: m
      })), (await r(this, bs).formatMessages(n)).map((m) => m.value);
    const d = await r(this, bs).formatMessages([{
      id: n,
      args: i
    }]);
    return (d == null ? void 0 : d[0].value) || l;
  }
  async translate(n) {
    try {
      r(this, bs).connectRoot(n), await r(this, bs).translateRoots();
    } catch {
    }
  }
  pause() {
    r(this, bs).pauseObserving();
  }
  resume() {
    r(this, bs).resumeObserving();
  }
};
Xd = new WeakMap(), dl = new WeakMap(), bs = new WeakMap(), Pg = new WeakSet(), ME = function(n) {
  return n = (n == null ? void 0 : n.toLowerCase()) || "en-us", {
    en: "en-us",
    es: "es-es",
    fy: "fy-nl",
    ga: "ga-ie",
    gu: "gu-in",
    hi: "hi-in",
    hy: "hy-am",
    nb: "nb-no",
    ne: "ne-np",
    nn: "nn-no",
    pa: "pa-in",
    pt: "pt-pt",
    sv: "sv-se",
    zh: "zh-cn"
  }[n] || n;
}, Tg = new WeakSet(), OE = function(n) {
  const i = n.split("-", 1)[0];
  return ["ar", "he", "fa", "ps", "ur"].includes(i);
}, v(il, Pg), v(il, Tg);
let Jv = il;
function Vy(u, n) {
  const i = new kx(n), l = new bx(u), d = l.addResource(i);
  return d.length && console.error("L10n errors", d), l;
}
var Cg, kE, Rg, DE, Ig, NE, Lg, FE, Kd, qv;
const vs = class vs extends Jv {
  constructor(n) {
    super({
      lang: n
    });
    const i = n ? E(vs, Cg, kE).bind(vs, "en-us", this.getLanguage()) : E(vs, Lg, FE).bind(vs, this.getLanguage());
    this._setL10n(new Zx([], i));
  }
};
Cg = new WeakSet(), kE = async function* (n, i) {
  const {
    baseURL: l,
    paths: d
  } = await E(this, Ig, NE).call(this), f = [i];
  if (n !== i) {
    const m = i.split("-", 1)[0];
    m !== i && f.push(m), f.push(n);
  }
  for (const m of f) {
    const y = await E(this, Rg, DE).call(this, m, l, d);
    y && (yield y), m === "en-us" && (yield E(this, Kd, qv).call(this, m));
  }
}, Rg = new WeakSet(), DE = async function(n, i, l) {
  const d = l[n];
  if (!d)
    return null;
  const f = new URL(d, i), m = await Py(f, "text");
  return Vy(n, m);
}, Ig = new WeakSet(), NE = async function() {
  try {
    const {
      href: n
    } = document.querySelector('link[type="application/l10n"]'), i = await Py(n, "json");
    return {
      baseURL: n.replace(/[^/]*$/, "") || "./",
      paths: i
    };
  } catch {
  }
  return {
    baseURL: "./",
    paths: /* @__PURE__ */ Object.create(null)
  };
}, Lg = new WeakSet(), FE = async function* (n) {
  yield E(this, Kd, qv).call(this, n);
}, Kd = new WeakSet(), qv = async function(n) {
  return Vy(n, `pdfjs-previous-button =
    .title = Previous Page
pdfjs-previous-button-label = Previous
pdfjs-next-button =
    .title = Next Page
pdfjs-next-button-label = Next
pdfjs-page-input =
    .title = Page
pdfjs-of-pages = of { $pagesCount }
pdfjs-page-of-pages = ({ $pageNumber } of { $pagesCount })
pdfjs-zoom-out-button =
    .title = Zoom Out
pdfjs-zoom-out-button-label = Zoom Out
pdfjs-zoom-in-button =
    .title = Zoom In
pdfjs-zoom-in-button-label = Zoom In
pdfjs-zoom-select =
    .title = Zoom
pdfjs-presentation-mode-button =
    .title = Switch to Presentation Mode
pdfjs-presentation-mode-button-label = Presentation Mode
pdfjs-open-file-button =
    .title = Open File
pdfjs-open-file-button-label = Open
pdfjs-print-button =
    .title = Print
pdfjs-print-button-label = Print
pdfjs-save-button =
    .title = Save
pdfjs-save-button-label = Save
pdfjs-download-button =
    .title = Download
pdfjs-download-button-label = Download
pdfjs-bookmark-button =
    .title = Current Page (View URL from Current Page)
pdfjs-bookmark-button-label = Current Page
pdfjs-tools-button =
    .title = Tools
pdfjs-tools-button-label = Tools
pdfjs-first-page-button =
    .title = Go to First Page
pdfjs-first-page-button-label = Go to First Page
pdfjs-last-page-button =
    .title = Go to Last Page
pdfjs-last-page-button-label = Go to Last Page
pdfjs-page-rotate-cw-button =
    .title = Rotate Clockwise
pdfjs-page-rotate-cw-button-label = Rotate Clockwise
pdfjs-page-rotate-ccw-button =
    .title = Rotate Counterclockwise
pdfjs-page-rotate-ccw-button-label = Rotate Counterclockwise
pdfjs-cursor-text-select-tool-button =
    .title = Enable Text Selection Tool
pdfjs-cursor-text-select-tool-button-label = Text Selection Tool
pdfjs-cursor-hand-tool-button =
    .title = Enable Hand Tool
pdfjs-cursor-hand-tool-button-label = Hand Tool
pdfjs-scroll-page-button =
    .title = Use Page Scrolling
pdfjs-scroll-page-button-label = Page Scrolling
pdfjs-scroll-vertical-button =
    .title = Use Vertical Scrolling
pdfjs-scroll-vertical-button-label = Vertical Scrolling
pdfjs-scroll-horizontal-button =
    .title = Use Horizontal Scrolling
pdfjs-scroll-horizontal-button-label = Horizontal Scrolling
pdfjs-scroll-wrapped-button =
    .title = Use Wrapped Scrolling
pdfjs-scroll-wrapped-button-label = Wrapped Scrolling
pdfjs-spread-none-button =
    .title = Do not join page spreads
pdfjs-spread-none-button-label = No Spreads
pdfjs-spread-odd-button =
    .title = Join page spreads starting with odd-numbered pages
pdfjs-spread-odd-button-label = Odd Spreads
pdfjs-spread-even-button =
    .title = Join page spreads starting with even-numbered pages
pdfjs-spread-even-button-label = Even Spreads
pdfjs-document-properties-button =
    .title = Document Properties…
pdfjs-document-properties-button-label = Document Properties…
pdfjs-document-properties-file-name = File name:
pdfjs-document-properties-file-size = File size:
pdfjs-document-properties-kb = { $size_kb } KB ({ $size_b } bytes)
pdfjs-document-properties-mb = { $size_mb } MB ({ $size_b } bytes)
pdfjs-document-properties-title = Title:
pdfjs-document-properties-author = Author:
pdfjs-document-properties-subject = Subject:
pdfjs-document-properties-keywords = Keywords:
pdfjs-document-properties-creation-date = Creation Date:
pdfjs-document-properties-modification-date = Modification Date:
pdfjs-document-properties-date-string = { $date }, { $time }
pdfjs-document-properties-creator = Creator:
pdfjs-document-properties-producer = PDF Producer:
pdfjs-document-properties-version = PDF Version:
pdfjs-document-properties-page-count = Page Count:
pdfjs-document-properties-page-size = Page Size:
pdfjs-document-properties-page-size-unit-inches = in
pdfjs-document-properties-page-size-unit-millimeters = mm
pdfjs-document-properties-page-size-orientation-portrait = portrait
pdfjs-document-properties-page-size-orientation-landscape = landscape
pdfjs-document-properties-page-size-name-a-three = A3
pdfjs-document-properties-page-size-name-a-four = A4
pdfjs-document-properties-page-size-name-letter = Letter
pdfjs-document-properties-page-size-name-legal = Legal
pdfjs-document-properties-page-size-dimension-string = { $width } × { $height } { $unit } ({ $orientation })
pdfjs-document-properties-page-size-dimension-name-string = { $width } × { $height } { $unit } ({ $name }, { $orientation })
pdfjs-document-properties-linearized = Fast Web View:
pdfjs-document-properties-linearized-yes = Yes
pdfjs-document-properties-linearized-no = No
pdfjs-document-properties-close-button = Close
pdfjs-print-progress-message = Preparing document for printing…
pdfjs-print-progress-percent = { $progress }%
pdfjs-print-progress-close-button = Cancel
pdfjs-printing-not-supported = Warning: Printing is not fully supported by this browser.
pdfjs-printing-not-ready = Warning: The PDF is not fully loaded for printing.
pdfjs-toggle-sidebar-button =
    .title = Toggle Sidebar
pdfjs-toggle-sidebar-notification-button =
    .title = Toggle Sidebar (document contains outline/attachments/layers)
pdfjs-toggle-sidebar-button-label = Toggle Sidebar
pdfjs-document-outline-button =
    .title = Show Document Outline (double-click to expand/collapse all items)
pdfjs-document-outline-button-label = Document Outline
pdfjs-attachments-button =
    .title = Show Attachments
pdfjs-attachments-button-label = Attachments
pdfjs-layers-button =
    .title = Show Layers (double-click to reset all layers to the default state)
pdfjs-layers-button-label = Layers
pdfjs-thumbs-button =
    .title = Show Thumbnails
pdfjs-thumbs-button-label = Thumbnails
pdfjs-current-outline-item-button =
    .title = Find Current Outline Item
pdfjs-current-outline-item-button-label = Current Outline Item
pdfjs-findbar-button =
    .title = Find in Document
pdfjs-findbar-button-label = Find
pdfjs-additional-layers = Additional Layers
pdfjs-thumb-page-title =
    .title = Page { $page }
pdfjs-thumb-page-canvas =
    .aria-label = Thumbnail of Page { $page }
pdfjs-find-input =
    .title = Find
    .placeholder = Find in document…
pdfjs-find-previous-button =
    .title = Find the previous occurrence of the phrase
pdfjs-find-previous-button-label = Previous
pdfjs-find-next-button =
    .title = Find the next occurrence of the phrase
pdfjs-find-next-button-label = Next
pdfjs-find-highlight-checkbox = Highlight All
pdfjs-find-match-case-checkbox-label = Match Case
pdfjs-find-match-diacritics-checkbox-label = Match Diacritics
pdfjs-find-entire-word-checkbox-label = Whole Words
pdfjs-find-reached-top = Reached top of document, continued from bottom
pdfjs-find-reached-bottom = Reached end of document, continued from top
pdfjs-find-match-count =
    { $total ->
        [one] { $current } of { $total } match
       *[other] { $current } of { $total } matches
    }
pdfjs-find-match-count-limit =
    { $limit ->
        [one] More than { $limit } match
       *[other] More than { $limit } matches
    }
pdfjs-find-not-found = Phrase not found
pdfjs-page-scale-width = Page Width
pdfjs-page-scale-fit = Page Fit
pdfjs-page-scale-auto = Automatic Zoom
pdfjs-page-scale-actual = Actual Size
pdfjs-page-scale-percent = { $scale }%
pdfjs-page-landmark =
    .aria-label = Page { $page }
pdfjs-loading-error = An error occurred while loading the PDF.
pdfjs-invalid-file-error = Invalid or corrupted PDF file.
pdfjs-missing-file-error = Missing PDF file.
pdfjs-unexpected-response-error = Unexpected server response.
pdfjs-rendering-error = An error occurred while rendering the page.
pdfjs-annotation-date-string = { $date }, { $time }
pdfjs-text-annotation-type =
    .alt = [{ $type } Annotation]
pdfjs-password-label = Enter the password to open this PDF file.
pdfjs-password-invalid = Invalid password. Please try again.
pdfjs-password-ok-button = OK
pdfjs-password-cancel-button = Cancel
pdfjs-web-fonts-disabled = Web fonts are disabled: unable to use embedded PDF fonts.
pdfjs-editor-free-text-button =
    .title = Text
pdfjs-editor-free-text-button-label = Text
pdfjs-editor-ink-button =
    .title = Draw
pdfjs-editor-ink-button-label = Draw
pdfjs-editor-stamp-button =
    .title = Add or edit images
pdfjs-editor-stamp-button-label = Add or edit images
pdfjs-editor-highlight-button =
    .title = Highlight
pdfjs-editor-highlight-button-label = Highlight
pdfjs-highlight-floating-button1 =
    .title = Highlight
    .aria-label = Highlight
pdfjs-highlight-floating-button-label = Highlight
pdfjs-editor-remove-ink-button =
    .title = Remove drawing
pdfjs-editor-remove-freetext-button =
    .title = Remove text
pdfjs-editor-remove-stamp-button =
    .title = Remove image
pdfjs-editor-remove-highlight-button =
    .title = Remove highlight
pdfjs-editor-free-text-color-input = Color
pdfjs-editor-free-text-size-input = Size
pdfjs-editor-ink-color-input = Color
pdfjs-editor-ink-thickness-input = Thickness
pdfjs-editor-ink-opacity-input = Opacity
pdfjs-editor-stamp-add-image-button =
    .title = Add image
pdfjs-editor-stamp-add-image-button-label = Add image
pdfjs-editor-free-highlight-thickness-input = Thickness
pdfjs-editor-free-highlight-thickness-title =
    .title = Change thickness when highlighting items other than text
pdfjs-free-text =
    .aria-label = Text Editor
pdfjs-free-text-default-content = Start typing…
pdfjs-ink =
    .aria-label = Draw Editor
pdfjs-ink-canvas =
    .aria-label = User-created image
pdfjs-editor-alt-text-button-label = Alt text
pdfjs-editor-alt-text-edit-button-label = Edit alt text
pdfjs-editor-alt-text-dialog-label = Choose an option
pdfjs-editor-alt-text-dialog-description = Alt text (alternative text) helps when people can’t see the image or when it doesn’t load.
pdfjs-editor-alt-text-add-description-label = Add a description
pdfjs-editor-alt-text-add-description-description = Aim for 1-2 sentences that describe the subject, setting, or actions.
pdfjs-editor-alt-text-mark-decorative-label = Mark as decorative
pdfjs-editor-alt-text-mark-decorative-description = This is used for ornamental images, like borders or watermarks.
pdfjs-editor-alt-text-cancel-button = Cancel
pdfjs-editor-alt-text-save-button = Save
pdfjs-editor-alt-text-decorative-tooltip = Marked as decorative
pdfjs-editor-alt-text-textarea =
    .placeholder = For example, “A young man sits down at a table to eat a meal”
pdfjs-editor-resizer-label-top-left = Top left corner — resize
pdfjs-editor-resizer-label-top-middle = Top middle — resize
pdfjs-editor-resizer-label-top-right = Top right corner — resize
pdfjs-editor-resizer-label-middle-right = Middle right — resize
pdfjs-editor-resizer-label-bottom-right = Bottom right corner — resize
pdfjs-editor-resizer-label-bottom-middle = Bottom middle — resize
pdfjs-editor-resizer-label-bottom-left = Bottom left corner — resize
pdfjs-editor-resizer-label-middle-left = Middle left — resize
pdfjs-editor-highlight-colorpicker-label = Highlight color
pdfjs-editor-colorpicker-button =
    .title = Change color
pdfjs-editor-colorpicker-dropdown =
    .aria-label = Color choices
pdfjs-editor-colorpicker-yellow =
    .title = Yellow
pdfjs-editor-colorpicker-green =
    .title = Green
pdfjs-editor-colorpicker-blue =
    .title = Blue
pdfjs-editor-colorpicker-pink =
    .title = Pink
pdfjs-editor-colorpicker-red =
    .title = Red
pdfjs-editor-highlight-show-all-button-label = Show all
pdfjs-editor-highlight-show-all-button =
    .title = Show all`);
}, v(vs, Cg), v(vs, Rg), v(vs, Ig), v(vs, Lg), v(vs, Kd);
let Cl = vs;
const Jx = 1e3, qx = 50, tP = 1e3;
function $m() {
  return document.location.hash;
}
var Tn, ys, Ii, ul, sg, fl, ig, ca, Cd, pl, ng, Yd, tb, _g, BE, Mg, jE, Qd, eb, Og, HE, kg, VE;
class eP {
  constructor({
    linkService: n,
    eventBus: i
  }) {
    v(this, ys);
    v(this, ul);
    v(this, fl);
    v(this, ca);
    v(this, pl);
    v(this, Yd);
    v(this, _g);
    v(this, Mg);
    v(this, Qd);
    v(this, Og);
    v(this, kg);
    v(this, Tn, null);
    this.linkService = n, this.eventBus = i, this._initialized = !1, this._fingerprint = "", this.reset(), this.eventBus._on("pagesinit", () => {
      this._isPagesLoaded = !1, this.eventBus._on("pagesloaded", (l) => {
        this._isPagesLoaded = !!l.pagesCount;
      }, {
        once: !0
      });
    });
  }
  initialize({
    fingerprint: n,
    resetHistory: i = !1,
    updateUrl: l = !1
  }) {
    if (!n || typeof n != "string") {
      console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
      return;
    }
    this._initialized && this.reset();
    const d = this._fingerprint !== "" && this._fingerprint !== n;
    this._fingerprint = n, this._updateUrl = l === !0, this._initialized = !0, E(this, Og, HE).call(this);
    const f = window.history.state;
    if (this._popStateInProgress = !1, this._blockHashChange = 0, this._currentHash = $m(), this._numPositionUpdates = 0, this._uid = this._maxUid = 0, this._destination = null, this._position = null, !E(this, ca, Cd).call(this, f, !0) || i) {
      const {
        hash: y,
        page: w,
        rotation: P
      } = E(this, Yd, tb).call(this, !0);
      if (!y || d || i) {
        E(this, ys, Ii).call(this, null, !0);
        return;
      }
      E(this, ys, Ii).call(this, {
        hash: y,
        page: w,
        rotation: P
      }, !0);
      return;
    }
    const m = f.destination;
    E(this, pl, ng).call(this, m, f.uid, !0), m.rotation !== void 0 && (this._initialRotation = m.rotation), m.dest ? (this._initialBookmark = JSON.stringify(m.dest), this._destination.page = null) : m.hash ? this._initialBookmark = m.hash : m.page && (this._initialBookmark = `page=${m.page}`);
  }
  reset() {
    this._initialized && (E(this, Qd, eb).call(this), this._initialized = !1, E(this, kg, VE).call(this)), this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), this._initialBookmark = null, this._initialRotation = null;
  }
  push({
    namedDest: n = null,
    explicitDest: i,
    pageNumber: l
  }) {
    if (!this._initialized)
      return;
    if (n && typeof n != "string") {
      console.error(`PDFHistory.push: "${n}" is not a valid namedDest parameter.`);
      return;
    } else if (Array.isArray(i)) {
      if (!E(this, fl, ig).call(this, l) && (l !== null || this._destination)) {
        console.error(`PDFHistory.push: "${l}" is not a valid pageNumber parameter.`);
        return;
      }
    } else {
      console.error(`PDFHistory.push: "${i}" is not a valid explicitDest parameter.`);
      return;
    }
    const d = n || JSON.stringify(i);
    if (!d)
      return;
    let f = !1;
    if (this._destination && (sP(this._destination.hash, d) || iP(this._destination.dest, i))) {
      if (this._destination.page)
        return;
      f = !0;
    }
    this._popStateInProgress && !f || (E(this, ys, Ii).call(this, {
      dest: i,
      hash: d,
      page: l,
      rotation: this.linkService.rotation
    }, f), this._popStateInProgress || (this._popStateInProgress = !0, Promise.resolve().then(() => {
      this._popStateInProgress = !1;
    })));
  }
  pushPage(n) {
    var i;
    if (this._initialized) {
      if (!E(this, fl, ig).call(this, n)) {
        console.error(`PDFHistory.pushPage: "${n}" is not a valid page number.`);
        return;
      }
      ((i = this._destination) == null ? void 0 : i.page) !== n && (this._popStateInProgress || (E(this, ys, Ii).call(this, {
        dest: null,
        hash: `page=${n}`,
        page: n,
        rotation: this.linkService.rotation
      }), this._popStateInProgress || (this._popStateInProgress = !0, Promise.resolve().then(() => {
        this._popStateInProgress = !1;
      }))));
    }
  }
  pushCurrentPosition() {
    !this._initialized || this._popStateInProgress || E(this, ul, sg).call(this);
  }
  back() {
    if (!this._initialized || this._popStateInProgress)
      return;
    const n = window.history.state;
    E(this, ca, Cd).call(this, n) && n.uid > 0 && window.history.back();
  }
  forward() {
    if (!this._initialized || this._popStateInProgress)
      return;
    const n = window.history.state;
    E(this, ca, Cd).call(this, n) && n.uid < this._maxUid && window.history.forward();
  }
  get popStateInProgress() {
    return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);
  }
  get initialBookmark() {
    return this._initialized ? this._initialBookmark : null;
  }
  get initialRotation() {
    return this._initialized ? this._initialRotation : null;
  }
}
Tn = new WeakMap(), ys = new WeakSet(), Ii = function(n, i = !1) {
  const l = i || !this._destination, d = {
    fingerprint: this._fingerprint,
    uid: l ? this._uid : this._uid + 1,
    destination: n
  };
  E(this, pl, ng).call(this, n, d.uid);
  let f;
  if (this._updateUrl && (n != null && n.hash)) {
    const m = document.location.href.split("#", 1)[0];
    m.startsWith("file://") || (f = `${m}#${n.hash}`);
  }
  l ? window.history.replaceState(d, "", f) : window.history.pushState(d, "", f);
}, ul = new WeakSet(), sg = function(n = !1) {
  if (!this._position)
    return;
  let i = this._position;
  if (n && (i = Object.assign(/* @__PURE__ */ Object.create(null), this._position), i.temporary = !0), !this._destination) {
    E(this, ys, Ii).call(this, i);
    return;
  }
  if (this._destination.temporary) {
    E(this, ys, Ii).call(this, i, !0);
    return;
  }
  if (this._destination.hash === i.hash || !this._destination.page && this._numPositionUpdates <= qx)
    return;
  let l = !1;
  if (this._destination.page >= i.first && this._destination.page <= i.page) {
    if (this._destination.dest !== void 0 || !this._destination.first)
      return;
    l = !0;
  }
  E(this, ys, Ii).call(this, i, l);
}, fl = new WeakSet(), ig = function(n) {
  return Number.isInteger(n) && n > 0 && n <= this.linkService.pagesCount;
}, ca = new WeakSet(), Cd = function(n, i = !1) {
  if (!n)
    return !1;
  if (n.fingerprint !== this._fingerprint)
    if (i) {
      if (typeof n.fingerprint != "string" || n.fingerprint.length !== this._fingerprint.length)
        return !1;
      const [l] = performance.getEntriesByType("navigation");
      if ((l == null ? void 0 : l.type) !== "reload")
        return !1;
    } else
      return !1;
  return !(!Number.isInteger(n.uid) || n.uid < 0 || n.destination === null || typeof n.destination != "object");
}, pl = new WeakSet(), ng = function(n, i, l = !1) {
  this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), l && (n != null && n.temporary) && delete n.temporary, this._destination = n, this._uid = i, this._maxUid = Math.max(this._maxUid, i), this._numPositionUpdates = 0;
}, Yd = new WeakSet(), tb = function(n = !1) {
  const i = unescape($m()).substring(1), l = Jg(i), d = l.get("nameddest") || "";
  let f = l.get("page") | 0;
  return (!E(this, fl, ig).call(this, f) || n && d.length > 0) && (f = null), {
    hash: i,
    page: f,
    rotation: this.linkService.rotation
  };
}, _g = new WeakSet(), BE = function({
  location: n
}) {
  this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), this._position = {
    hash: n.pdfOpenParams.substring(1),
    page: this.linkService.page,
    first: n.pageNumber,
    rotation: n.rotation
  }, !this._popStateInProgress && (this._isPagesLoaded && this._destination && !this._destination.page && this._numPositionUpdates++, this._updateViewareaTimeout = setTimeout(() => {
    this._popStateInProgress || E(this, ul, sg).call(this, !0), this._updateViewareaTimeout = null;
  }, tP));
}, Mg = new WeakSet(), jE = function({
  state: n
}) {
  const i = $m(), l = this._currentHash !== i;
  if (this._currentHash = i, !n) {
    this._uid++;
    const {
      hash: f,
      page: m,
      rotation: y
    } = E(this, Yd, tb).call(this);
    E(this, ys, Ii).call(this, {
      hash: f,
      page: m,
      rotation: y
    }, !0);
    return;
  }
  if (!E(this, ca, Cd).call(this, n))
    return;
  this._popStateInProgress = !0, l && (this._blockHashChange++, rx({
    target: window,
    name: "hashchange",
    delay: Jx
  }).then(() => {
    this._blockHashChange--;
  }));
  const d = n.destination;
  E(this, pl, ng).call(this, d, n.uid, !0), vE(d.rotation) && (this.linkService.rotation = d.rotation), d.dest ? this.linkService.goToDestination(d.dest) : d.hash ? this.linkService.setHash(d.hash) : d.page && (this.linkService.page = d.page), Promise.resolve().then(() => {
    this._popStateInProgress = !1;
  });
}, Qd = new WeakSet(), eb = function() {
  (!this._destination || this._destination.temporary) && E(this, ul, sg).call(this);
}, Og = new WeakSet(), HE = function() {
  if (r(this, Tn))
    return;
  x(this, Tn, new AbortController());
  const {
    signal: n
  } = r(this, Tn);
  this.eventBus._on("updateviewarea", E(this, _g, BE).bind(this), {
    signal: n
  }), window.addEventListener("popstate", E(this, Mg, jE).bind(this), {
    signal: n
  }), window.addEventListener("pagehide", E(this, Qd, eb).bind(this), {
    signal: n
  });
}, kg = new WeakSet(), VE = function() {
  var n;
  (n = r(this, Tn)) == null || n.abort(), x(this, Tn, null);
};
function sP(u, n) {
  return typeof u != "string" || typeof n != "string" ? !1 : u === n || Jg(u).get("nameddest") === n;
}
function iP(u, n) {
  function i(l, d) {
    if (typeof l != typeof d || Array.isArray(l) || Array.isArray(d))
      return !1;
    if (l !== null && typeof l == "object" && d !== null) {
      if (Object.keys(l).length !== Object.keys(d).length)
        return !1;
      for (const f in l)
        if (!i(l[f], d[f]))
          return !1;
      return !0;
    }
    return l === d || Number.isNaN(l) && Number.isNaN(d);
  }
  if (!(Array.isArray(u) && Array.isArray(n)) || u.length !== n.length)
    return !1;
  for (let l = 0, d = u.length; l < d; l++)
    if (!i(u[l], n[l]))
      return !1;
  return !0;
}
var Zd, Jd, qd, tu, gl;
class nP {
  constructor(n) {
    v(this, Zd, null);
    v(this, Jd, null);
    v(this, qd, null);
    v(this, tu, null);
    v(this, gl, void 0);
    this.pdfPage = n.pdfPage, this.accessibilityManager = n.accessibilityManager, this.l10n = n.l10n, this.l10n || (this.l10n = new Cl()), this.annotationEditorLayer = null, this.div = null, this._cancelled = !1, x(this, gl, n.uiManager), x(this, Zd, n.annotationLayer || null), x(this, tu, n.textLayer || null), x(this, Jd, n.drawLayer || null), x(this, qd, n.onAppend || null);
  }
  async render(n, i = "display") {
    var m;
    if (i !== "display" || this._cancelled)
      return;
    const l = n.clone({
      dontFlip: !0
    });
    if (this.div) {
      this.annotationEditorLayer.update({
        viewport: l
      }), this.show();
      return;
    }
    const d = this.div = document.createElement("div");
    d.className = "annotationEditorLayer", d.hidden = !0, d.dir = r(this, gl).direction, (m = r(this, qd)) == null || m.call(this, d), this.annotationEditorLayer = new KS({
      uiManager: r(this, gl),
      div: d,
      accessibilityManager: this.accessibilityManager,
      pageIndex: this.pdfPage.pageNumber - 1,
      l10n: this.l10n,
      viewport: l,
      annotationLayer: r(this, Zd),
      textLayer: r(this, tu),
      drawLayer: r(this, Jd)
    });
    const f = {
      viewport: l,
      div: d,
      annotations: null,
      intent: i
    };
    this.annotationEditorLayer.render(f), this.show();
  }
  cancel() {
    this._cancelled = !0, this.div && this.annotationEditorLayer.destroy();
  }
  hide() {
    this.div && (this.div.hidden = !0);
  }
  show() {
    !this.div || this.annotationEditorLayer.isInvisible || (this.div.hidden = !1);
  }
}
Zd = new WeakMap(), Jd = new WeakMap(), qd = new WeakMap(), tu = new WeakMap(), gl = new WeakMap();
{
  var Fd = /* @__PURE__ */ Object.create(null);
  const u = navigator.userAgent || "", n = navigator.platform || "", i = navigator.maxTouchPoints || 1, l = /Android/.test(u), d = /\b(iPad|iPhone|iPod)(?=;)/.test(u) || n === "MacIntel" && i > 1;
  (function() {
    (d || l) && (Fd.maxCanvasPixels = 5242880);
  })();
}
const it = {
  BROWSER: 1,
  VIEWER: 2,
  API: 4,
  WORKER: 8,
  PREFERENCE: 128
}, Fn = {
  canvasMaxAreaInBytes: {
    value: -1,
    kind: it.BROWSER + it.API
  },
  isInAutomation: {
    value: !1,
    kind: it.BROWSER
  },
  supportsCaretBrowsingMode: {
    value: !1,
    kind: it.BROWSER
  },
  supportsDocumentFonts: {
    value: !0,
    kind: it.BROWSER
  },
  supportsIntegratedFind: {
    value: !1,
    kind: it.BROWSER
  },
  supportsMouseWheelZoomCtrlKey: {
    value: !0,
    kind: it.BROWSER
  },
  supportsMouseWheelZoomMetaKey: {
    value: !0,
    kind: it.BROWSER
  },
  supportsPinchToZoom: {
    value: !0,
    kind: it.BROWSER
  },
  annotationEditorMode: {
    value: 0,
    kind: it.VIEWER + it.PREFERENCE
  },
  annotationMode: {
    value: 2,
    kind: it.VIEWER + it.PREFERENCE
  },
  cursorToolOnLoad: {
    value: 0,
    kind: it.VIEWER + it.PREFERENCE
  },
  debuggerSrc: {
    value: "./debugger.mjs",
    kind: it.VIEWER
  },
  defaultZoomDelay: {
    value: 400,
    kind: it.VIEWER + it.PREFERENCE
  },
  defaultZoomValue: {
    value: "",
    kind: it.VIEWER + it.PREFERENCE
  },
  disableHistory: {
    value: !1,
    kind: it.VIEWER
  },
  disablePageLabels: {
    value: !1,
    kind: it.VIEWER + it.PREFERENCE
  },
  enableHighlightEditor: {
    value: !1,
    kind: it.VIEWER + it.PREFERENCE
  },
  enableHighlightFloatingButton: {
    value: !1,
    kind: it.VIEWER + it.PREFERENCE
  },
  enableML: {
    value: !1,
    kind: it.VIEWER + it.PREFERENCE
  },
  enablePermissions: {
    value: !1,
    kind: it.VIEWER + it.PREFERENCE
  },
  enablePrintAutoRotate: {
    value: !0,
    kind: it.VIEWER + it.PREFERENCE
  },
  enableScripting: {
    value: !0,
    kind: it.VIEWER + it.PREFERENCE
  },
  enableStampEditor: {
    value: !0,
    kind: it.VIEWER + it.PREFERENCE
  },
  externalLinkRel: {
    value: "noopener noreferrer nofollow",
    kind: it.VIEWER
  },
  externalLinkTarget: {
    value: 0,
    kind: it.VIEWER + it.PREFERENCE
  },
  highlightEditorColors: {
    value: "yellow=#FFFF98,green=#53FFBC,blue=#80EBFF,pink=#FFCBE6,red=#FF4F5F",
    kind: it.VIEWER + it.PREFERENCE
  },
  historyUpdateUrl: {
    value: !1,
    kind: it.VIEWER + it.PREFERENCE
  },
  ignoreDestinationZoom: {
    value: !1,
    kind: it.VIEWER + it.PREFERENCE
  },
  imageResourcesPath: {
    value: "./images/",
    kind: it.VIEWER
  },
  maxCanvasPixels: {
    value: 2 ** 25,
    kind: it.VIEWER
  },
  forcePageColors: {
    value: !1,
    kind: it.VIEWER + it.PREFERENCE
  },
  pageColorsBackground: {
    value: "Canvas",
    kind: it.VIEWER + it.PREFERENCE
  },
  pageColorsForeground: {
    value: "CanvasText",
    kind: it.VIEWER + it.PREFERENCE
  },
  pdfBugEnabled: {
    value: !1,
    kind: it.VIEWER + it.PREFERENCE
  },
  printResolution: {
    value: 150,
    kind: it.VIEWER
  },
  sidebarViewOnLoad: {
    value: -1,
    kind: it.VIEWER + it.PREFERENCE
  },
  scrollModeOnLoad: {
    value: -1,
    kind: it.VIEWER + it.PREFERENCE
  },
  spreadModeOnLoad: {
    value: -1,
    kind: it.VIEWER + it.PREFERENCE
  },
  textLayerMode: {
    value: 1,
    kind: it.VIEWER + it.PREFERENCE
  },
  viewOnLoad: {
    value: 0,
    kind: it.VIEWER + it.PREFERENCE
  },
  cMapPacked: {
    value: !0,
    kind: it.API
  },
  cMapUrl: {
    value: "../web/cmaps/",
    kind: it.API
  },
  disableAutoFetch: {
    value: !1,
    kind: it.API + it.PREFERENCE
  },
  disableFontFace: {
    value: !1,
    kind: it.API + it.PREFERENCE
  },
  disableRange: {
    value: !1,
    kind: it.API + it.PREFERENCE
  },
  disableStream: {
    value: !1,
    kind: it.API + it.PREFERENCE
  },
  docBaseUrl: {
    value: "",
    kind: it.API
  },
  enableXfa: {
    value: !0,
    kind: it.API + it.PREFERENCE
  },
  fontExtraProperties: {
    value: !1,
    kind: it.API
  },
  isEvalSupported: {
    value: !0,
    kind: it.API
  },
  isOffscreenCanvasSupported: {
    value: !0,
    kind: it.API
  },
  maxImageSize: {
    value: -1,
    kind: it.API
  },
  pdfBug: {
    value: !1,
    kind: it.API
  },
  standardFontDataUrl: {
    value: "../web/standard_fonts/",
    kind: it.API
  },
  verbosity: {
    value: 1,
    kind: it.API
  },
  workerPort: {
    value: null,
    kind: it.WORKER
  },
  workerSrc: {
    value: "../build/pdf.worker.mjs",
    kind: it.WORKER
  }
};
Fn.defaultUrl = {
  value: "compressed.tracemonkey-pldi-09.pdf",
  kind: it.VIEWER
}, Fn.sandboxBundleSrc = {
  value: "../build/pdf.sandbox.mjs",
  kind: it.VIEWER
}, Fn.viewerCssTheme = {
  value: 0,
  kind: it.VIEWER + it.PREFERENCE
};
Fn.disablePreferences = {
  value: !1,
  kind: it.VIEWER
}, Fn.locale = {
  value: navigator.language || "en-US",
  kind: it.VIEWER
};
const An = /* @__PURE__ */ Object.create(null);
for (const u in Fd)
  An[u] = Fd[u];
class rP {
  constructor() {
    throw new Error("Cannot initialize AppOptions.");
  }
  static get(n) {
    var i;
    return An[n] ?? ((i = Fn[n]) == null ? void 0 : i.value) ?? void 0;
  }
  static getAll(n = null, i = !1) {
    const l = /* @__PURE__ */ Object.create(null);
    for (const d in Fn) {
      const f = Fn[d];
      n && !(n & f.kind) || (l[d] = i ? f.value : An[d] ?? f.value);
    }
    return l;
  }
  static set(n, i) {
    An[n] = i;
  }
  static setAll(n, i = !1) {
    if (i) {
      if (this.get("disablePreferences"))
        return;
      for (const l in An)
        if (Fd[l] === void 0) {
          console.warn('setAll: The Preferences may override manually set AppOptions; please use the "disablePreferences"-option in order to prevent that.');
          break;
        }
    }
    for (const l in n)
      An[l] = n[l];
  }
  static remove(n) {
    delete An[n];
    const i = Fd[n];
    i !== void 0 && (An[n] = i);
  }
}
var Vs;
class aP {
  constructor(n) {
    v(this, Vs, null);
    this.pageIndex = n.pageIndex;
  }
  async render(n = "display") {
    n !== "display" || r(this, Vs) || this._cancelled || x(this, Vs, new JS({
      pageIndex: this.pageIndex
    }));
  }
  cancel() {
    this._cancelled = !0, r(this, Vs) && (r(this, Vs).destroy(), x(this, Vs, null));
  }
  setParent(n) {
    var i;
    (i = r(this, Vs)) == null || i.setParent(n);
  }
  getDrawLayer() {
    return r(this, Vs);
  }
}
Vs = new WeakMap();
const $y = {
  Document: null,
  DocumentFragment: null,
  Part: "group",
  Sect: "group",
  Div: "group",
  Aside: "note",
  NonStruct: "none",
  P: null,
  H: "heading",
  Title: null,
  FENote: "note",
  Sub: "group",
  Lbl: null,
  Span: null,
  Em: null,
  Strong: null,
  Link: "link",
  Annot: "note",
  Form: "form",
  Ruby: null,
  RB: null,
  RT: null,
  RP: null,
  Warichu: null,
  WT: null,
  WP: null,
  L: "list",
  LI: "listitem",
  LBody: null,
  Table: "table",
  TR: "row",
  TH: "columnheader",
  TD: "cell",
  THead: "columnheader",
  TBody: null,
  TFoot: null,
  Caption: null,
  Figure: "figure",
  Formula: null,
  Artifact: null
}, oP = /^H(\d+)$/;
var qe, eu, sb, su, ib;
class $E {
  constructor() {
    v(this, eu);
    v(this, su);
    v(this, qe, void 0);
  }
  get renderingDone() {
    return r(this, qe) !== void 0;
  }
  render(n) {
    if (r(this, qe) !== void 0)
      return r(this, qe);
    const i = E(this, su, ib).call(this, n);
    return i == null || i.classList.add("structTree"), x(this, qe, i);
  }
  hide() {
    r(this, qe) && !r(this, qe).hidden && (r(this, qe).hidden = !0);
  }
  show() {
    var n;
    (n = r(this, qe)) != null && n.hidden && (r(this, qe).hidden = !1);
  }
}
qe = new WeakMap(), eu = new WeakSet(), sb = function(n, i) {
  const {
    alt: l,
    id: d,
    lang: f
  } = n;
  l !== void 0 && i.setAttribute("aria-label", cg(l)), d !== void 0 && i.setAttribute("aria-owns", d), f !== void 0 && i.setAttribute("lang", cg(f, !0));
}, su = new WeakSet(), ib = function(n) {
  if (!n)
    return null;
  const i = document.createElement("span");
  if ("role" in n) {
    const {
      role: l
    } = n, d = l.match(oP);
    d ? (i.setAttribute("role", "heading"), i.setAttribute("aria-level", d[1])) : $y[l] && i.setAttribute("role", $y[l]);
  }
  if (E(this, eu, sb).call(this, n, i), n.children)
    if (n.children.length === 1 && "id" in n.children[0])
      E(this, eu, sb).call(this, n.children[0], i);
    else
      for (const l of n.children)
        i.append(E(this, su, ib).call(this, l));
  return i;
};
var Mi, ts, Oi, Cn, ml, rg, iu, rb;
const nl = class nl {
  constructor() {
    v(this, iu);
    v(this, Mi, !1);
    v(this, ts, null);
    v(this, Oi, /* @__PURE__ */ new Map());
    v(this, Cn, /* @__PURE__ */ new Map());
  }
  setTextMapping(n) {
    x(this, ts, n);
  }
  enable() {
    if (r(this, Mi))
      throw new Error("TextAccessibilityManager is already enabled.");
    if (!r(this, ts))
      throw new Error("Text divs and strings have not been set.");
    if (x(this, Mi, !0), x(this, ts, r(this, ts).slice()), r(this, ts).sort(E(nl, ml, rg)), r(this, Oi).size > 0) {
      const n = r(this, ts);
      for (const [i, l] of r(this, Oi)) {
        if (!document.getElementById(i)) {
          r(this, Oi).delete(i);
          continue;
        }
        E(this, iu, rb).call(this, i, n[l]);
      }
    }
    for (const [n, i] of r(this, Cn))
      this.addPointerInTextLayer(n, i);
    r(this, Cn).clear();
  }
  disable() {
    r(this, Mi) && (r(this, Cn).clear(), x(this, ts, null), x(this, Mi, !1));
  }
  removePointerInTextLayer(n) {
    if (!r(this, Mi)) {
      r(this, Cn).delete(n);
      return;
    }
    const i = r(this, ts);
    if (!i || i.length === 0)
      return;
    const {
      id: l
    } = n, d = r(this, Oi).get(l);
    if (d === void 0)
      return;
    const f = i[d];
    r(this, Oi).delete(l);
    let m = f.getAttribute("aria-owns");
    m != null && m.includes(l) && (m = m.split(" ").filter((y) => y !== l).join(" "), m ? f.setAttribute("aria-owns", m) : (f.removeAttribute("aria-owns"), f.setAttribute("role", "presentation")));
  }
  addPointerInTextLayer(n, i) {
    const {
      id: l
    } = n;
    if (!l)
      return null;
    if (!r(this, Mi))
      return r(this, Cn).set(n, i), null;
    i && this.removePointerInTextLayer(n);
    const d = r(this, ts);
    if (!d || d.length === 0)
      return null;
    const f = Dd(d, (P) => {
      var I;
      return E(I = nl, ml, rg).call(I, n, P) < 0;
    }), m = Math.max(0, f - 1), y = d[m];
    E(this, iu, rb).call(this, l, y), r(this, Oi).set(l, m);
    const w = y.parentNode;
    return w != null && w.classList.contains("markedContent") ? w.id : null;
  }
  moveElementInDOM(n, i, l, d) {
    const f = this.addPointerInTextLayer(l, d);
    if (!n.hasChildNodes())
      return n.append(i), f;
    const m = Array.from(n.childNodes).filter((P) => P !== i);
    if (m.length === 0)
      return f;
    const y = l || i, w = Dd(m, (P) => {
      var I;
      return E(I = nl, ml, rg).call(I, y, P) < 0;
    });
    return w === 0 ? m[0].before(i) : m[w - 1].after(i), f;
  }
};
Mi = new WeakMap(), ts = new WeakMap(), Oi = new WeakMap(), Cn = new WeakMap(), ml = new WeakSet(), rg = function(n, i) {
  const l = n.getBoundingClientRect(), d = i.getBoundingClientRect();
  if (l.width === 0 && l.height === 0)
    return 1;
  if (d.width === 0 && d.height === 0)
    return -1;
  const f = l.y, m = l.y + l.height, y = l.y + l.height / 2, w = d.y, P = d.y + d.height, I = d.y + d.height / 2;
  if (y <= w && I >= m)
    return -1;
  if (I <= f && y >= P)
    return 1;
  const L = l.x + l.width / 2, _ = d.x + d.width / 2;
  return L - _;
}, iu = new WeakSet(), rb = function(n, i) {
  const l = i.getAttribute("aria-owns");
  l != null && l.includes(n) || i.setAttribute("aria-owns", l ? `${l} ${n}` : n), i.removeAttribute("role");
}, v(nl, ml);
let nb = nl;
var Rn;
class lP {
  constructor({
    findController: n,
    eventBus: i,
    pageIndex: l
  }) {
    v(this, Rn, null);
    this.findController = n, this.matches = [], this.eventBus = i, this.pageIdx = l, this.textDivs = null, this.textContentItemsStr = null, this.enabled = !1;
  }
  setTextMapping(n, i) {
    this.textDivs = n, this.textContentItemsStr = i;
  }
  enable() {
    if (!this.textDivs || !this.textContentItemsStr)
      throw new Error("Text divs and strings have not been set.");
    if (this.enabled)
      throw new Error("TextHighlighter is already enabled.");
    this.enabled = !0, r(this, Rn) || (x(this, Rn, new AbortController()), this.eventBus._on("updatetextlayermatches", (n) => {
      (n.pageIndex === this.pageIdx || n.pageIndex === -1) && this._updateMatches();
    }, {
      signal: r(this, Rn).signal
    })), this._updateMatches();
  }
  disable() {
    var n;
    this.enabled && (this.enabled = !1, (n = r(this, Rn)) == null || n.abort(), x(this, Rn, null), this._updateMatches(!0));
  }
  _convertMatches(n, i) {
    if (!n)
      return [];
    const {
      textContentItemsStr: l
    } = this;
    let d = 0, f = 0;
    const m = l.length - 1, y = [];
    for (let w = 0, P = n.length; w < P; w++) {
      let I = n[w];
      for (; d !== m && I >= f + l[d].length; )
        f += l[d].length, d++;
      d === l.length && console.error("Could not find a matching mapping");
      const L = {
        begin: {
          divIdx: d,
          offset: I - f
        }
      };
      for (I += i[w]; d !== m && I > f + l[d].length; )
        f += l[d].length, d++;
      L.end = {
        divIdx: d,
        offset: I - f
      }, y.push(L);
    }
    return y;
  }
  _renderMatches(n) {
    if (n.length === 0)
      return;
    const {
      findController: i,
      pageIdx: l
    } = this, {
      textContentItemsStr: d,
      textDivs: f
    } = this, m = l === i.selected.pageIdx, y = i.selected.matchIdx, w = i.state.highlightAll;
    let P = null;
    const I = {
      divIdx: -1,
      offset: void 0
    };
    function L(N, z) {
      const V = N.divIdx;
      return f[V].textContent = "", _(V, 0, N.offset, z);
    }
    function _(N, z, V, Z) {
      let K = f[N];
      if (K.nodeType === Node.TEXT_NODE) {
        const Q = document.createElement("span");
        K.before(Q), Q.append(K), f[N] = Q, K = Q;
      }
      const $ = d[N].substring(z, V), j = document.createTextNode($);
      if (Z) {
        const Q = document.createElement("span");
        return Q.className = `${Z} appended`, Q.append(j), K.append(Q), Z.includes("selected") ? Q.offsetLeft : 0;
      }
      return K.append(j), 0;
    }
    let D = y, k = D + 1;
    if (w)
      D = 0, k = n.length;
    else if (!m)
      return;
    let H = -1, X = -1;
    for (let N = D; N < k; N++) {
      const z = n[N], V = z.begin;
      if (V.divIdx === H && V.offset === X)
        continue;
      H = V.divIdx, X = V.offset;
      const Z = z.end, K = m && N === y, $ = K ? " selected" : "";
      let j = 0;
      if (!P || V.divIdx !== P.divIdx ? (P !== null && _(P.divIdx, P.offset, I.offset), L(V)) : _(P.divIdx, P.offset, V.offset), V.divIdx === Z.divIdx)
        j = _(V.divIdx, V.offset, Z.offset, "highlight" + $);
      else {
        j = _(V.divIdx, V.offset, I.offset, "highlight begin" + $);
        for (let Q = V.divIdx + 1, B = Z.divIdx; Q < B; Q++)
          f[Q].className = "highlight middle" + $;
        L(Z, "highlight end" + $);
      }
      P = Z, K && i.scrollMatchIntoView({
        element: f[V.divIdx],
        selectedLeft: j,
        pageIndex: l,
        matchIndex: y
      });
    }
    P && _(P.divIdx, P.offset, I.offset);
  }
  _updateMatches(n = !1) {
    if (!this.enabled && !n)
      return;
    const {
      findController: i,
      matches: l,
      pageIdx: d
    } = this, {
      textContentItemsStr: f,
      textDivs: m
    } = this;
    let y = -1;
    for (const I of l) {
      const L = Math.max(y, I.begin.divIdx);
      for (let _ = L, D = I.end.divIdx; _ <= D; _++) {
        const k = m[_];
        k.textContent = f[_], k.className = "";
      }
      y = I.end.divIdx + 1;
    }
    if (!(i != null && i.highlightMatches) || n)
      return;
    const w = i.pageMatches[d] || null, P = i.pageMatchesLength[d] || null;
    this.matches = this._convertMatches(w, P), this._renderMatches(this.matches);
  }
}
Rn = new WeakMap();
var nu, ru, da, $s, es, In, Dg, UE, Ng, zE, Fg, WE, Bg, GE;
const Li = class Li {
  constructor({
    pdfPage: n,
    highlighter: i = null,
    accessibilityManager: l = null,
    enablePermissions: d = !1,
    onAppend: f = null
  }) {
    v(this, Dg);
    v(this, Ng);
    v(this, nu, !1);
    v(this, ru, null);
    v(this, da, !1);
    v(this, $s, null);
    this.pdfPage = n, this.highlighter = i, this.accessibilityManager = l, x(this, nu, d === !0), x(this, ru, f), this.div = document.createElement("div"), this.div.tabIndex = 0, this.div.className = "textLayer";
  }
  async render(n, i = null) {
    var f, m, y, w, P;
    if (r(this, da) && r(this, $s)) {
      r(this, $s).update({
        viewport: n,
        onBefore: this.hide.bind(this)
      }), this.show();
      return;
    }
    this.cancel(), x(this, $s, new ix({
      textContentSource: this.pdfPage.streamTextContent(i || {
        includeMarkedContent: !0,
        disableNormalization: !0
      }),
      container: this.div,
      viewport: n
    }));
    const {
      textDivs: l,
      textContentItemsStr: d
    } = r(this, $s);
    (f = this.highlighter) == null || f.setTextMapping(l, d), (m = this.accessibilityManager) == null || m.setTextMapping(l), await r(this, $s).render(), E(this, Dg, UE).call(this), (y = r(this, ru)) == null || y.call(this, this.div), (w = this.highlighter) == null || w.enable(), (P = this.accessibilityManager) == null || P.enable();
  }
  hide() {
    var n;
    !this.div.hidden && r(this, da) && ((n = this.highlighter) == null || n.disable(), this.div.hidden = !0);
  }
  show() {
    var n;
    this.div.hidden && r(this, da) && (this.div.hidden = !1, (n = this.highlighter) == null || n.enable());
  }
  cancel() {
    var n, i, l, d;
    (n = r(this, $s)) == null || n.cancel(), x(this, $s, null), (i = this.highlighter) == null || i.disable(), (l = this.accessibilityManager) == null || l.disable(), E(d = Li, Fg, WE).call(d, this.div);
  }
};
nu = new WeakMap(), ru = new WeakMap(), da = new WeakMap(), $s = new WeakMap(), es = new WeakMap(), In = new WeakMap(), Dg = new WeakSet(), UE = function() {
  x(this, da, !0);
  const n = document.createElement("div");
  n.className = "endOfContent", this.div.append(n), E(this, Ng, zE).call(this, n);
}, Ng = new WeakSet(), zE = function(n) {
  var l;
  const {
    div: i
  } = this;
  i.addEventListener("mousedown", (d) => {
    n.classList.add("active");
  }), i.addEventListener("copy", (d) => {
    if (!r(this, nu)) {
      const f = document.getSelection();
      d.clipboardData.setData("text/plain", cg(ex(f.toString())));
    }
    d.preventDefault(), d.stopPropagation();
  }), r(Li, es).set(i, n), E(l = Li, Bg, GE).call(l);
}, Fg = new WeakSet(), WE = function(n) {
  var i;
  r(this, es).delete(n), r(this, es).size === 0 && ((i = r(this, In)) == null || i.abort(), x(this, In, null));
}, Bg = new WeakSet(), GE = function() {
  if (r(this, In))
    return;
  x(this, In, new AbortController());
  const {
    signal: n
  } = r(this, In), i = (f, m) => {
    m.append(f), f.style.width = "", f.style.height = "", f.classList.remove("active");
  };
  document.addEventListener("pointerup", () => {
    r(this, es).forEach(i);
  }, {
    signal: n
  });
  var l, d;
  document.addEventListener("selectionchange", () => {
    const f = document.getSelection();
    if (f.rangeCount === 0) {
      r(this, es).forEach(i);
      return;
    }
    const m = /* @__PURE__ */ new Set();
    for (let _ = 0; _ < f.rangeCount; _++) {
      const D = f.getRangeAt(_);
      for (const k of r(this, es).keys())
        !m.has(k) && D.intersectsNode(k) && m.add(k);
    }
    for (const [_, D] of r(this, es))
      m.has(_) ? D.classList.add("active") : i(D, _);
    if (l ?? (l = getComputedStyle(r(this, es).values().next().value).getPropertyValue("-moz-user-select") === "none"), l)
      return;
    const y = f.getRangeAt(0), w = d && (y.compareBoundaryPoints(Range.END_TO_END, d) === 0 || y.compareBoundaryPoints(Range.START_TO_END, d) === 0);
    let P = w ? y.startContainer : y.endContainer;
    P.nodeType === Node.TEXT_NODE && (P = P.parentNode);
    const I = P.parentElement.closest(".textLayer"), L = r(this, es).get(I);
    L && (L.style.width = I.style.width, L.style.height = I.style.height, P.parentElement.insertBefore(L, w ? P : P.nextSibling)), d = y.cloneRange();
  }, {
    signal: n
  });
}, v(Li, Fg), v(Li, Bg), v(Li, es, /* @__PURE__ */ new Map()), v(Li, In, null);
let pg = Li;
class XE {
  constructor({
    pdfPage: n,
    annotationStorage: i = null,
    linkService: l,
    xfaHtml: d = null
  }) {
    this.pdfPage = n, this.annotationStorage = i, this.linkService = l, this.xfaHtml = d, this.div = null, this._cancelled = !1;
  }
  async render(n, i = "display") {
    if (i === "print") {
      const f = {
        viewport: n.clone({
          dontFlip: !0
        }),
        div: this.div,
        xfaHtml: this.xfaHtml,
        annotationStorage: this.annotationStorage,
        linkService: this.linkService,
        intent: i
      };
      return this.div = document.createElement("div"), f.div = this.div, Bm.render(f);
    }
    const l = await this.pdfPage.getXfa();
    if (this._cancelled || !l)
      return {
        textDivs: []
      };
    const d = {
      viewport: n.clone({
        dontFlip: !0
      }),
      div: this.div,
      xfaHtml: l,
      annotationStorage: this.annotationStorage,
      linkService: this.linkService,
      intent: i
    };
    return this.div ? Bm.update(d) : (this.div = document.createElement("div"), d.div = this.div, Bm.render(d));
  }
  cancel() {
    this._cancelled = !0;
  }
  hide() {
    this.div && (this.div.hidden = !0);
  }
}
const hP = {
  annotationEditorUIManager: null,
  annotationStorage: null,
  downloadManager: null,
  enableScripting: !1,
  fieldObjectsPromise: null,
  findController: null,
  hasJSActionsPromise: null,
  get linkService() {
    return new yb();
  }
}, cP = /* @__PURE__ */ new Map([["canvasWrapper", 0], ["textLayer", 1], ["annotationLayer", 2], ["annotationEditorLayer", 3], ["xfaLayer", 3]]);
var ua, fa, Ln, _n, au, pa, vl, bl, ki, ga, Mn, On, sl, yl, ag, ma, Rd, ou, ab, lu, ob, hu, lb, cu, hb, du, cb, jg, YE, Hg, QE, uu, db;
class KE {
  constructor(n) {
    v(this, On);
    v(this, yl);
    v(this, ma);
    v(this, ou);
    v(this, lu);
    v(this, hu);
    v(this, cu);
    v(this, du);
    v(this, jg);
    v(this, Hg);
    v(this, uu);
    v(this, ua, Bi.ENABLE_FORMS);
    v(this, fa, !1);
    v(this, Ln, null);
    v(this, _n, null);
    v(this, au, null);
    v(this, pa, null);
    v(this, vl, Kt.INITIAL);
    v(this, bl, Ws.ENABLE);
    v(this, ki, {
      directDrawing: !0,
      initialOptionalContent: !0,
      regularAnnotations: !0
    });
    v(this, ga, /* @__PURE__ */ new WeakMap());
    v(this, Mn, [null, null, null, null]);
    var f;
    const i = n.container, l = n.defaultViewport;
    this.id = n.id, this.renderingId = "page" + this.id, x(this, Ln, n.layerProperties || hP), this.pdfPage = null, this.pageLabel = null, this.rotation = 0, this.scale = n.scale || gE, this.viewport = l, this.pdfPageRotate = l.rotation, this._optionalContentConfigPromise = n.optionalContentConfigPromise || null, x(this, bl, n.textLayerMode ?? Ws.ENABLE), x(this, ua, n.annotationMode ?? Bi.ENABLE_FORMS), this.imageResourcesPath = n.imageResourcesPath || "", this.maxCanvasPixels = n.maxCanvasPixels ?? rP.get("maxCanvasPixels"), this.pageColors = n.pageColors || null, this.eventBus = n.eventBus, this.renderingQueue = n.renderingQueue, this.l10n = n.l10n, this.l10n || (this.l10n = new Cl()), this.renderTask = null, this.resume = null, this._isStandalone = !((f = this.renderingQueue) != null && f.hasViewer()), this._container = i, this._annotationCanvasMap = null, this.annotationLayer = null, this.annotationEditorLayer = null, this.textLayer = null, this.zoomLayer = null, this.xfaLayer = null, this.structTreeLayer = null, this.drawLayer = null;
    const d = document.createElement("div");
    if (d.className = "page", d.setAttribute("data-page-number", this.id), d.setAttribute("role", "region"), d.setAttribute("data-l10n-id", "pdfjs-page-landmark"), d.setAttribute("data-l10n-args", JSON.stringify({
      page: this.id
    })), this.div = d, E(this, yl, ag).call(this), i == null || i.append(d), this._isStandalone) {
      i == null || i.style.setProperty("--scale-factor", this.scale * _i.PDF_TO_CSS_UNITS);
      const {
        optionalContentConfigPromise: m
      } = n;
      m && m.then((y) => {
        m === this._optionalContentConfigPromise && (r(this, ki).initialOptionalContent = y.hasInitialVisibility);
      }), n.l10n || this.l10n.translate(this.div);
    }
  }
  get renderingState() {
    return r(this, vl);
  }
  set renderingState(n) {
    if (n !== r(this, vl))
      switch (x(this, vl, n), r(this, _n) && (clearTimeout(r(this, _n)), x(this, _n, null)), n) {
        case Kt.PAUSED:
          this.div.classList.remove("loading");
          break;
        case Kt.RUNNING:
          this.div.classList.add("loadingIcon"), x(this, _n, setTimeout(() => {
            this.div.classList.add("loading"), x(this, _n, null);
          }, 0));
          break;
        case Kt.INITIAL:
        case Kt.FINISHED:
          this.div.classList.remove("loadingIcon", "loading");
          break;
      }
  }
  setPdfPage(n) {
    var l, d, f, m;
    this._isStandalone && (((l = this.pageColors) == null ? void 0 : l.foreground) === "CanvasText" || ((d = this.pageColors) == null ? void 0 : d.background) === "Canvas") && ((f = this._container) == null || f.style.setProperty("--hcm-highlight-filter", n.filterFactory.addHighlightHCMFilter("highlight", "CanvasText", "Canvas", "HighlightText", "Highlight")), (m = this._container) == null || m.style.setProperty("--hcm-highlight-selected-filter", n.filterFactory.addHighlightHCMFilter("highlight_selected", "CanvasText", "Canvas", "HighlightText", "Highlight"))), this.pdfPage = n, this.pdfPageRotate = n.rotate;
    const i = (this.rotation + this.pdfPageRotate) % 360;
    this.viewport = n.getViewport({
      scale: this.scale * _i.PDF_TO_CSS_UNITS,
      rotation: i
    }), E(this, yl, ag).call(this), this.reset();
  }
  destroy() {
    var n;
    this.reset(), (n = this.pdfPage) == null || n.cleanup();
  }
  get _textHighlighter() {
    return ug(this, "_textHighlighter", new lP({
      pageIndex: this.id - 1,
      eventBus: this.eventBus,
      findController: r(this, Ln).findController
    }));
  }
  _resetZoomLayer(n = !1) {
    if (!this.zoomLayer)
      return;
    const i = this.zoomLayer.firstChild;
    r(this, ga).delete(i), i.width = 0, i.height = 0, n && this.zoomLayer.remove(), this.zoomLayer = null;
  }
  reset({
    keepZoomLayer: n = !1,
    keepAnnotationLayer: i = !1,
    keepAnnotationEditorLayer: l = !1,
    keepXfaLayer: d = !1,
    keepTextLayer: f = !1
  } = {}) {
    var D, k, H, X, N;
    this.cancelRendering({
      keepAnnotationLayer: i,
      keepAnnotationEditorLayer: l,
      keepXfaLayer: d,
      keepTextLayer: f
    }), this.renderingState = Kt.INITIAL;
    const m = this.div, y = m.childNodes, w = n && this.zoomLayer || null, P = i && ((D = this.annotationLayer) == null ? void 0 : D.div) || null, I = l && ((k = this.annotationEditorLayer) == null ? void 0 : k.div) || null, L = d && ((H = this.xfaLayer) == null ? void 0 : H.div) || null, _ = f && ((X = this.textLayer) == null ? void 0 : X.div) || null;
    for (let z = y.length - 1; z >= 0; z--) {
      const V = y[z];
      switch (V) {
        case w:
        case P:
        case I:
        case L:
        case _:
          continue;
      }
      V.remove();
      const Z = r(this, Mn).indexOf(V);
      Z >= 0 && (r(this, Mn)[Z] = null);
    }
    m.removeAttribute("data-loaded"), P && this.annotationLayer.hide(), I && this.annotationEditorLayer.hide(), L && this.xfaLayer.hide(), _ && this.textLayer.hide(), (N = this.structTreeLayer) == null || N.hide(), w || (this.canvas && (r(this, ga).delete(this.canvas), this.canvas.width = 0, this.canvas.height = 0, delete this.canvas), this._resetZoomLayer());
  }
  update({
    scale: n = 0,
    rotation: i = null,
    optionalContentConfigPromise: l = null,
    drawingDelay: d = -1
  }) {
    var m;
    this.scale = n || this.scale, typeof i == "number" && (this.rotation = i), l instanceof Promise && (this._optionalContentConfigPromise = l, l.then((y) => {
      l === this._optionalContentConfigPromise && (r(this, ki).initialOptionalContent = y.hasInitialVisibility);
    })), r(this, ki).directDrawing = !0;
    const f = (this.rotation + this.pdfPageRotate) % 360;
    if (this.viewport = this.viewport.clone({
      scale: this.scale * _i.PDF_TO_CSS_UNITS,
      rotation: f
    }), E(this, yl, ag).call(this), this._isStandalone && ((m = this._container) == null || m.style.setProperty("--scale-factor", this.viewport.scale)), this.canvas) {
      let y = !1;
      if (r(this, fa)) {
        if (this.maxCanvasPixels === 0)
          y = !0;
        else if (this.maxCanvasPixels > 0) {
          const {
            width: P,
            height: I
          } = this.viewport, {
            sx: L,
            sy: _
          } = this.outputScale;
          y = (Math.floor(P) * L | 0) * (Math.floor(I) * _ | 0) > this.maxCanvasPixels;
        }
      }
      const w = d >= 0 && d < 1e3;
      if (w || y) {
        if (w && !y && this.renderingState !== Kt.FINISHED && (this.cancelRendering({
          keepZoomLayer: !0,
          keepAnnotationLayer: !0,
          keepAnnotationEditorLayer: !0,
          keepXfaLayer: !0,
          keepTextLayer: !0,
          cancelExtraDelay: d
        }), this.renderingState = Kt.FINISHED, r(this, ki).directDrawing = !1), this.cssTransform({
          target: this.canvas,
          redrawAnnotationLayer: !0,
          redrawAnnotationEditorLayer: !0,
          redrawXfaLayer: !0,
          redrawTextLayer: !w,
          hideTextLayer: w
        }), w)
          return;
        this.eventBus.dispatch("pagerendered", {
          source: this,
          pageNumber: this.id,
          cssTransform: !0,
          timestamp: performance.now(),
          error: r(this, pa)
        });
        return;
      }
      !this.zoomLayer && !this.canvas.hidden && (this.zoomLayer = this.canvas.parentNode, this.zoomLayer.style.position = "absolute");
    }
    this.zoomLayer && this.cssTransform({
      target: this.zoomLayer.firstChild
    }), this.reset({
      keepZoomLayer: !0,
      keepAnnotationLayer: !0,
      keepAnnotationEditorLayer: !0,
      keepXfaLayer: !0,
      keepTextLayer: !0
    });
  }
  cancelRendering({
    keepAnnotationLayer: n = !1,
    keepAnnotationEditorLayer: i = !1,
    keepXfaLayer: l = !1,
    keepTextLayer: d = !1,
    cancelExtraDelay: f = 0
  } = {}) {
    var m;
    this.renderTask && (this.renderTask.cancel(f), this.renderTask = null), this.resume = null, this.textLayer && (!d || !this.textLayer.div) && (this.textLayer.cancel(), this.textLayer = null), this.structTreeLayer && !this.textLayer && (this.structTreeLayer = null), this.annotationLayer && (!n || !this.annotationLayer.div) && (this.annotationLayer.cancel(), this.annotationLayer = null, this._annotationCanvasMap = null), this.annotationEditorLayer && (!i || !this.annotationEditorLayer.div) && (this.drawLayer && (this.drawLayer.cancel(), this.drawLayer = null), this.annotationEditorLayer.cancel(), this.annotationEditorLayer = null), this.xfaLayer && (!l || !this.xfaLayer.div) && (this.xfaLayer.cancel(), this.xfaLayer = null, (m = this._textHighlighter) == null || m.disable());
  }
  cssTransform({
    target: n,
    redrawAnnotationLayer: i = !1,
    redrawAnnotationEditorLayer: l = !1,
    redrawXfaLayer: d = !1,
    redrawTextLayer: f = !1,
    hideTextLayer: m = !1
  }) {
    var w;
    if (!n.hasAttribute("zooming")) {
      n.setAttribute("zooming", !0);
      const {
        style: P
      } = n;
      P.width = P.height = "";
    }
    const y = r(this, ga).get(n);
    if (this.viewport !== y) {
      const P = this.viewport.rotation - y.rotation, I = Math.abs(P);
      let L = 1, _ = 1;
      if (I === 90 || I === 270) {
        const {
          width: D,
          height: k
        } = this.viewport;
        L = k / D, _ = D / k;
      }
      n.style.transform = `rotate(${P}deg) scale(${L}, ${_})`;
    }
    i && this.annotationLayer && E(this, ou, ab).call(this), l && this.annotationEditorLayer && (this.drawLayer && E(this, hu, lb).call(this), E(this, lu, ob).call(this)), d && this.xfaLayer && E(this, cu, hb).call(this), this.textLayer && (m ? (this.textLayer.hide(), (w = this.structTreeLayer) == null || w.hide()) : f && E(this, du, cb).call(this));
  }
  get width() {
    return this.viewport.width;
  }
  get height() {
    return this.viewport.height;
  }
  getPagePoint(n, i) {
    return this.viewport.convertToPdfPoint(n, i);
  }
  async draw() {
    this.renderingState !== Kt.INITIAL && (console.error("Must be in new state before drawing"), this.reset());
    const {
      div: n,
      l10n: i,
      pageColors: l,
      pdfPage: d,
      viewport: f
    } = this;
    if (!d)
      throw this.renderingState = Kt.FINISHED, new Error("pdfPage is not loaded");
    this.renderingState = Kt.RUNNING;
    const m = document.createElement("div");
    if (m.classList.add("canvasWrapper"), E(this, On, sl).call(this, m, "canvasWrapper"), !this.textLayer && r(this, bl) !== Ws.DISABLE && !d.isPureXfa && (this._accessibilityManager || (this._accessibilityManager = new nb()), this.textLayer = new pg({
      pdfPage: d,
      highlighter: this._textHighlighter,
      accessibilityManager: this._accessibilityManager,
      enablePermissions: r(this, bl) === Ws.ENABLE_PERMISSIONS,
      onAppend: ($) => {
        this.l10n.pause(), E(this, On, sl).call(this, $, "textLayer"), this.l10n.resume();
      }
    })), !this.annotationLayer && r(this, ua) !== Bi.DISABLE) {
      const {
        annotationStorage: $,
        annotationEditorUIManager: j,
        downloadManager: Q,
        enableScripting: B,
        fieldObjectsPromise: G,
        hasJSActionsPromise: q,
        linkService: tt
      } = r(this, Ln);
      this._annotationCanvasMap || (this._annotationCanvasMap = /* @__PURE__ */ new Map()), this.annotationLayer = new CE({
        pdfPage: d,
        annotationStorage: $,
        imageResourcesPath: this.imageResourcesPath,
        renderForms: r(this, ua) === Bi.ENABLE_FORMS,
        linkService: tt,
        downloadManager: Q,
        enableScripting: B,
        hasJSActionsPromise: q,
        fieldObjectsPromise: G,
        annotationCanvasMap: this._annotationCanvasMap,
        accessibilityManager: this._accessibilityManager,
        annotationEditorUIManager: j,
        onAppend: (lt) => {
          E(this, On, sl).call(this, lt, "annotationLayer");
        }
      });
    }
    const y = ($) => {
      if (_ == null || _(!1), this.renderingQueue && !this.renderingQueue.isHighestPriority(this)) {
        this.renderingState = Kt.PAUSED, this.resume = () => {
          this.renderingState = Kt.RUNNING, $();
        };
        return;
      }
      $();
    }, {
      width: w,
      height: P
    } = f, I = document.createElement("canvas");
    I.setAttribute("role", "presentation"), I.hidden = !0;
    const L = !!(l != null && l.background && (l != null && l.foreground));
    let _ = ($) => {
      (!L || $) && (I.hidden = !1, _ = null);
    };
    m.append(I), this.canvas = I;
    const D = I.getContext("2d", {
      alpha: !1
    }), k = this.outputScale = new pS();
    if (this.maxCanvasPixels === 0) {
      const $ = 1 / this.scale;
      k.sx *= $, k.sy *= $, x(this, fa, !0);
    } else if (this.maxCanvasPixels > 0) {
      const $ = w * P, j = Math.sqrt(this.maxCanvasPixels / $);
      k.sx > j || k.sy > j ? (k.sx = j, k.sy = j, x(this, fa, !0)) : x(this, fa, !1);
    }
    const H = vy(k.sx), X = vy(k.sy);
    I.width = Pp(w * k.sx, H[0]), I.height = Pp(P * k.sy, X[0]);
    const {
      style: N
    } = I;
    N.width = Pp(w, H[1]) + "px", N.height = Pp(P, X[1]) + "px", r(this, ga).set(I, f);
    const z = k.scaled ? [k.sx, 0, 0, k.sy, 0, 0] : null, V = {
      canvasContext: D,
      transform: z,
      viewport: f,
      annotationMode: r(this, ua),
      optionalContentConfigPromise: this._optionalContentConfigPromise,
      annotationCanvasMap: this._annotationCanvasMap,
      pageColors: l
    }, Z = this.renderTask = d.render(V);
    Z.onContinue = y;
    const K = Z.promise.then(async () => {
      var j;
      _ == null || _(!0), await E(this, uu, db).call(this, Z), E(this, du, cb).call(this), this.annotationLayer && await E(this, ou, ab).call(this);
      const {
        annotationEditorUIManager: $
      } = r(this, Ln);
      $ && (this.drawLayer || (this.drawLayer = new aP({
        pageIndex: this.id
      })), await E(this, hu, lb).call(this), this.drawLayer.setParent(m), this.annotationEditorLayer || (this.annotationEditorLayer = new nP({
        uiManager: $,
        pdfPage: d,
        l10n: i,
        accessibilityManager: this._accessibilityManager,
        annotationLayer: (j = this.annotationLayer) == null ? void 0 : j.annotationLayer,
        textLayer: this.textLayer,
        drawLayer: this.drawLayer.getDrawLayer(),
        onAppend: (Q) => {
          E(this, On, sl).call(this, Q, "annotationEditorLayer");
        }
      })), E(this, lu, ob).call(this));
    }, ($) => ($ instanceof Kv || _ == null || _(!0), E(this, uu, db).call(this, Z, $)));
    if (d.isPureXfa) {
      if (!this.xfaLayer) {
        const {
          annotationStorage: $,
          linkService: j
        } = r(this, Ln);
        this.xfaLayer = new XE({
          pdfPage: d,
          annotationStorage: $,
          linkService: j
        });
      }
      E(this, cu, hb).call(this);
    }
    return n.setAttribute("data-loaded", !0), this.eventBus.dispatch("pagerender", {
      source: this,
      pageNumber: this.id
    }), K;
  }
  setPageLabel(n) {
    this.pageLabel = typeof n == "string" ? n : null, this.div.setAttribute("data-l10n-args", JSON.stringify({
      page: this.pageLabel ?? this.id
    })), this.pageLabel !== null ? this.div.setAttribute("data-page-label", this.pageLabel) : this.div.removeAttribute("data-page-label");
  }
  get thumbnailCanvas() {
    const {
      directDrawing: n,
      initialOptionalContent: i,
      regularAnnotations: l
    } = r(this, ki);
    return n && i && l ? this.canvas : null;
  }
}
ua = new WeakMap(), fa = new WeakMap(), Ln = new WeakMap(), _n = new WeakMap(), au = new WeakMap(), pa = new WeakMap(), vl = new WeakMap(), bl = new WeakMap(), ki = new WeakMap(), ga = new WeakMap(), Mn = new WeakMap(), On = new WeakSet(), sl = function(n, i) {
  const l = cP.get(i), d = r(this, Mn)[l];
  if (r(this, Mn)[l] = n, d) {
    d.replaceWith(n);
    return;
  }
  for (let f = l - 1; f >= 0; f--) {
    const m = r(this, Mn)[f];
    if (m) {
      m.after(n);
      return;
    }
  }
  this.div.prepend(n);
}, yl = new WeakSet(), ag = function() {
  const {
    viewport: n
  } = this;
  if (this.pdfPage) {
    if (r(this, au) === n.rotation)
      return;
    x(this, au, n.rotation);
  }
  sx(this.div, n, !0, !1);
}, ma = new WeakSet(), Rd = function(n, i) {
  this.eventBus.dispatch(n, {
    source: this,
    pageNumber: this.id,
    error: i
  });
}, ou = new WeakSet(), ab = async function() {
  let n = null;
  try {
    await this.annotationLayer.render(this.viewport, "display");
  } catch (i) {
    console.error(`#renderAnnotationLayer: "${i}".`), n = i;
  } finally {
    E(this, ma, Rd).call(this, "annotationlayerrendered", n);
  }
}, lu = new WeakSet(), ob = async function() {
  let n = null;
  try {
    await this.annotationEditorLayer.render(this.viewport, "display");
  } catch (i) {
    console.error(`#renderAnnotationEditorLayer: "${i}".`), n = i;
  } finally {
    E(this, ma, Rd).call(this, "annotationeditorlayerrendered", n);
  }
}, hu = new WeakSet(), lb = async function() {
  try {
    await this.drawLayer.render("display");
  } catch (n) {
    console.error(`#renderDrawLayer: "${n}".`);
  }
}, cu = new WeakSet(), hb = async function() {
  var i;
  let n = null;
  try {
    const l = await this.xfaLayer.render(this.viewport, "display");
    l != null && l.textDivs && this._textHighlighter && E(this, Hg, QE).call(this, l.textDivs);
  } catch (l) {
    console.error(`#renderXfaLayer: "${l}".`), n = l;
  } finally {
    (i = this.xfaLayer) != null && i.div && (this.l10n.pause(), E(this, On, sl).call(this, this.xfaLayer.div, "xfaLayer"), this.l10n.resume()), E(this, ma, Rd).call(this, "xfalayerrendered", n);
  }
}, du = new WeakSet(), cb = async function() {
  if (!this.textLayer)
    return;
  let n = null;
  try {
    await this.textLayer.render(this.viewport);
  } catch (i) {
    if (i instanceof XS)
      return;
    console.error(`#renderTextLayer: "${i}".`), n = i;
  }
  E(this, ma, Rd).call(this, "textlayerrendered", n), E(this, jg, YE).call(this);
}, jg = new WeakSet(), YE = async function() {
  var l, d, f;
  if (!this.textLayer)
    return;
  this.structTreeLayer || (this.structTreeLayer = new $E());
  const n = await (this.structTreeLayer.renderingDone ? null : this.pdfPage.getStructTree()), i = (l = this.structTreeLayer) == null ? void 0 : l.render(n);
  i && (this.l10n.pause(), (d = this.canvas) == null || d.append(i), this.l10n.resume()), (f = this.structTreeLayer) == null || f.show();
}, Hg = new WeakSet(), QE = async function(n) {
  const i = await this.pdfPage.getTextContent(), l = [];
  for (const d of i.items)
    l.push(d.str);
  this._textHighlighter.setTextMapping(n, l), this._textHighlighter.enable();
}, uu = new WeakSet(), db = async function(n, i = null) {
  if (n === this.renderTask && (this.renderTask = null), i instanceof Kv) {
    x(this, pa, null);
    return;
  }
  if (x(this, pa, i), this.renderingState = Kt.FINISHED, this._resetZoomLayer(!0), r(this, ki).regularAnnotations = !n.separateAnnots, this.eventBus.dispatch("pagerendered", {
    source: this,
    pageNumber: this.id,
    cssTransform: !1,
    timestamp: performance.now(),
    error: r(this, pa)
  }), i)
    throw i;
};
async function dP(u) {
  const n = "", i = n.split("#", 1)[0];
  let {
    info: l,
    metadata: d,
    contentDispositionFilename: f,
    contentLength: m
  } = await u.getMetadata();
  if (!m) {
    const {
      length: y
    } = await u.getDownloadInfo();
    m = y;
  }
  return {
    ...l,
    baseURL: i,
    filesize: m,
    filename: f || qS(n),
    metadata: d == null ? void 0 : d.getRaw(),
    authors: d == null ? void 0 : d.get("dc:creator"),
    numPages: u.numPages,
    URL: n
  };
}
class uP {
  constructor(n) {
    this._ready = new Promise((i, l) => {
      import(
        /*webpackIgnore: true*/
        n
      ).then((f) => {
        i(f.QuickJSSandbox());
      }).catch(l);
    });
  }
  async createSandbox(n) {
    (await this._ready).create(n);
  }
  async dispatchEventInSandbox(n) {
    const i = await this._ready;
    setTimeout(() => i.dispatchEvent(n), 0);
  }
  async destroySandbox() {
    (await this._ready).nukeSandbox();
  }
}
var Us, va, fu, ba, ya, pu, Ie, Di, Al, ie, ss, Vg, ZE, El, og, gu, ub, $g, JE, Aa, Id;
class fP {
  constructor({
    eventBus: n,
    externalServices: i = null,
    docProperties: l = null
  }) {
    v(this, Vg);
    v(this, El);
    v(this, gu);
    v(this, $g);
    v(this, Aa);
    v(this, Us, null);
    v(this, va, null);
    v(this, fu, null);
    v(this, ba, null);
    v(this, ya, null);
    v(this, pu, null);
    v(this, Ie, null);
    v(this, Di, null);
    v(this, Al, !1);
    v(this, ie, null);
    v(this, ss, null);
    x(this, ya, n), x(this, pu, i), x(this, fu, l);
  }
  setViewer(n) {
    x(this, Di, n);
  }
  async setDocument(n) {
    var y;
    if (r(this, Ie) && await E(this, Aa, Id).call(this), x(this, Ie, n), !n)
      return;
    const [i, l, d] = await Promise.all([n.getFieldObjects(), n.getCalculationOrderIds(), n.getJSActions()]);
    if (!i && !d) {
      await E(this, Aa, Id).call(this);
      return;
    }
    if (n !== r(this, Ie))
      return;
    try {
      x(this, ie, E(this, $g, JE).call(this));
    } catch (w) {
      console.error(`setDocument: "${w.message}".`), await E(this, Aa, Id).call(this);
      return;
    }
    const f = r(this, ya);
    x(this, ba, new AbortController());
    const {
      signal: m
    } = r(this, ba);
    f._on("updatefromsandbox", (w) => {
      (w == null ? void 0 : w.source) === window && E(this, Vg, ZE).call(this, w.detail);
    }, {
      signal: m
    }), f._on("dispatcheventinsandbox", (w) => {
      var P;
      (P = r(this, ie)) == null || P.dispatchEventInSandbox(w.detail);
    }, {
      signal: m
    }), f._on("pagechanging", ({
      pageNumber: w,
      previous: P
    }) => {
      w !== P && (E(this, gu, ub).call(this, P), E(this, El, og).call(this, w));
    }, {
      signal: m
    }), f._on("pagerendered", ({
      pageNumber: w
    }) => {
      this._pageOpenPending.has(w) && w === r(this, Di).currentPageNumber && E(this, El, og).call(this, w);
    }, {
      signal: m
    }), f._on("pagesdestroy", async () => {
      var w, P;
      await E(this, gu, ub).call(this, r(this, Di).currentPageNumber), await ((w = r(this, ie)) == null ? void 0 : w.dispatchEventInSandbox({
        id: "doc",
        name: "WillClose"
      })), (P = r(this, Us)) == null || P.resolve();
    }, {
      signal: m
    });
    try {
      const w = await r(this, fu).call(this, n);
      if (n !== r(this, Ie))
        return;
      await r(this, ie).createSandbox({
        objects: i,
        calculationOrder: l,
        appInfo: {
          platform: navigator.platform,
          language: navigator.language
        },
        docInfo: {
          ...w,
          actions: d
        }
      }), f.dispatch("sandboxcreated", {
        source: this
      });
    } catch (w) {
      console.error(`setDocument: "${w.message}".`), await E(this, Aa, Id).call(this);
      return;
    }
    await ((y = r(this, ie)) == null ? void 0 : y.dispatchEventInSandbox({
      id: "doc",
      name: "Open"
    })), await E(this, El, og).call(this, r(this, Di).currentPageNumber, !0), Promise.resolve().then(() => {
      n === r(this, Ie) && x(this, Al, !0);
    });
  }
  async dispatchWillSave() {
    var n;
    return (n = r(this, ie)) == null ? void 0 : n.dispatchEventInSandbox({
      id: "doc",
      name: "WillSave"
    });
  }
  async dispatchDidSave() {
    var n;
    return (n = r(this, ie)) == null ? void 0 : n.dispatchEventInSandbox({
      id: "doc",
      name: "DidSave"
    });
  }
  async dispatchWillPrint() {
    var n;
    if (r(this, ie)) {
      await ((n = r(this, ss)) == null ? void 0 : n.promise), x(this, ss, Promise.withResolvers());
      try {
        await r(this, ie).dispatchEventInSandbox({
          id: "doc",
          name: "WillPrint"
        });
      } catch (i) {
        throw r(this, ss).resolve(), x(this, ss, null), i;
      }
      await r(this, ss).promise;
    }
  }
  async dispatchDidPrint() {
    var n;
    return (n = r(this, ie)) == null ? void 0 : n.dispatchEventInSandbox({
      id: "doc",
      name: "DidPrint"
    });
  }
  get destroyPromise() {
    var n;
    return ((n = r(this, va)) == null ? void 0 : n.promise) || null;
  }
  get ready() {
    return r(this, Al);
  }
  get _pageOpenPending() {
    return ug(this, "_pageOpenPending", /* @__PURE__ */ new Set());
  }
  get _visitedPages() {
    return ug(this, "_visitedPages", /* @__PURE__ */ new Map());
  }
}
Us = new WeakMap(), va = new WeakMap(), fu = new WeakMap(), ba = new WeakMap(), ya = new WeakMap(), pu = new WeakMap(), Ie = new WeakMap(), Di = new WeakMap(), Al = new WeakMap(), ie = new WeakMap(), ss = new WeakMap(), Vg = new WeakSet(), ZE = async function(n) {
  var P, I;
  const i = r(this, Di), l = i.isInPresentationMode || i.isChangingPresentationMode, {
    id: d,
    siblings: f,
    command: m,
    value: y
  } = n;
  if (!d) {
    switch (m) {
      case "clear":
        console.clear();
        break;
      case "error":
        console.error(y);
        break;
      case "layout":
        if (!l) {
          const L = SS(y);
          i.spreadMode = L.spreadMode;
        }
        break;
      case "page-num":
        i.currentPageNumber = y + 1;
        break;
      case "print":
        await i.pagesPromise, r(this, ya).dispatch("print", {
          source: this
        });
        break;
      case "println":
        console.log(y);
        break;
      case "zoom":
        l || (i.currentScaleValue = y);
        break;
      case "SaveAs":
        r(this, ya).dispatch("download", {
          source: this
        });
        break;
      case "FirstPage":
        i.currentPageNumber = 1;
        break;
      case "LastPage":
        i.currentPageNumber = i.pagesCount;
        break;
      case "NextPage":
        i.nextPage();
        break;
      case "PrevPage":
        i.previousPage();
        break;
      case "ZoomViewIn":
        l || i.increaseScale();
        break;
      case "ZoomViewOut":
        l || i.decreaseScale();
        break;
      case "WillPrintFinished":
        (P = r(this, ss)) == null || P.resolve(), x(this, ss, null);
        break;
    }
    return;
  }
  if (l && n.focus)
    return;
  delete n.id, delete n.siblings;
  const w = f ? [d, ...f] : [d];
  for (const L of w) {
    const _ = document.querySelector(`[data-element-id="${L}"]`);
    _ ? _.dispatchEvent(new CustomEvent("updatefromsandbox", {
      detail: n
    })) : (I = r(this, Ie)) == null || I.annotationStorage.setValue(L, n);
  }
}, El = new WeakSet(), og = async function(n, i = !1) {
  const l = r(this, Ie), d = this._visitedPages;
  if (i && x(this, Us, Promise.withResolvers()), !r(this, Us))
    return;
  const f = r(this, Di).getPageView(n - 1);
  if ((f == null ? void 0 : f.renderingState) !== Kt.FINISHED) {
    this._pageOpenPending.add(n);
    return;
  }
  this._pageOpenPending.delete(n);
  const m = (async () => {
    var w, P;
    const y = await (d.has(n) ? null : (w = f.pdfPage) == null ? void 0 : w.getJSActions());
    l === r(this, Ie) && await ((P = r(this, ie)) == null ? void 0 : P.dispatchEventInSandbox({
      id: "page",
      name: "PageOpen",
      pageNumber: n,
      actions: y
    }));
  })();
  d.set(n, m);
}, gu = new WeakSet(), ub = async function(n) {
  var f;
  const i = r(this, Ie), l = this._visitedPages;
  if (!r(this, Us) || this._pageOpenPending.has(n))
    return;
  const d = l.get(n);
  d && (l.set(n, null), await d, i === r(this, Ie) && await ((f = r(this, ie)) == null ? void 0 : f.dispatchEventInSandbox({
    id: "page",
    name: "PageClose",
    pageNumber: n
  })));
}, $g = new WeakSet(), JE = function() {
  if (x(this, va, Promise.withResolvers()), r(this, ie))
    throw new Error("#initScripting: Scripting already exists.");
  return r(this, pu).createScripting();
}, Aa = new WeakSet(), Id = async function() {
  var n, i, l, d;
  if (!r(this, ie)) {
    x(this, Ie, null), (n = r(this, va)) == null || n.resolve();
    return;
  }
  r(this, Us) && (await Promise.race([r(this, Us).promise, new Promise((f) => {
    setTimeout(f, 1e3);
  })]).catch(() => {
  }), x(this, Us, null)), x(this, Ie, null);
  try {
    await r(this, ie).destroySandbox();
  } catch {
  }
  (i = r(this, ss)) == null || i.reject(new Error("Scripting destroyed.")), x(this, ss, null), (l = r(this, ba)) == null || l.abort(), x(this, ba, null), this._pageOpenPending.clear(), this._visitedPages.clear(), x(this, ie, null), x(this, Al, !1), (d = r(this, va)) == null || d.resolve();
};
class pP extends fP {
  constructor(n) {
    n.externalServices || window.addEventListener("updatefromsandbox", (i) => {
      n.eventBus.dispatch("updatefromsandbox", {
        source: window,
        detail: i.detail
      });
    }), n.externalServices || (n.externalServices = {
      createScripting: () => new uP(n.sandboxBundleSrc)
    }), n.docProperties || (n.docProperties = (i) => dP(i)), super(n);
  }
}
const gP = 3e4;
class mP {
  constructor() {
    this.pdfViewer = null, this.pdfThumbnailViewer = null, this.onIdle = null, this.highestPriorityPage = null, this.idleTimeout = null, this.printing = !1, this.isThumbnailViewEnabled = !1, Object.defineProperty(this, "hasViewer", {
      value: () => !!this.pdfViewer
    });
  }
  setViewer(n) {
    this.pdfViewer = n;
  }
  setThumbnailViewer(n) {
    this.pdfThumbnailViewer = n;
  }
  isHighestPriority(n) {
    return this.highestPriorityPage === n.renderingId;
  }
  renderHighestPriority(n) {
    var i;
    this.idleTimeout && (clearTimeout(this.idleTimeout), this.idleTimeout = null), !this.pdfViewer.forceRendering(n) && (this.isThumbnailViewEnabled && ((i = this.pdfThumbnailViewer) != null && i.forceRendering()) || this.printing || this.onIdle && (this.idleTimeout = setTimeout(this.onIdle.bind(this), gP)));
  }
  getHighestPriority(n, i, l, d = !1) {
    const f = n.views, m = f.length;
    if (m === 0)
      return null;
    for (let L = 0; L < m; L++) {
      const _ = f[L].view;
      if (!this.isViewFinished(_))
        return _;
    }
    const y = n.first.id, w = n.last.id;
    if (w - y + 1 > m) {
      const L = n.ids;
      for (let _ = 1, D = w - y; _ < D; _++) {
        const k = l ? y + _ : w - _;
        if (L.has(k))
          continue;
        const H = i[k - 1];
        if (!this.isViewFinished(H))
          return H;
      }
    }
    let P = l ? w : y - 2, I = i[P];
    return I && !this.isViewFinished(I) || d && (P += l ? 1 : -1, I = i[P], I && !this.isViewFinished(I)) ? I : null;
  }
  isViewFinished(n) {
    return n.renderingState === Kt.FINISHED;
  }
  renderView(n) {
    switch (n.renderingState) {
      case Kt.FINISHED:
        return !1;
      case Kt.PAUSED:
        this.highestPriorityPage = n.renderingId, n.resume();
        break;
      case Kt.RUNNING:
        this.highestPriorityPage = n.renderingId;
        break;
      case Kt.INITIAL:
        this.highestPriorityPage = n.renderingId, n.draw().finally(() => {
          this.renderHighestPriority();
        }).catch((i) => {
          i instanceof Kv || console.error(`renderView: "${i}"`);
        });
        break;
    }
    return !0;
  }
}
const Uy = 10, Ip = {
  FORCE_SCROLL_MODE_PAGE: 15e3,
  FORCE_LAZY_PAGE_INIT: 7500,
  PAUSE_EAGER_PAGE_INIT: 250
};
function zy(u) {
  return Object.values(wn).includes(u) && u !== wn.DISABLE;
}
var Ni, Ea, mu, fb;
class vP {
  constructor(n) {
    v(this, mu);
    v(this, Ni, /* @__PURE__ */ new Set());
    v(this, Ea, 0);
    x(this, Ea, n);
  }
  push(n) {
    const i = r(this, Ni);
    i.has(n) && i.delete(n), i.add(n), i.size > r(this, Ea) && E(this, mu, fb).call(this);
  }
  resize(n, i = null) {
    x(this, Ea, n);
    const l = r(this, Ni);
    if (i) {
      const d = l.size;
      let f = 1;
      for (const m of l)
        if (i.has(m.id) && (l.delete(m), l.add(m)), ++f > d)
          break;
    }
    for (; l.size > r(this, Ea); )
      E(this, mu, fb).call(this);
  }
  has(n) {
    return r(this, Ni).has(n);
  }
  [Symbol.iterator]() {
    return r(this, Ni).keys();
  }
}
Ni = new WeakMap(), Ea = new WeakMap(), mu = new WeakSet(), fb = function() {
  const n = r(this, Ni).keys().next().value;
  n == null || n.destroy(), r(this, Ni).delete(n);
};
var kn, vu, bu, Fi, Ee, wa, yu, Au, Eu, Sa, wu, wl, Dn, Sl, Su, Ug, xa, Nn, xl, zg, t0, Wg, e0, Gg, s0, Pa, Ld, Pl, lg, Xg, i0, xu, pb, Kg, n0, zs, En, Pu, gb, Yg, r0, Qg, a0, Tu, mb, Zg, o0;
class qE {
  constructor(n) {
    v(this, zg);
    v(this, Wg);
    v(this, Gg);
    v(this, Pa);
    v(this, Pl);
    v(this, Xg);
    v(this, xu);
    v(this, Kg);
    v(this, zs);
    v(this, Pu);
    v(this, Yg);
    v(this, Qg);
    v(this, Tu);
    v(this, Zg);
    v(this, kn, null);
    v(this, vu, null);
    v(this, bu, null);
    v(this, Fi, wn.NONE);
    v(this, Ee, null);
    v(this, wa, Bi.ENABLE_FORMS);
    v(this, yu, null);
    v(this, Au, !1);
    v(this, Eu, !1);
    v(this, Sa, null);
    v(this, wu, null);
    v(this, wl, !1);
    v(this, Dn, null);
    v(this, Sl, !1);
    v(this, Su, 0);
    v(this, Ug, new ResizeObserver(E(this, Zg, o0).bind(this)));
    v(this, xa, null);
    v(this, Nn, null);
    v(this, xl, Ws.ENABLE);
    var l, d;
    const i = "4.3.136";
    if (Ty !== i)
      throw new Error(`The API version "${Ty}" does not match the Viewer version "${i}".`);
    if (this.container = n.container, this.viewer = n.viewer || n.container.firstElementChild, ((l = this.container) == null ? void 0 : l.tagName) !== "DIV" || ((d = this.viewer) == null ? void 0 : d.tagName) !== "DIV")
      throw new Error("Invalid `container` and/or `viewer` option.");
    if (this.container.offsetParent && getComputedStyle(this.container).position !== "absolute")
      throw new Error("The `container` must be absolutely positioned.");
    r(this, Ug).observe(this.container), this.eventBus = n.eventBus, this.linkService = n.linkService || new yb(), this.downloadManager = n.downloadManager || null, this.findController = n.findController || null, x(this, vu, n.altTextManager || null), this.findController && (this.findController.onIsPageVisible = (f) => this._getVisiblePages().ids.has(f)), this._scriptingManager = n.scriptingManager || null, x(this, xl, n.textLayerMode ?? Ws.ENABLE), x(this, wa, n.annotationMode ?? Bi.ENABLE_FORMS), x(this, Fi, n.annotationEditorMode ?? wn.NONE), x(this, bu, n.annotationEditorHighlightColors || null), x(this, Au, n.enableHighlightFloatingButton === !0), this.imageResourcesPath = n.imageResourcesPath || "", this.enablePrintAutoRotate = n.enablePrintAutoRotate || !1, this.removePageBorders = n.removePageBorders || !1, this.maxCanvasPixels = n.maxCanvasPixels, this.l10n = n.l10n, this.l10n || (this.l10n = new Cl()), x(this, Eu, n.enablePermissions || !1), this.pageColors = n.pageColors || null, x(this, wu, n.mlManager || null), this.defaultRenderingQueue = !n.renderingQueue, this.defaultRenderingQueue ? (this.renderingQueue = new mP(), this.renderingQueue.setViewer(this)) : this.renderingQueue = n.renderingQueue, this.scroll = gS(this.container, this._scrollUpdate.bind(this)), this.presentationModeState = rl.UNKNOWN, this._resetView(), this.removePageBorders && this.viewer.classList.add("removePageBorders"), E(this, Tu, mb).call(this), this.eventBus._on("thumbnailrendered", ({
      pageNumber: f,
      pdfPage: m
    }) => {
      const y = this._pages[f - 1];
      r(this, kn).has(y) || m == null || m.cleanup();
    }), n.l10n || this.l10n.translate(this.container);
  }
  get pagesCount() {
    return this._pages.length;
  }
  getPageView(n) {
    return this._pages[n];
  }
  getCachedPageViews() {
    return new Set(r(this, kn));
  }
  get pageViewsReady() {
    return this._pages.every((n) => n == null ? void 0 : n.pdfPage);
  }
  get renderForms() {
    return r(this, wa) === Bi.ENABLE_FORMS;
  }
  get enableScripting() {
    return !!this._scriptingManager;
  }
  get currentPageNumber() {
    return this._currentPageNumber;
  }
  set currentPageNumber(n) {
    if (!Number.isInteger(n))
      throw new Error("Invalid page number.");
    this.pdfDocument && (this._setCurrentPageNumber(n, !0) || console.error(`currentPageNumber: "${n}" is not a valid page.`));
  }
  _setCurrentPageNumber(n, i = !1) {
    var d;
    if (this._currentPageNumber === n)
      return i && E(this, Pu, gb).call(this), !0;
    if (!(0 < n && n <= this.pagesCount))
      return !1;
    const l = this._currentPageNumber;
    return this._currentPageNumber = n, this.eventBus.dispatch("pagechanging", {
      source: this,
      pageNumber: n,
      pageLabel: ((d = this._pageLabels) == null ? void 0 : d[n - 1]) ?? null,
      previous: l
    }), i && E(this, Pu, gb).call(this), !0;
  }
  get currentPageLabel() {
    var n;
    return ((n = this._pageLabels) == null ? void 0 : n[this._currentPageNumber - 1]) ?? null;
  }
  set currentPageLabel(n) {
    if (!this.pdfDocument)
      return;
    let i = n | 0;
    if (this._pageLabels) {
      const l = this._pageLabels.indexOf(n);
      l >= 0 && (i = l + 1);
    }
    this._setCurrentPageNumber(i, !0) || console.error(`currentPageLabel: "${n}" is not a valid page.`);
  }
  get currentScale() {
    return this._currentScale !== km ? this._currentScale : gE;
  }
  set currentScale(n) {
    if (isNaN(n))
      throw new Error("Invalid numeric scale.");
    this.pdfDocument && E(this, zs, En).call(this, n, {
      noScroll: !1
    });
  }
  get currentScaleValue() {
    return this._currentScaleValue;
  }
  set currentScaleValue(n) {
    this.pdfDocument && E(this, zs, En).call(this, n, {
      noScroll: !1
    });
  }
  get pagesRotation() {
    return this._pagesRotation;
  }
  set pagesRotation(n) {
    if (!vE(n))
      throw new Error("Invalid pages rotation angle.");
    if (!this.pdfDocument || (n %= 360, n < 0 && (n += 360), this._pagesRotation === n))
      return;
    this._pagesRotation = n;
    const i = this._currentPageNumber;
    this.refresh(!0, {
      rotation: n
    }), this._currentScaleValue && E(this, zs, En).call(this, this._currentScaleValue, {
      noScroll: !0
    }), this.eventBus.dispatch("rotationchanging", {
      source: this,
      pagesRotation: n,
      pageNumber: i
    }), this.defaultRenderingQueue && this.update();
  }
  get firstPagePromise() {
    return this.pdfDocument ? this._firstPageCapability.promise : null;
  }
  get onePageRendered() {
    return this.pdfDocument ? this._onePageRenderedCapability.promise : null;
  }
  get pagesPromise() {
    return this.pdfDocument ? this._pagesCapability.promise : null;
  }
  get _layerProperties() {
    const n = this;
    return ug(this, "_layerProperties", {
      get annotationEditorUIManager() {
        return r(n, Ee);
      },
      get annotationStorage() {
        var i;
        return (i = n.pdfDocument) == null ? void 0 : i.annotationStorage;
      },
      get downloadManager() {
        return n.downloadManager;
      },
      get enableScripting() {
        return !!n._scriptingManager;
      },
      get fieldObjectsPromise() {
        var i;
        return (i = n.pdfDocument) == null ? void 0 : i.getFieldObjects();
      },
      get findController() {
        return n.findController;
      },
      get hasJSActionsPromise() {
        var i;
        return (i = n.pdfDocument) == null ? void 0 : i.hasJSActions();
      },
      get linkService() {
        return n.linkService;
      }
    });
  }
  async getAllText() {
    const n = [], i = [];
    for (let l = 1, d = this.pdfDocument.numPages; l <= d; ++l) {
      if (r(this, Sl))
        return null;
      i.length = 0;
      const f = await this.pdfDocument.getPage(l), {
        items: m
      } = await f.getTextContent();
      for (const y of m)
        y.str && i.push(y.str), y.hasEOL && i.push(`
`);
      n.push(cg(i.join("")));
    }
    return n.join(`
`);
  }
  setDocument(n) {
    var _, D;
    if (this.pdfDocument && (this.eventBus.dispatch("pagesdestroy", {
      source: this
    }), this._cancelRendering(), this._resetView(), (_ = this.findController) == null || _.setDocument(null), (D = this._scriptingManager) == null || D.setDocument(null), r(this, Ee) && (r(this, Ee).destroy(), x(this, Ee, null))), this.pdfDocument = n, !n)
      return;
    const i = n.numPages, l = n.getPage(1), d = n.getOptionalContentConfig({
      intent: "display"
    }), f = r(this, Eu) ? n.getPermissions() : Promise.resolve(), {
      eventBus: m,
      pageColors: y,
      viewer: w
    } = this;
    x(this, Sa, new AbortController());
    const {
      signal: P
    } = r(this, Sa);
    if (i > Ip.FORCE_SCROLL_MODE_PAGE) {
      console.warn("Forcing PAGE-scrolling for performance reasons, given the length of the document.");
      const k = this._scrollMode = xt.PAGE;
      m.dispatch("scrollmodechanged", {
        source: this,
        mode: k
      });
    }
    this._pagesCapability.promise.then(() => {
      m.dispatch("pagesloaded", {
        source: this,
        pagesCount: i
      });
    }, () => {
    });
    const I = (k) => {
      const H = this._pages[k.pageNumber - 1];
      H && r(this, kn).push(H);
    };
    m._on("pagerender", I, {
      signal: P
    });
    const L = (k) => {
      k.cssTransform || (this._onePageRenderedCapability.resolve({
        timestamp: k.timestamp
      }), m._off("pagerendered", L));
    };
    m._on("pagerendered", L, {
      signal: P
    }), Promise.all([l, f]).then(([k, H]) => {
      var $;
      if (n !== this.pdfDocument)
        return;
      this._firstPageCapability.resolve(k), this._optionalContentConfigPromise = d;
      const {
        annotationEditorMode: X,
        annotationMode: N,
        textLayerMode: z
      } = E(this, zg, t0).call(this, H);
      if (z !== Ws.DISABLE) {
        const j = x(this, Dn, document.createElement("div"));
        j.id = "hiddenCopyElement", w.before(j);
      }
      if (X !== wn.DISABLE) {
        const j = X;
        n.isPureXfa ? console.warn("Warning: XFA-editing is not implemented.") : zy(j) ? (x(this, Ee, new YS(this.container, w, r(this, vu), m, n, y, r(this, bu), r(this, Au), r(this, wu))), m.dispatch("annotationeditoruimanager", {
          source: this,
          uiManager: r(this, Ee)
        }), j !== wn.NONE && r(this, Ee).updateMode(j)) : console.error(`Invalid AnnotationEditor mode: ${j}`);
      }
      const V = this._scrollMode === xt.PAGE ? null : w, Z = this.currentScale, K = k.getViewport({
        scale: Z * _i.PDF_TO_CSS_UNITS
      });
      w.style.setProperty("--scale-factor", K.scale), ((y == null ? void 0 : y.foreground) === "CanvasText" || (y == null ? void 0 : y.background) === "Canvas") && (w.style.setProperty("--hcm-highlight-filter", n.filterFactory.addHighlightHCMFilter("highlight", "CanvasText", "Canvas", "HighlightText", "Highlight")), w.style.setProperty("--hcm-highlight-selected-filter", n.filterFactory.addHighlightHCMFilter("highlight_selected", "CanvasText", "Canvas", "HighlightText", "ButtonText")));
      for (let j = 1; j <= i; ++j) {
        const Q = new KE({
          container: V,
          eventBus: m,
          id: j,
          scale: Z,
          defaultViewport: K.clone(),
          optionalContentConfigPromise: d,
          renderingQueue: this.renderingQueue,
          textLayerMode: z,
          annotationMode: N,
          imageResourcesPath: this.imageResourcesPath,
          maxCanvasPixels: this.maxCanvasPixels,
          pageColors: y,
          l10n: this.l10n,
          layerProperties: this._layerProperties
        });
        this._pages.push(Q);
      }
      ($ = this._pages[0]) == null || $.setPdfPage(k), this._scrollMode === xt.PAGE ? E(this, Pa, Ld).call(this) : this._spreadMode !== we.NONE && this._updateSpreadMode(), E(this, Wg, e0).call(this, P).then(async () => {
        var Q, B;
        if (n !== this.pdfDocument)
          return;
        if ((Q = this.findController) == null || Q.setDocument(n), (B = this._scriptingManager) == null || B.setDocument(n), r(this, Dn) && document.addEventListener("copy", E(this, Gg, s0).bind(this, z), {
          signal: P
        }), r(this, Ee) && m.dispatch("annotationeditormodechanged", {
          source: this,
          mode: r(this, Fi)
        }), n.loadingParams.disableAutoFetch || i > Ip.FORCE_LAZY_PAGE_INIT) {
          this._pagesCapability.resolve();
          return;
        }
        let j = i - 1;
        if (j <= 0) {
          this._pagesCapability.resolve();
          return;
        }
        for (let G = 2; G <= i; ++G) {
          const q = n.getPage(G).then((tt) => {
            const lt = this._pages[G - 1];
            lt.pdfPage || lt.setPdfPage(tt), --j === 0 && this._pagesCapability.resolve();
          }, (tt) => {
            console.error(`Unable to get page ${G} to initialize viewer`, tt), --j === 0 && this._pagesCapability.resolve();
          });
          G % Ip.PAUSE_EAGER_PAGE_INIT === 0 && await q;
        }
      }), m.dispatch("pagesinit", {
        source: this
      }), n.getMetadata().then(({
        info: j
      }) => {
        n === this.pdfDocument && j.Language && (w.lang = j.Language);
      }), this.defaultRenderingQueue && this.update();
    }).catch((k) => {
      console.error("Unable to initialize viewer", k), this._pagesCapability.reject(k);
    });
  }
  setPageLabels(n) {
    var i;
    if (this.pdfDocument) {
      n ? Array.isArray(n) && this.pdfDocument.numPages === n.length ? this._pageLabels = n : (this._pageLabels = null, console.error("setPageLabels: Invalid page labels.")) : this._pageLabels = null;
      for (let l = 0, d = this._pages.length; l < d; l++)
        this._pages[l].setPageLabel(((i = this._pageLabels) == null ? void 0 : i[l]) ?? null);
    }
  }
  _resetView() {
    var n, i;
    this._pages = [], this._currentPageNumber = 1, this._currentScale = km, this._currentScaleValue = null, this._pageLabels = null, x(this, kn, new vP(Uy)), this._location = null, this._pagesRotation = 0, this._optionalContentConfigPromise = null, this._firstPageCapability = Promise.withResolvers(), this._onePageRenderedCapability = Promise.withResolvers(), this._pagesCapability = Promise.withResolvers(), this._scrollMode = xt.VERTICAL, this._previousScrollMode = xt.UNKNOWN, this._spreadMode = we.NONE, x(this, xa, {
      previousPageNumber: 1,
      scrollDown: !0,
      pages: []
    }), (n = r(this, Sa)) == null || n.abort(), x(this, Sa, null), this.viewer.textContent = "", this._updateScrollMode(), this.viewer.removeAttribute("lang"), (i = r(this, Dn)) == null || i.remove(), x(this, Dn, null);
  }
  _scrollUpdate() {
    this.pagesCount !== 0 && this.update();
  }
  pageLabelToPageNumber(n) {
    if (!this._pageLabels)
      return null;
    const i = this._pageLabels.indexOf(n);
    return i < 0 ? null : i + 1;
  }
  scrollPageIntoView({
    pageNumber: n,
    destArray: i = null,
    allowNegativeOffset: l = !1,
    ignoreDestinationZoom: d = !1
  }) {
    if (!this.pdfDocument)
      return;
    const f = Number.isInteger(n) && this._pages[n - 1];
    if (!f) {
      console.error(`scrollPageIntoView: "${n}" is not a valid pageNumber parameter.`);
      return;
    }
    if (this.isInPresentationMode || !i) {
      this._setCurrentPageNumber(n, !0);
      return;
    }
    let m = 0, y = 0, w = 0, P = 0, I, L;
    const _ = f.rotation % 180 !== 0, D = (_ ? f.height : f.width) / f.scale / _i.PDF_TO_CSS_UNITS, k = (_ ? f.width : f.height) / f.scale / _i.PDF_TO_CSS_UNITS;
    let H = 0;
    switch (i[1].name) {
      case "XYZ":
        m = i[2], y = i[3], H = i[4], m = m !== null ? m : 0, y = y !== null ? y : k;
        break;
      case "Fit":
      case "FitB":
        H = "page-fit";
        break;
      case "FitH":
      case "FitBH":
        y = i[2], H = "page-width", y === null && this._location ? (m = this._location.left, y = this._location.top) : (typeof y != "number" || y < 0) && (y = k);
        break;
      case "FitV":
      case "FitBV":
        m = i[2], w = D, P = k, H = "page-height";
        break;
      case "FitR":
        m = i[2], y = i[3], w = i[4] - m, P = i[5] - y;
        let V = py, Z = gy;
        this.removePageBorders && (V = Z = 0), I = (this.container.clientWidth - V) / w / _i.PDF_TO_CSS_UNITS, L = (this.container.clientHeight - Z) / P / _i.PDF_TO_CSS_UNITS, H = Math.min(Math.abs(I), Math.abs(L));
        break;
      default:
        console.error(`scrollPageIntoView: "${i[1].name}" is not a valid destination type.`);
        return;
    }
    if (d || (H && H !== this._currentScale ? this.currentScaleValue = H : this._currentScale === km && (this.currentScaleValue = cS)), H === "page-fit" && !i[4]) {
      E(this, Pl, lg).call(this, f);
      return;
    }
    const X = [f.viewport.convertToViewportPoint(m, y), f.viewport.convertToViewportPoint(m + w, y + P)];
    let N = Math.min(X[0][0], X[1][0]), z = Math.min(X[0][1], X[1][1]);
    l || (N = Math.max(N, 0), z = Math.max(z, 0)), E(this, Pl, lg).call(this, f, {
      left: N,
      top: z
    });
  }
  _updateLocation(n) {
    const i = this._currentScale, l = this._currentScaleValue, d = parseFloat(l) === i ? Math.round(i * 1e4) / 100 : l, f = n.id, m = this._pages[f - 1], y = this.container, w = m.getPagePoint(y.scrollLeft - n.x, y.scrollTop - n.y), P = Math.round(w[0]), I = Math.round(w[1]);
    let L = `#page=${f}`;
    this.isInPresentationMode || (L += `&zoom=${d},${P},${I}`), this._location = {
      pageNumber: f,
      scale: d,
      top: I,
      left: P,
      rotation: this._pagesRotation,
      pdfOpenParams: L
    };
  }
  update() {
    const n = this._getVisiblePages(), i = n.views, l = i.length;
    if (l === 0)
      return;
    const d = Math.max(Uy, 2 * l + 1);
    r(this, kn).resize(d, n.ids), this.renderingQueue.renderHighestPriority(n);
    const f = this._spreadMode === we.NONE && (this._scrollMode === xt.PAGE || this._scrollMode === xt.VERTICAL), m = this._currentPageNumber;
    let y = !1;
    for (const w of i) {
      if (w.percent < 100)
        break;
      if (w.id === m && f) {
        y = !0;
        break;
      }
    }
    this._setCurrentPageNumber(y ? m : i[0].id), this._updateLocation(n.first), this.eventBus.dispatch("updateviewarea", {
      source: this,
      location: this._location
    });
  }
  containsElement(n) {
    return this.container.contains(n);
  }
  focus() {
    this.container.focus();
  }
  get _isContainerRtl() {
    return getComputedStyle(this.container).direction === "rtl";
  }
  get isInPresentationMode() {
    return this.presentationModeState === rl.FULLSCREEN;
  }
  get isChangingPresentationMode() {
    return this.presentationModeState === rl.CHANGING;
  }
  get isHorizontalScrollbarEnabled() {
    return this.isInPresentationMode ? !1 : this.container.scrollWidth > this.container.clientWidth;
  }
  get isVerticalScrollbarEnabled() {
    return this.isInPresentationMode ? !1 : this.container.scrollHeight > this.container.clientHeight;
  }
  _getVisiblePages() {
    const n = this._scrollMode === xt.PAGE ? r(this, xa).pages : this._pages, i = this._scrollMode === xt.HORIZONTAL, l = i && this._isContainerRtl;
    return vS({
      scrollEl: this.container,
      views: n,
      sortByVisibility: !0,
      horizontal: i,
      rtl: l
    });
  }
  cleanup() {
    for (const n of this._pages)
      n.renderingState !== Kt.FINISHED && n.reset();
  }
  _cancelRendering() {
    for (const n of this._pages)
      n.cancelRendering();
  }
  forceRendering(n) {
    const i = n || this._getVisiblePages(), l = E(this, Qg, a0).call(this, i), d = this._spreadMode !== we.NONE && this._scrollMode !== xt.HORIZONTAL, f = this.renderingQueue.getHighestPriority(i, this._pages, l, d);
    return f ? (E(this, Yg, r0).call(this, f).then(() => {
      this.renderingQueue.renderView(f);
    }), !0) : !1;
  }
  get hasEqualPageSizes() {
    const n = this._pages[0];
    for (let i = 1, l = this._pages.length; i < l; ++i) {
      const d = this._pages[i];
      if (d.width !== n.width || d.height !== n.height)
        return !1;
    }
    return !0;
  }
  getPagesOverview() {
    let n;
    return this._pages.map((i) => {
      const l = i.pdfPage.getViewport({
        scale: 1
      }), d = by(l);
      if (n === void 0)
        n = d;
      else if (this.enablePrintAutoRotate && d !== n)
        return {
          width: l.height,
          height: l.width,
          rotation: (l.rotation - 90) % 360
        };
      return {
        width: l.width,
        height: l.height,
        rotation: l.rotation
      };
    });
  }
  get optionalContentConfigPromise() {
    return this.pdfDocument ? this._optionalContentConfigPromise ? this._optionalContentConfigPromise : (console.error("optionalContentConfigPromise: Not initialized yet."), this.pdfDocument.getOptionalContentConfig({
      intent: "display"
    })) : Promise.resolve(null);
  }
  set optionalContentConfigPromise(n) {
    if (!(n instanceof Promise))
      throw new Error(`Invalid optionalContentConfigPromise: ${n}`);
    this.pdfDocument && this._optionalContentConfigPromise && (this._optionalContentConfigPromise = n, this.refresh(!1, {
      optionalContentConfigPromise: n
    }), this.eventBus.dispatch("optionalcontentconfigchanged", {
      source: this,
      promise: n
    }));
  }
  get scrollMode() {
    return this._scrollMode;
  }
  set scrollMode(n) {
    if (this._scrollMode !== n) {
      if (!bS(n))
        throw new Error(`Invalid scroll mode: ${n}`);
      this.pagesCount > Ip.FORCE_SCROLL_MODE_PAGE || (this._previousScrollMode = this._scrollMode, this._scrollMode = n, this.eventBus.dispatch("scrollmodechanged", {
        source: this,
        mode: n
      }), this._updateScrollMode(this._currentPageNumber));
    }
  }
  _updateScrollMode(n = null) {
    const i = this._scrollMode, l = this.viewer;
    l.classList.toggle("scrollHorizontal", i === xt.HORIZONTAL), l.classList.toggle("scrollWrapped", i === xt.WRAPPED), !(!this.pdfDocument || !n) && (i === xt.PAGE ? E(this, Pa, Ld).call(this) : this._previousScrollMode === xt.PAGE && this._updateSpreadMode(), this._currentScaleValue && isNaN(this._currentScaleValue) && E(this, zs, En).call(this, this._currentScaleValue, {
      noScroll: !0
    }), this._setCurrentPageNumber(n, !0), this.update());
  }
  get spreadMode() {
    return this._spreadMode;
  }
  set spreadMode(n) {
    if (this._spreadMode !== n) {
      if (!yS(n))
        throw new Error(`Invalid spread mode: ${n}`);
      this._spreadMode = n, this.eventBus.dispatch("spreadmodechanged", {
        source: this,
        mode: n
      }), this._updateSpreadMode(this._currentPageNumber);
    }
  }
  _updateSpreadMode(n = null) {
    if (!this.pdfDocument)
      return;
    const i = this.viewer, l = this._pages;
    if (this._scrollMode === xt.PAGE)
      E(this, Pa, Ld).call(this);
    else if (i.textContent = "", this._spreadMode === we.NONE)
      for (const d of this._pages)
        i.append(d.div);
    else {
      const d = this._spreadMode - 1;
      let f = null;
      for (let m = 0, y = l.length; m < y; ++m)
        f === null ? (f = document.createElement("div"), f.className = "spread", i.append(f)) : m % 2 === d && (f = f.cloneNode(!1), i.append(f)), f.append(l[m].div);
    }
    n && (this._currentScaleValue && isNaN(this._currentScaleValue) && E(this, zs, En).call(this, this._currentScaleValue, {
      noScroll: !0
    }), this._setCurrentPageNumber(n, !0), this.update());
  }
  _getPageAdvance(n, i = !1) {
    switch (this._scrollMode) {
      case xt.WRAPPED: {
        const {
          views: l
        } = this._getVisiblePages(), d = /* @__PURE__ */ new Map();
        for (const {
          id: f,
          y: m,
          percent: y,
          widthPercent: w
        } of l) {
          if (y === 0 || w < 100)
            continue;
          let P = d.get(m);
          P || d.set(m, P || (P = [])), P.push(f);
        }
        for (const f of d.values()) {
          const m = f.indexOf(n);
          if (m === -1)
            continue;
          const y = f.length;
          if (y === 1)
            break;
          if (i)
            for (let w = m - 1, P = 0; w >= P; w--) {
              const I = f[w], L = f[w + 1] - 1;
              if (I < L)
                return n - L;
            }
          else
            for (let w = m + 1, P = y; w < P; w++) {
              const I = f[w], L = f[w - 1] + 1;
              if (I > L)
                return L - n;
            }
          if (i) {
            const w = f[0];
            if (w < n)
              return n - w + 1;
          } else {
            const w = f[y - 1];
            if (w > n)
              return w - n + 1;
          }
          break;
        }
        break;
      }
      case xt.HORIZONTAL:
        break;
      case xt.PAGE:
      case xt.VERTICAL: {
        if (this._spreadMode === we.NONE)
          break;
        const l = this._spreadMode - 1;
        if (i && n % 2 !== l)
          break;
        if (!i && n % 2 === l)
          break;
        const {
          views: d
        } = this._getVisiblePages(), f = i ? n - 1 : n + 1;
        for (const {
          id: m,
          percent: y,
          widthPercent: w
        } of d)
          if (m === f) {
            if (y > 0 && w === 100)
              return 2;
            break;
          }
        break;
      }
    }
    return 1;
  }
  nextPage() {
    const n = this._currentPageNumber, i = this.pagesCount;
    if (n >= i)
      return !1;
    const l = this._getPageAdvance(n, !1) || 1;
    return this.currentPageNumber = Math.min(n + l, i), !0;
  }
  previousPage() {
    const n = this._currentPageNumber;
    if (n <= 1)
      return !1;
    const i = this._getPageAdvance(n, !0) || 1;
    return this.currentPageNumber = Math.max(n - i, 1), !0;
  }
  updateScale({
    drawingDelay: n,
    scaleFactor: i = null,
    steps: l = null,
    origin: d
  }) {
    if (l === null && i === null)
      throw new Error("Invalid updateScale options: either `steps` or `scaleFactor` must be provided.");
    if (!this.pdfDocument)
      return;
    let f = this._currentScale;
    if (i > 0 && i !== 1)
      f = Math.round(f * i * 100) / 100;
    else if (l) {
      const m = l > 0 ? fy : 1 / fy, y = l > 0 ? Math.ceil : Math.floor;
      l = Math.abs(l);
      do
        f = y((f * m).toFixed(2) * 10) / 10;
      while (--l > 0);
    }
    f = Math.max(dS, Math.min(uS, f)), E(this, zs, En).call(this, f, {
      noScroll: !1,
      drawingDelay: n,
      origin: d
    });
  }
  increaseScale(n = {}) {
    this.updateScale({
      ...n,
      steps: n.steps ?? 1
    });
  }
  decreaseScale(n = {}) {
    this.updateScale({
      ...n,
      steps: -(n.steps ?? 1)
    });
  }
  get containerTopLeft() {
    return r(this, yu) || x(this, yu, [this.container.offsetTop, this.container.offsetLeft]);
  }
  get annotationEditorMode() {
    return r(this, Ee) ? r(this, Fi) : wn.DISABLE;
  }
  set annotationEditorMode({
    mode: n,
    editId: i = null,
    isFromKeyboard: l = !1
  }) {
    if (!r(this, Ee))
      throw new Error("The AnnotationEditor is not enabled.");
    if (r(this, Fi) !== n) {
      if (!zy(n))
        throw new Error(`Invalid AnnotationEditor mode: ${n}`);
      this.pdfDocument && (x(this, Fi, n), this.eventBus.dispatch("annotationeditormodechanged", {
        source: this,
        mode: n
      }), r(this, Ee).updateMode(n, i, l));
    }
  }
  set annotationEditorParams({
    type: n,
    value: i
  }) {
    if (!r(this, Ee))
      throw new Error("The AnnotationEditor is not enabled.");
    r(this, Ee).updateParams(n, i);
  }
  refresh(n = !1, i = /* @__PURE__ */ Object.create(null)) {
    if (this.pdfDocument) {
      for (const l of this._pages)
        l.update(i);
      r(this, Nn) !== null && (clearTimeout(r(this, Nn)), x(this, Nn, null)), n || this.update();
    }
  }
}
kn = new WeakMap(), vu = new WeakMap(), bu = new WeakMap(), Fi = new WeakMap(), Ee = new WeakMap(), wa = new WeakMap(), yu = new WeakMap(), Au = new WeakMap(), Eu = new WeakMap(), Sa = new WeakMap(), wu = new WeakMap(), wl = new WeakMap(), Dn = new WeakMap(), Sl = new WeakMap(), Su = new WeakMap(), Ug = new WeakMap(), xa = new WeakMap(), Nn = new WeakMap(), xl = new WeakMap(), zg = new WeakSet(), t0 = function(n) {
  const i = {
    annotationEditorMode: r(this, Fi),
    annotationMode: r(this, wa),
    textLayerMode: r(this, xl)
  };
  return n && (!n.includes(Cp.COPY) && r(this, xl) === Ws.ENABLE && (i.textLayerMode = Ws.ENABLE_PERMISSIONS), n.includes(Cp.MODIFY_CONTENTS) || (i.annotationEditorMode = wn.DISABLE), !n.includes(Cp.MODIFY_ANNOTATIONS) && !n.includes(Cp.FILL_INTERACTIVE_FORMS) && r(this, wa) === Bi.ENABLE_FORMS && (i.annotationMode = Bi.ENABLE)), i;
}, Wg = new WeakSet(), e0 = async function(n) {
  if (document.visibilityState === "hidden" || !this.container.offsetParent || this._getVisiblePages().views.length === 0)
    return;
  const i = Promise.withResolvers();
  function l() {
    document.visibilityState === "hidden" && i.resolve();
  }
  document.addEventListener("visibilitychange", l, {
    signal: n
  }), await Promise.race([this._onePageRenderedCapability.promise, i.promise]), document.removeEventListener("visibilitychange", l);
}, Gg = new WeakSet(), s0 = function(n, i) {
  const l = document.getSelection(), {
    focusNode: d,
    anchorNode: f
  } = l;
  if (f && d && l.containsNode(r(this, Dn))) {
    if (r(this, wl) || n === Ws.ENABLE_PERMISSIONS) {
      i.preventDefault(), i.stopPropagation();
      return;
    }
    x(this, wl, !0);
    const m = this.container.style.cursor;
    this.container.style.cursor = "wait";
    const y = (w) => x(this, Sl, w.key === "Escape");
    window.addEventListener("keydown", y), this.getAllText().then(async (w) => {
      w !== null && await navigator.clipboard.writeText(w);
    }).catch((w) => {
      console.warn(`Something goes wrong when extracting the text: ${w.message}`);
    }).finally(() => {
      x(this, wl, !1), x(this, Sl, !1), window.removeEventListener("keydown", y), this.container.style.cursor = m;
    }), i.preventDefault(), i.stopPropagation();
  }
}, Pa = new WeakSet(), Ld = function() {
  if (this._scrollMode !== xt.PAGE)
    throw new Error("#ensurePageViewVisible: Invalid scrollMode value.");
  const n = this._currentPageNumber, i = r(this, xa), l = this.viewer;
  if (l.textContent = "", i.pages.length = 0, this._spreadMode === we.NONE && !this.isInPresentationMode) {
    const d = this._pages[n - 1];
    l.append(d.div), i.pages.push(d);
  } else {
    const d = /* @__PURE__ */ new Set(), f = this._spreadMode - 1;
    f === -1 ? d.add(n - 1) : n % 2 !== f ? (d.add(n - 1), d.add(n)) : (d.add(n - 2), d.add(n - 1));
    const m = document.createElement("div");
    if (m.className = "spread", this.isInPresentationMode) {
      const y = document.createElement("div");
      y.className = "dummyPage", m.append(y);
    }
    for (const y of d) {
      const w = this._pages[y];
      w && (m.append(w.div), i.pages.push(w));
    }
    l.append(m);
  }
  i.scrollDown = n >= i.previousPageNumber, i.previousPageNumber = n;
}, Pl = new WeakSet(), lg = function(n, i = null) {
  const {
    div: l,
    id: d
  } = n;
  if (this._currentPageNumber !== d && this._setCurrentPageNumber(d), this._scrollMode === xt.PAGE && (E(this, Pa, Ld).call(this), this.update()), !i && !this.isInPresentationMode) {
    const f = l.offsetLeft + l.clientLeft, m = f + l.clientWidth, {
      scrollLeft: y,
      clientWidth: w
    } = this.container;
    (this._scrollMode === xt.HORIZONTAL || f < y || m > y + w) && (i = {
      left: 0,
      top: 0
    });
  }
  mE(l, i), !this._currentScaleValue && this._location && (this._location = null);
}, Xg = new WeakSet(), i0 = function(n) {
  return n === this._currentScale || Math.abs(n - this._currentScale) < 1e-15;
}, xu = new WeakSet(), pb = function(n, i, {
  noScroll: l = !1,
  preset: d = !1,
  drawingDelay: f = -1,
  origin: m = null
}) {
  if (this._currentScaleValue = i.toString(), E(this, Xg, i0).call(this, n)) {
    d && this.eventBus.dispatch("scalechanging", {
      source: this,
      scale: n,
      presetValue: i
    });
    return;
  }
  this.viewer.style.setProperty("--scale-factor", n * _i.PDF_TO_CSS_UNITS);
  const y = f >= 0 && f < 1e3;
  this.refresh(!0, {
    scale: n,
    drawingDelay: y ? f : -1
  }), y && x(this, Nn, setTimeout(() => {
    x(this, Nn, null), this.refresh();
  }, f));
  const w = this._currentScale;
  if (this._currentScale = n, !l) {
    let P = this._currentPageNumber, I;
    if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode) && (P = this._location.pageNumber, I = [null, {
      name: "XYZ"
    }, this._location.left, this._location.top, null]), this.scrollPageIntoView({
      pageNumber: P,
      destArray: I,
      allowNegativeOffset: !0
    }), Array.isArray(m)) {
      const L = n / w - 1, [_, D] = this.containerTopLeft;
      this.container.scrollLeft += (m[0] - D) * L, this.container.scrollTop += (m[1] - _) * L;
    }
  }
  this.eventBus.dispatch("scalechanging", {
    source: this,
    scale: n,
    presetValue: d ? i : void 0
  }), this.defaultRenderingQueue && this.update();
}, Kg = new WeakSet(), n0 = function() {
  return this._spreadMode !== we.NONE && this._scrollMode !== xt.HORIZONTAL ? 2 : 1;
}, zs = new WeakSet(), En = function(n, i) {
  let l = parseFloat(n);
  if (l > 0)
    i.preset = !1, E(this, xu, pb).call(this, l, n, i);
  else {
    const d = this._pages[this._currentPageNumber - 1];
    if (!d)
      return;
    let f = py, m = gy;
    this.isInPresentationMode ? (f = m = 4, this._spreadMode !== we.NONE && (f *= 2)) : this.removePageBorders ? f = m = 0 : this._scrollMode === xt.HORIZONTAL && ([f, m] = [m, f]);
    const y = (this.container.clientWidth - f) / d.width * d.scale / r(this, Kg, n0), w = (this.container.clientHeight - m) / d.height * d.scale;
    switch (n) {
      case "page-actual":
        l = 1;
        break;
      case "page-width":
        l = y;
        break;
      case "page-height":
        l = w;
        break;
      case "page-fit":
        l = Math.min(y, w);
        break;
      case "auto":
        const P = by(d) ? y : Math.min(w, y);
        l = Math.min(fS, P);
        break;
      default:
        console.error(`#setScale: "${n}" is an unknown zoom value.`);
        return;
    }
    i.preset = !0, E(this, xu, pb).call(this, l, n, i);
  }
}, Pu = new WeakSet(), gb = function() {
  const n = this._pages[this._currentPageNumber - 1];
  this.isInPresentationMode && E(this, zs, En).call(this, this._currentScaleValue, {
    noScroll: !0
  }), E(this, Pl, lg).call(this, n);
}, Yg = new WeakSet(), r0 = async function(n) {
  if (n.pdfPage)
    return n.pdfPage;
  try {
    const i = await this.pdfDocument.getPage(n.id);
    return n.pdfPage || n.setPdfPage(i), i;
  } catch (i) {
    return console.error("Unable to get page for page view", i), null;
  }
}, Qg = new WeakSet(), a0 = function(n) {
  var i, l;
  if (((i = n.first) == null ? void 0 : i.id) === 1)
    return !0;
  if (((l = n.last) == null ? void 0 : l.id) === this.pagesCount)
    return !1;
  switch (this._scrollMode) {
    case xt.PAGE:
      return r(this, xa).scrollDown;
    case xt.HORIZONTAL:
      return this.scroll.right;
  }
  return this.scroll.down;
}, Tu = new WeakSet(), mb = function(n = this.container.clientHeight) {
  n !== r(this, Su) && (x(this, Su, n), AS.setProperty("--viewer-container-height", `${n}px`));
}, Zg = new WeakSet(), o0 = function(n) {
  for (const i of n)
    if (i.target === this.container) {
      E(this, Tu, mb).call(this, Math.floor(i.borderBoxSize[0].blockSize)), x(this, yu, null);
      break;
    }
};
class bP extends qE {
  _resetView() {
    super._resetView(), this._scrollMode = xt.PAGE, this._spreadMode = we.NONE;
  }
  set scrollMode(n) {
  }
  _updateScrollMode() {
  }
  set spreadMode(n) {
  }
  _updateSpreadMode() {
  }
}
Gt.AnnotationLayerBuilder;
Gt.DownloadManager;
Gt.EventBus;
Gt.FindState;
Gt.GenericL10n;
Gt.LinkTarget;
Gt.PDFFindController;
Gt.PDFHistory;
var yP = Gt.PDFLinkService;
Gt.PDFPageView;
Gt.PDFScriptingManager;
Gt.PDFSinglePageViewer;
Gt.PDFViewer;
Gt.ProgressBar;
Gt.RenderingStates;
Gt.ScrollMode;
Gt.SimpleLinkService;
Gt.SpreadMode;
Gt.StructTreeLayerBuilder;
Gt.TextLayerBuilder;
Gt.XfaLayerBuilder;
Gt.parseQueryString;
function AP(u, n, i) {
  const l = u.contentWindow.document.createElement("style");
  l.textContent = `
    @page {
      margin: 3mm;
      size: ${n}pt ${i}pt;
    }
    body {
      margin: 0;
    }
    canvas {
      width: 100%;
      page-break-after: always;
      page-break-before: avoid;
      page-break-inside: avoid;
    }
  `, u.contentWindow.document.head.appendChild(l), u.contentWindow.document.body.style.width = "100%";
}
function EP(u) {
  return new Promise((n) => {
    const i = document.createElement("iframe");
    i.width = "0", i.height = "0", i.style.position = "absolute", i.style.top = "0", i.style.left = "0", i.style.border = "none", i.style.overflow = "hidden", i.onload = () => n(i), u.appendChild(i);
  });
}
function wP(u, n) {
  const i = URL.createObjectURL(
    new Blob([u], {
      type: "application/pdf"
    })
  ), l = document.createElement("a");
  l.href = i, l.download = n, l.style.display = "none", document.body.append(l), l.click(), setTimeout(() => {
    URL.revokeObjectURL(i), document.body.removeChild(l);
  }, 1e3);
}
function Wy(u) {
  for (; u != null && u.firstChild; )
    u.removeChild(u.firstChild);
}
function Um(u) {
  u == null || u.querySelectorAll("canvas").forEach((n) => {
    var i;
    n.width = 1, n.height = 1, (i = n.getContext("2d")) == null || i.clearRect(0, 0, 1, 1);
  });
}
const SP = ["id"], xP = ["id"], PP = /* @__PURE__ */ Yy("canvas", null, null, -1), TP = {
  key: 0,
  class: "textLayer"
}, CP = {
  key: 1,
  class: "annotationLayer"
}, uT = /* @__PURE__ */ Zw({
  __name: "VuePdfEmbed",
  props: {
    annotationLayer: { type: Boolean },
    height: {},
    id: {},
    imageResourcesPath: {},
    page: {},
    rotation: { default: 0 },
    scale: { default: 1 },
    source: {},
    textLayer: { type: Boolean },
    width: {}
  },
  emits: ["internal-link-clicked", "loaded", "loading-failed", "password-requested", "progress", "rendered", "rendering-failed"],
  setup(u, { expose: n, emit: i }) {
    const l = u, d = Md([]), f = Md([]), m = Jw([]), y = Md(null), { doc: w } = hS({
      onError: (N) => {
        d.value = [], i("loading-failed", N);
      },
      onPasswordRequest({ callback: N, isWrongPassword: z }) {
        i("password-requested", { callback: N, isWrongPassword: z });
      },
      onProgress: (N) => {
        i("progress", N);
      },
      source: qw(l, "source")
    }), P = tS(() => {
      if (!w.value || !l.annotationLayer)
        return null;
      const N = new yP();
      return N.setDocument(w.value), N.setViewer({
        scrollPageIntoView: ({ pageNumber: z }) => {
          i("internal-link-clicked", z);
        }
      }), N;
    }), I = async (N) => {
      if (!w.value)
        return;
      const z = await w.value.getData(), V = await w.value.getMetadata(), Z = (
        // @ts-expect-error: contentDispositionFilename is not typed
        N ?? V.contentDispositionFilename ?? ""
      );
      wP(z, Z);
    }, L = (N) => {
      let z, V;
      return l.height && !l.width ? (V = l.height, z = V / N) : (z = l.width ?? y.value.clientWidth, V = z * N), [z, V];
    }, _ = async (N = 300, z = "", V = !1) => {
      var B, G, q;
      if (!w.value)
        return;
      const Z = N / 72, K = 96 / 72;
      let $, j, Q;
      try {
        $ = window.document.createElement("div"), $.style.display = "none", window.document.body.appendChild($), j = await EP($);
        const tt = l.page && !V ? [l.page] : [...Array(w.value.numPages + 1).keys()].slice(1);
        await Promise.all(
          tt.map(async (lt, vt) => {
            const dt = await w.value.getPage(lt), W = dt.getViewport({
              scale: 1,
              rotation: 0
            });
            if (vt === 0) {
              const Ht = W.width * Z / K, Ft = W.height * Z / K;
              AP(j, Ht, Ft);
            }
            const Et = window.document.createElement("canvas");
            Et.width = W.width * Z, Et.height = W.height * Z, $.appendChild(Et);
            const Pt = Et.cloneNode();
            j.contentWindow.document.body.appendChild(Pt), await dt.render({
              canvasContext: Et.getContext("2d"),
              intent: "print",
              transform: [Z, 0, 0, Z, 0, 0],
              viewport: W
            }).promise, Pt.getContext("2d").drawImage(Et, 0, 0);
          })
        ), z && (Q = window.document.title, window.document.title = z), (B = j.contentWindow) == null || B.focus(), (G = j.contentWindow) == null || G.print();
      } finally {
        Q && (window.document.title = Q), Um($), (q = $.parentNode) == null || q.removeChild($);
      }
    }, D = async () => {
      if (w.value)
        try {
          d.value = l.page ? [l.page] : [...Array(w.value.numPages + 1).keys()].slice(1), m.value = Array(d.value.length).fill(1), await Promise.all(
            d.value.map(async (N, z) => {
              const V = await w.value.getPage(N), Z = ((l.rotation % 90 === 0 ? l.rotation : 0) + V.rotate) % 360, [K, $, j] = Array.from(f.value[z].children), Q = !!(Z / 90 % 2), [B, G] = L(
                Q ? V.view[2] / V.view[3] : V.view[3] / V.view[2]
              ), q = `${Math.floor(B)}px`, tt = `${Math.floor(G)}px`, lt = Q ? V.view[3] : V.view[2], vt = B / lt, dt = V.getViewport({
                scale: vt,
                rotation: Z
              });
              m.value[z] = vt, K.style.width = q, K.style.height = tt, $ && ($.style.width = Q ? tt : q, $.style.height = Q ? q : tt), j && (j.style.width = Q ? tt : q, j.style.height = Q ? q : tt), await k(
                V,
                dt.clone({
                  scale: dt.scale * window.devicePixelRatio * l.scale
                }),
                K
              ), l.textLayer && await X(
                V,
                dt.clone({
                  dontFlip: !0
                }),
                $
              ), l.annotationLayer && await H(
                V,
                dt.clone({
                  dontFlip: !0
                }),
                j || $
              );
            })
          ), i("rendered");
        } catch (N) {
          d.value = [], m.value = [], i("rendering-failed", N);
        }
    }, k = async (N, z, V) => {
      V.width = z.width, V.height = z.height, await N.render({
        canvasContext: V.getContext("2d"),
        viewport: z
      }).promise;
    }, H = async (N, z, V) => {
      Wy(V), new rS({
        accessibilityManager: null,
        annotationCanvasMap: null,
        annotationEditorUIManager: null,
        div: V,
        page: N,
        viewport: z
      }).render({
        annotations: await N.getAnnotations(),
        div: V,
        imageResourcesPath: l.imageResourcesPath,
        linkService: P.value,
        page: N,
        renderForms: !1,
        viewport: z
      });
    }, X = async (N, z, V) => {
      Wy(V), new oS({
        container: V,
        textContentSource: await N.getTextContent(),
        viewport: z
      }).render();
    };
    return Om(
      w,
      () => {
        w.value && i("loaded", w.value);
      },
      { immediate: !0 }
    ), Om(
      () => l.source,
      () => {
        Um(y.value);
      }
    ), Om(
      () => [
        w.value,
        l.annotationLayer,
        l.height,
        l.imageResourcesPath,
        l.page,
        l.rotation,
        l.scale,
        l.textLayer,
        l.width
      ],
      () => {
        w.value && D();
      },
      { immediate: !0 }
    ), Ky(() => {
      Um(y.value);
    }), n({
      doc: w,
      download: I,
      print: _
    }), (N, z) => (od(), ld("div", {
      id: N.id,
      ref_key: "root",
      ref: y,
      class: "vue-pdf-embed"
    }, [
      (od(!0), ld(eS, null, sS(d.value, (V, Z) => (od(), ld("div", { key: V }, [
        cy(N.$slots, "before-page", { page: V }),
        Yy("div", {
          id: N.id && `${N.id}-${V}`,
          ref_for: !0,
          ref_key: "pageRefs",
          ref: f,
          class: "vue-pdf-embed__page",
          style: iS({
            "--scale-factor": m.value[Z]
          })
        }, [
          PP,
          N.textLayer ? (od(), ld("div", TP)) : dy("", !0),
          N.annotationLayer ? (od(), ld("div", CP)) : dy("", !0)
        ], 12, xP),
        cy(N.$slots, "after-page", { page: V })
      ]))), 128))
    ], 8, SP));
  }
});
const RP = {}, cd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, default: RP }, Symbol.toStringTag, { value: "Module" }));
var dd = {
  a: 7,
  c: 6,
  h: 1,
  l: 2,
  m: 2,
  q: 4,
  s: 4,
  t: 2,
  v: 1,
  z: 0
}, IP = /([astvzqmhlc])([^astvzqmhlc]*)/gi, LP = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi;
function _P(u) {
  const n = u.match(LP);
  return n ? n.map(Number) : [];
}
function l0(u) {
  const n = [], i = String(u).trim();
  return i[0] !== "M" && i[0] !== "m" || i.replace(IP, (l, d, f) => {
    const m = _P(f);
    let y = d.toLowerCase(), w = d;
    if (y === "m" && m.length > 2 && (n.push([w, ...m.splice(0, 2)]), y = "l", w = w === "m" ? "l" : "L"), m.length < dd[y])
      return "";
    for (n.push([w, ...m.splice(0, dd[y])]); m.length >= dd[y] && m.length && dd[y]; )
      n.push([w, ...m.splice(0, dd[y])]);
    return "";
  }), n;
}
function Gy(u, n) {
  const i = u.x * Math.cos(n) - u.y * Math.sin(n), l = u.y * Math.cos(n) + u.x * Math.sin(n);
  u.x = i, u.y = l;
}
function MP(u, n, i) {
  u.x += n, u.y += i;
}
function Xy(u, n) {
  u.x *= n, u.y *= n;
}
var hg = class vb {
  constructor(n) {
    this.commands = [], n && n instanceof vb ? this.commands.push(...n.commands) : n && (this.commands = l0(n));
  }
  addPath(n) {
    n && n instanceof vb && this.commands.push(...n.commands);
  }
  moveTo(n, i) {
    this.commands.push(["M", n, i]);
  }
  lineTo(n, i) {
    this.commands.push(["L", n, i]);
  }
  arc(n, i, l, d, f, m) {
    this.commands.push(["AC", n, i, l, d, f, !!m]);
  }
  arcTo(n, i, l, d, f) {
    this.commands.push(["AT", n, i, l, d, f]);
  }
  ellipse(n, i, l, d, f, m, y, w) {
    this.commands.push(["E", n, i, l, d, f, m, y, !!w]);
  }
  closePath() {
    this.commands.push(["Z"]);
  }
  bezierCurveTo(n, i, l, d, f, m) {
    this.commands.push(["C", n, i, l, d, f, m]);
  }
  quadraticCurveTo(n, i, l, d) {
    this.commands.push(["Q", n, i, l, d]);
  }
  rect(n, i, l, d) {
    this.commands.push(["R", n, i, l, d]);
  }
  roundRect(n, i, l, d, f) {
    typeof f > "u" ? this.commands.push(["RR", n, i, l, d, 0]) : this.commands.push(["RR", n, i, l, d, f]);
  }
};
function _d(u, n) {
  let i = 0, l = 0, d, f, m, y, w, P, I, L, _, D, k, H, X, N, z, V, Z, K, $, j, Q, B = null, G = null, q = null, tt = null, lt = null, vt = null;
  u.beginPath();
  for (let dt = 0; dt < n.length; ++dt) {
    K = n[dt][0], K !== "S" && K !== "s" && K !== "C" && K !== "c" && (B = null, G = null), K !== "T" && K !== "t" && K !== "Q" && K !== "q" && (q = null, tt = null);
    let W;
    switch (K) {
      case "m":
      case "M":
        W = n[dt], K === "m" ? (i += W[1], l += W[2]) : (i = W[1], l = W[2]), (K === "M" || !lt) && (lt = { x: i, y: l }), u.moveTo(i, l);
        break;
      case "l":
        W = n[dt], i += W[1], l += W[2], u.lineTo(i, l);
        break;
      case "L":
        W = n[dt], i = W[1], l = W[2], u.lineTo(i, l);
        break;
      case "H":
        W = n[dt], i = W[1], u.lineTo(i, l);
        break;
      case "h":
        W = n[dt], i += W[1], u.lineTo(i, l);
        break;
      case "V":
        W = n[dt], l = W[1], u.lineTo(i, l);
        break;
      case "v":
        W = n[dt], l += W[1], u.lineTo(i, l);
        break;
      case "a":
      case "A":
        if (W = n[dt], vt === null)
          throw new Error("This should never happen");
        K === "a" ? (i += W[6], l += W[7]) : (i = W[6], l = W[7]), N = W[1], z = W[2], I = W[3] * Math.PI / 180, m = !!W[4], y = !!W[5], w = { x: i, y: l }, P = {
          x: (vt.x - w.x) / 2,
          y: (vt.y - w.y) / 2
        }, Gy(P, -I), L = P.x * P.x / (N * N) + P.y * P.y / (z * z), L > 1 && (L = Math.sqrt(L), N *= L, z *= L), $ = {
          x: N * P.y / z,
          y: -(z * P.x) / N
        }, _ = N * N * z * z, D = N * N * P.y * P.y + z * z * P.x * P.x, y !== m ? Xy($, Math.sqrt((_ - D) / D) || 0) : Xy($, -Math.sqrt((_ - D) / D) || 0), f = Math.atan2((P.y - $.y) / z, (P.x - $.x) / N), d = Math.atan2(-(P.y + $.y) / z, -(P.x + $.x) / N), Gy($, I), MP($, (w.x + vt.x) / 2, (w.y + vt.y) / 2), u.save(), u.translate($.x, $.y), u.rotate(I), u.scale(N, z), u.arc(0, 0, 1, f, d, !y), u.restore();
        break;
      case "C":
        W = n[dt], B = W[3], G = W[4], i = W[5], l = W[6], u.bezierCurveTo(W[1], W[2], B, G, i, l);
        break;
      case "c":
        W = n[dt], u.bezierCurveTo(W[1] + i, W[2] + l, W[3] + i, W[4] + l, W[5] + i, W[6] + l), B = W[3] + i, G = W[4] + l, i += W[5], l += W[6];
        break;
      case "S":
        W = n[dt], (B === null || G === null) && (B = i, G = l), u.bezierCurveTo(2 * i - B, 2 * l - G, W[1], W[2], W[3], W[4]), B = W[1], G = W[2], i = W[3], l = W[4];
        break;
      case "s":
        W = n[dt], (B === null || G === null) && (B = i, G = l), u.bezierCurveTo(2 * i - B, 2 * l - G, W[1] + i, W[2] + l, W[3] + i, W[4] + l), B = W[1] + i, G = W[2] + l, i += W[3], l += W[4];
        break;
      case "Q":
        W = n[dt], q = W[1], tt = W[2], i = W[3], l = W[4], u.quadraticCurveTo(q, tt, i, l);
        break;
      case "q":
        W = n[dt], q = W[1] + i, tt = W[2] + l, i += W[3], l += W[4], u.quadraticCurveTo(q, tt, i, l);
        break;
      case "T":
        W = n[dt], (q === null || tt === null) && (q = i, tt = l), q = 2 * i - q, tt = 2 * l - tt, i = W[1], l = W[2], u.quadraticCurveTo(q, tt, i, l);
        break;
      case "t":
        W = n[dt], (q === null || tt === null) && (q = i, tt = l), q = 2 * i - q, tt = 2 * l - tt, i += W[1], l += W[2], u.quadraticCurveTo(q, tt, i, l);
        break;
      case "z":
      case "Z":
        lt && (i = lt.x, l = lt.y), lt = null, u.closePath();
        break;
      case "AC":
        W = n[dt], i = W[1], l = W[2], X = W[3], f = W[4], d = W[5], j = W[6], u.arc(i, l, X, f, d, j);
        break;
      case "AT":
        W = n[dt], k = W[1], H = W[2], i = W[3], l = W[4], X = W[5], u.arcTo(k, H, i, l, X);
        break;
      case "E":
        W = n[dt], i = W[1], l = W[2], N = W[3], z = W[4], I = W[5], f = W[6], d = W[7], j = W[8], u.save(), u.translate(i, l), u.rotate(I), u.scale(N, z), u.arc(0, 0, 1, f, d, j), u.restore();
        break;
      case "R":
        W = n[dt], i = W[1], l = W[2], V = W[3], Z = W[4], lt = { x: i, y: l }, u.rect(i, l, V, Z);
        break;
      case "RR":
        W = n[dt], i = W[1], l = W[2], V = W[3], Z = W[4], Q = W[5], lt = { x: i, y: l }, u.roundRect(i, l, V, Z, Q);
        break;
      default:
        throw new Error(`Invalid path command: ${K}`);
    }
    vt ? (vt.x = i, vt.y = l) : vt = { x: i, y: l };
  }
}
function Ab(u, n, i, l, d = 0) {
  if (typeof d == "number" && (d = [d]), Array.isArray(d)) {
    if (d.length === 0 || d.length > 4)
      throw new RangeError(
        `Failed to execute 'roundRect' on '${this.constructor.name}': ${d.length} radii provided. Between one and four radii are necessary.`
      );
    d.forEach((I) => {
      if (I < 0)
        throw new RangeError(
          `Failed to execute 'roundRect' on '${this.constructor.name}': Radius value ${I} is negative.`
        );
    });
  } else
    return;
  if (d.length === 1 && d[0] === 0) {
    this.rect(u, n, i, l);
    return;
  }
  const f = Math.min(i, l) / 2, m = Math.min(f, d[0]);
  let y = m, w = m, P = m;
  d.length === 2 && (y = Math.min(f, d[1]), P = y), d.length === 3 && (y = Math.min(f, d[1]), P = y, w = Math.min(f, d[2])), d.length === 4 && (y = Math.min(f, d[1]), w = Math.min(f, d[2]), P = Math.min(f, d[3])), this.moveTo(u, n + l - P), this.arcTo(u, n, u + m, n, m), this.arcTo(u + i, n, u + i, n + y, y), this.arcTo(u + i, n + l, u + i - w, n + l, w), this.arcTo(u, n + l, u, n + l - P, P), this.moveTo(u, n);
}
function OP(u) {
  if (!u)
    return;
  const n = u.prototype.clip, i = u.prototype.fill, l = u.prototype.stroke, d = u.prototype.isPointInPath;
  u.prototype.clip = function(...m) {
    if (m[0] instanceof hg) {
      const w = m[0], P = m[1] || "nonzero";
      return _d(this, w.commands), n.apply(this, [P]);
    }
    const y = m[0] || "nonzero";
    return n.apply(this, [y]);
  }, u.prototype.fill = function(...m) {
    if (m[0] instanceof hg) {
      const w = m[0], P = m[1] || "nonzero";
      return _d(this, w.commands), i.apply(this, [P]);
    }
    const y = m[0] || "nonzero";
    return i.apply(this, [y]);
  }, u.prototype.stroke = function(m) {
    m && _d(this, m.commands), l.apply(this);
  }, u.prototype.isPointInPath = function(...m) {
    if (m[0] instanceof hg) {
      const y = m[0], w = m[1], P = m[2], I = m[3] || "nonzero";
      return _d(this, y.commands), d.apply(this, [w, P, I]);
    }
    return d.apply(this, m);
  };
}
function kP(u) {
  u && !u.prototype.roundRect && (u.prototype.roundRect = Ab);
}
function DP(u) {
  u && !u.prototype.roundRect && (u.prototype.roundRect = Ab);
}
const NP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, Path2D: hg, applyPath2DToCanvasRenderingContext: OP, applyRoundRectToCanvasRenderingContext2D: kP, applyRoundRectToPath2D: DP, buildPath: _d, parsePath: l0, roundRect: Ab }, Symbol.toStringTag, { value: "Module" }));
export {
  jP as GlobalWorkerOptions,
  uT as default,
  hS as useVuePdfEmbed
};
