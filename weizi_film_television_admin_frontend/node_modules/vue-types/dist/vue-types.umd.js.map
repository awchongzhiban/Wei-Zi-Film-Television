{"version":3,"file":"vue-types.umd.js","sources":["../src/config.ts","../src/utils.ts","../src/sensibles.ts","../src/validators/native.ts","../src/validators/custom.ts","../src/validators/oneof.ts","../src/validators/oneoftype.ts","../src/validators/arrayof.ts","../src/validators/instanceof.ts","../src/validators/objectof.ts","../src/validators/shape.ts","../src/index.ts"],"sourcesContent":["import { VueTypesConfig } from './types'\n\nexport const config: VueTypesConfig = {\n  silent: false,\n  logLevel: 'warn',\n}\n","import { isPlainObject as _isPlainObject } from 'is-plain-object'\nimport { config } from './config'\nimport {\n  VueTypeDef,\n  VueTypeValidableDef,\n  VueProp,\n  InferType,\n  PropOptions,\n  VueTypesConfig,\n} from './types'\n\nconst ObjProto = Object.prototype\nconst toString = ObjProto.toString\nexport const hasOwn = ObjProto.hasOwnProperty\n\nconst FN_MATCH_REGEXP = /^\\s*function (\\w+)/\n\n// https://github.com/vuejs/vue/blob/dev/src/core/util/props.js#L177\nexport function getType(\n  fn: VueProp<any> | (() => any) | (new (...args: any[]) => any),\n): string {\n  const type = (fn as VueProp<any>)?.type ?? fn\n  if (type) {\n    const match = type.toString().match(FN_MATCH_REGEXP)\n    return match ? match[1] : ''\n  }\n  return ''\n}\n\nexport function getNativeType(value: any): string {\n  if (value === null || value === undefined) return ''\n  const match = value.constructor.toString().match(FN_MATCH_REGEXP)\n  return match ? match[1].replace(/^Async/, '') : ''\n}\n\ntype PlainObject = Record<string, any>\nexport const isPlainObject = _isPlainObject as (obj: any) => obj is PlainObject\n\n/**\n * No-op function\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() {}\n\n/**\n * A function that returns its first argument\n *\n * @param arg - Any argument\n */\nexport const identity = (arg: any) => arg\n\nlet warn: (msg: string, level?: VueTypesConfig['logLevel']) => void = noop\n\nif (process.env.NODE_ENV !== 'production') {\n  const hasConsole = typeof console !== 'undefined'\n  warn = hasConsole\n    ? function warn(msg: string, level = config.logLevel) {\n        if (config.silent === false) {\n          console[level](`[VueTypes warn]: ${msg}`)\n        }\n      }\n    : noop\n}\n\nexport { warn }\n\n/**\n * Checks for a own property in an object\n *\n * @param {object} obj - Object\n * @param {string} prop - Property to check\n */\nexport const has = <T, U extends keyof T>(obj: T, prop: U) =>\n  hasOwn.call(obj, prop)\n\n/**\n * Determines whether the passed value is an integer. Uses `Number.isInteger` if available\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n * @param {*} value - The value to be tested for being an integer.\n * @returns {boolean}\n */\nexport const isInteger =\n  Number.isInteger ||\n  function isInteger(value: unknown): value is number {\n    return (\n      typeof value === 'number' &&\n      isFinite(value) &&\n      Math.floor(value) === value\n    )\n  }\n\n/**\n * Determines whether the passed value is an Array.\n *\n * @param {*} value - The value to be tested for being an array.\n * @returns {boolean}\n */\nexport const isArray =\n  Array.isArray ||\n  function isArray(value): value is any[] {\n    return toString.call(value) === '[object Array]'\n  }\n\n/**\n * Checks if a value is a function\n *\n * @param {any} value - Value to check\n * @returns {boolean}\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const isFunction = <T extends Function>(value: unknown): value is T =>\n  toString.call(value) === '[object Function]'\n\n/**\n * Checks if the passed-in value is a VueTypes type\n * @param value - The value to check\n * @param name - Optional validator name\n */\nexport const isVueTypeDef = <T>(\n  value: any,\n  name?: string,\n): value is VueTypeDef<T> | VueTypeValidableDef<T> =>\n  isPlainObject(value) &&\n  has(value, '_vueTypes_name') &&\n  (!name || value._vueTypes_name === name)\n\n/**\n * Checks if the passed-in value is a Vue prop definition object or a VueTypes type\n * @param value - The value to check\n */\nexport const isComplexType = <T>(value: any): value is VueProp<T> =>\n  isPlainObject(value) &&\n  (has(value, 'type') ||\n    ['_vueTypes_name', 'validator', 'default', 'required'].some((k) =>\n      has(value, k),\n    ))\n\nexport interface WrappedFn {\n  (...args: any[]): any\n  __original: (...args: any[]) => any\n}\n\n/**\n * Binds a function to a context and saves a reference to the original.\n *\n * @param fn - Target function\n * @param ctx - New function context\n */\nexport function bindTo(fn: (...args: any[]) => any, ctx: any): WrappedFn {\n  return Object.defineProperty(fn.bind(ctx) as WrappedFn, '__original', {\n    value: fn,\n  })\n}\n\n/**\n * Returns the original function bounded with `bindTo`. If the passed-in function\n * has not be bound, the function itself will be returned instead.\n *\n * @param fn - Function to unwrap\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function unwrap<T extends WrappedFn | Function>(fn: T) {\n  return (fn as WrappedFn).__original ?? fn\n}\n\n/**\n * Validates a given value against a prop type object.\n *\n * If `silent` is `false` (default) will return a boolean. If it is set to `true`\n * it will return `true` on success or a string error message on failure\n *\n * @param {Object|*} type - Type to use for validation. Either a type object or a constructor\n * @param {*} value - Value to check\n * @param {boolean} silent - Silence warnings\n */\nexport function validateType<T, U>(\n  type: T,\n  value: U,\n  silent = false,\n): string | boolean {\n  let typeToCheck: Record<string, any>\n  let valid = true\n  let expectedType = ''\n  if (!isPlainObject(type)) {\n    typeToCheck = { type }\n  } else {\n    typeToCheck = type\n  }\n  const namePrefix = isVueTypeDef(typeToCheck)\n    ? typeToCheck._vueTypes_name + ' - '\n    : ''\n\n  if (isComplexType(typeToCheck) && typeToCheck.type !== null) {\n    if (typeToCheck.type === undefined || typeToCheck.type === true) {\n      return valid\n    }\n    if (!typeToCheck.required && value == null) {\n      return valid\n    }\n    if (isArray(typeToCheck.type)) {\n      valid = typeToCheck.type.some(\n        (type: any) => validateType(type, value, true) === true,\n      )\n      expectedType = typeToCheck.type\n        .map((type: any) => getType(type))\n        .join(' or ')\n    } else {\n      expectedType = getType(typeToCheck)\n\n      if (expectedType === 'Array') {\n        valid = isArray(value)\n      } else if (expectedType === 'Object') {\n        valid = isPlainObject(value)\n      } else if (\n        expectedType === 'String' ||\n        expectedType === 'Number' ||\n        expectedType === 'Boolean' ||\n        expectedType === 'Function'\n      ) {\n        valid = getNativeType(value) === expectedType\n      } else {\n        valid = value instanceof typeToCheck.type\n      }\n    }\n  }\n\n  if (!valid) {\n    const msg = `${namePrefix}value \"${value}\" should be of type \"${expectedType}\"`\n    if (silent === false) {\n      warn(msg)\n      return false\n    }\n    return msg\n  }\n\n  if (has(typeToCheck, 'validator') && isFunction(typeToCheck.validator)) {\n    const oldWarn = warn\n    const warnLog: string[] = []\n    warn = (msg) => {\n      warnLog.push(msg)\n    }\n\n    valid = typeToCheck.validator(value)\n    warn = oldWarn\n\n    if (!valid) {\n      const msg = (warnLog.length > 1 ? '* ' : '') + warnLog.join('\\n* ')\n      warnLog.length = 0\n      if (silent === false) {\n        warn(msg)\n        return valid\n      }\n      return msg\n    }\n  }\n  return valid\n}\n\n/**\n * Adds `isRequired` and `def` modifiers to an object\n *\n * @param {string} name - Type internal name\n * @param {object} obj - Object to enhance\n */\nexport function toType<T = any>(name: string, obj: PropOptions<T>) {\n  const type: VueTypeDef<T> = Object.defineProperties(obj as VueTypeDef<T>, {\n    _vueTypes_name: {\n      value: name,\n      writable: true,\n    },\n    isRequired: {\n      get() {\n        this.required = true\n        return this\n      },\n    },\n    def: {\n      value(def?: any) {\n        if (def === undefined) {\n          if (\n            this.type === Boolean ||\n            (Array.isArray(this.type) && this.type.includes(Boolean))\n          ) {\n            this.default = undefined\n            return\n          }\n          if (has(this, 'default')) {\n            delete this.default\n          }\n          return this\n        }\n        if (!isFunction(def) && validateType(this, def, true) !== true) {\n          warn(`${this._vueTypes_name} - invalid default value: \"${def}\"`)\n          return this\n        }\n        if (isArray(def)) {\n          this.default = () => [...def]\n        } else if (isPlainObject(def)) {\n          this.default = () => Object.assign({}, def)\n        } else {\n          this.default = def\n        }\n        return this\n      },\n    },\n  })\n\n  const { validator } = type\n  if (isFunction(validator)) {\n    type.validator = bindTo(validator, type)\n  }\n\n  return type\n}\n\n/**\n * Like `toType` but also adds the `validate()` method to the type object\n *\n * @param {string} name - Type internal name\n * @param {object} obj - Object to enhance\n */\nexport function toValidableType<T = any>(name: string, obj: PropOptions<T>) {\n  const type = toType<T>(name, obj)\n  return Object.defineProperty(type, 'validate', {\n    value(fn: (value: T) => boolean) {\n      if (isFunction(this.validator)) {\n        warn(\n          `${\n            this._vueTypes_name\n          } - calling .validate() will overwrite the current custom validator function. Validator info:\\n${JSON.stringify(\n            this,\n          )}`,\n        )\n      }\n      this.validator = bindTo(fn, this)\n      return this\n    },\n  }) as VueTypeValidableDef<T>\n}\n\n/**\n *  Clones an object preserving all of it's own keys.\n *\n * @param obj - Object to clone\n */\n\nexport function clone<T extends object>(obj: T): T {\n  const descriptors = {} as { [P in keyof T]: any }\n  Object.getOwnPropertyNames(obj).forEach((key) => {\n    descriptors[key as keyof T] = Object.getOwnPropertyDescriptor(obj, key)\n  })\n  return Object.defineProperties({}, descriptors) as T\n}\n\n/**\n * Return a new VueTypes type using another type as base.\n *\n * Properties in the `props` object will overwrite those defined in the source one\n * expect for the `validator` function. In that case both functions will be executed in series.\n *\n * @param name - Name of the new type\n * @param source - Source type\n * @param props - Custom type properties\n */\nexport function fromType<T extends VueTypeDef<any>>(name: string, source: T): T\nexport function fromType<\n  T extends VueTypeDef<any>,\n  V extends PropOptions<InferType<T>>,\n>(name: string, source: T, props: V): Omit<T, keyof V> & V\nexport function fromType<\n  T extends VueTypeDef<any>,\n  V extends PropOptions<InferType<T>>,\n>(name: string, source: T, props?: V) {\n  // 1. create an exact copy of the source type\n  const copy = clone(source)\n\n  // 2. give it a new name\n  copy._vueTypes_name = name\n\n  if (!isPlainObject(props)) {\n    return copy\n  }\n  const { validator, ...rest } = props\n\n  // 3. compose the validator function\n  // with the one on the source (if present)\n  // and ensure it is bound to the copy\n  if (isFunction(validator)) {\n    let { validator: prevValidator } = copy\n\n    if (prevValidator) {\n      prevValidator = unwrap(prevValidator) as (_v: any) => boolean\n    }\n\n    copy.validator = bindTo(\n      prevValidator\n        ? function (this: T, value: any) {\n            return (\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              prevValidator!.call(this, value) && validator.call(this, value)\n            )\n          }\n        : validator,\n      copy,\n    )\n  }\n  // 4. overwrite the rest, if present\n  return Object.assign(copy, rest as V)\n}\n\nexport function indent(string: string) {\n  return string.replace(/^(?!\\s*$)/gm, '  ')\n}\n","import { VueTypesDefaults } from './types'\n\nexport const typeDefaults = (): VueTypesDefaults => ({\n  func: () => undefined,\n  bool: true,\n  string: '',\n  number: 0,\n  array: () => [],\n  object: () => ({}),\n  integer: 0,\n})\n","import { toType, toValidableType, isInteger, warn } from '../utils'\nimport { PropOptions, PropType } from '../types'\n\nexport const any = <T = any>() => toValidableType<T>('any', {})\n\nexport const func = <T extends (...args: any[]) => any>() =>\n  toValidableType<T>('function', {\n    type: Function as PropType<T>,\n  })\n\nexport const bool = () =>\n  toValidableType('boolean', {\n    type: Boolean,\n  })\n\nexport const string = <T extends string = string>() =>\n  toValidableType<T>('string', {\n    type: String as unknown as PropType<T>,\n  })\n\nexport const number = <T extends number = number>() =>\n  toValidableType<T>('number', {\n    type: Number as unknown as PropType<T>,\n  })\n\nexport const array = <T>() =>\n  toValidableType<T[]>('array', {\n    type: Array,\n  })\n\nexport const object = <T extends Record<string, any>>() =>\n  toValidableType<T>('object', {\n    type: Object,\n  })\n\nexport const integer = <T extends number = number>() =>\n  toType<T>('integer', {\n    type: Number as unknown as PropType<T>,\n    validator(value) {\n      const res = isInteger(value)\n      if (res === false) {\n        warn(`integer - \"${value}\" is not an integer`)\n      }\n      return res\n    },\n  })\n\nexport const symbol = () =>\n  toType<symbol>('symbol', {\n    validator(value: unknown) {\n      const res = typeof value === 'symbol'\n      if (res === false) {\n        warn(`symbol - invalid value \"${value}\"`)\n      }\n      return res\n    },\n  })\n\nexport const nullable = () =>\n  Object.defineProperty(\n    {\n      type: null as unknown as PropType<null>,\n      validator(value: unknown) {\n        const res = value === null\n        if (res === false) {\n          warn(`nullable - value should be null`)\n        }\n        return res\n      },\n    },\n    '_vueTypes_name',\n    { value: 'nullable' },\n  ) as PropOptions<null>\n","import { toType, warn } from '../utils'\nimport { ValidatorFunction, VueTypeDef, PropType } from '../types'\n\nexport default function custom<T>(\n  validatorFn: ValidatorFunction<T>,\n  warnMsg = 'custom validation failed',\n) {\n  if (typeof validatorFn !== 'function') {\n    throw new TypeError(\n      '[VueTypes error]: You must provide a function as argument',\n    )\n  }\n\n  return toType<T>(validatorFn.name || '<<anonymous function>>', {\n    type: null as unknown as PropType<T>,\n    validator(this: VueTypeDef<T>, value: T) {\n      const valid = validatorFn(value)\n      if (!valid) warn(`${this._vueTypes_name} - ${warnMsg}`)\n      return valid\n    },\n  })\n}\n","import { Prop, PropOptions } from '../types'\nimport { toType, warn, isArray } from '../utils'\n\nexport default function oneOf<D, T extends readonly D[] = readonly D[]>(\n  arr: T,\n) {\n  if (!isArray(arr)) {\n    throw new TypeError(\n      '[VueTypes error]: You must provide an array as argument.',\n    )\n  }\n  const msg = `oneOf - value should be one of \"${arr\n    .map((v: any) => (typeof v === 'symbol' ? v.toString() : v))\n    .join('\", \"')}\".`\n  const base: PropOptions<T[number]> = {\n    validator(value) {\n      const valid = arr.indexOf(value) !== -1\n      if (!valid) warn(msg)\n      return valid\n    },\n  }\n  if (arr.indexOf(null) === -1) {\n    const type = arr.reduce(\n      (ret, v) => {\n        if (v !== null && v !== undefined) {\n          const constr = (v as any).constructor\n          ret.indexOf(constr) === -1 && ret.push(constr)\n        }\n        return ret\n      },\n      [] as Prop<T[number]>[],\n    )\n\n    if (type.length > 0) {\n      base.type = type\n    }\n  }\n\n  return toType<T[number]>('oneOf', base)\n}\n","import { Prop, VueProp, InferType, PropType } from '../types'\nimport {\n  isArray,\n  isComplexType,\n  isVueTypeDef,\n  isFunction,\n  toType,\n  validateType,\n  warn,\n  indent,\n} from '../utils'\n\nexport default function oneOfType<\n  D extends V,\n  U extends VueProp<any> | Prop<any> = any,\n  V = InferType<U>,\n>(arr: U[]) {\n  if (!isArray(arr)) {\n    throw new TypeError(\n      '[VueTypes error]: You must provide an array as argument',\n    )\n  }\n\n  let hasCustomValidators = false\n  let hasNullable = false\n\n  let nativeChecks: Prop<V>[] = []\n\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\n  for (let i = 0; i < arr.length; i += 1) {\n    const type = arr[i]\n    if (isComplexType<V>(type)) {\n      if (isFunction(type.validator)) {\n        hasCustomValidators = true\n      }\n      if (isVueTypeDef<V>(type, 'oneOf') && type.type) {\n        nativeChecks = nativeChecks.concat(type.type as PropType<V>)\n        continue\n      }\n      if (isVueTypeDef<V>(type, 'nullable')) {\n        hasNullable = true\n        continue\n      }\n      if (type.type === true || !type.type) {\n        warn('oneOfType - invalid usage of \"true\" and \"null\" as types.')\n        continue\n      }\n      nativeChecks = nativeChecks.concat(type.type)\n    } else {\n      nativeChecks.push(type as Prop<V>)\n    }\n  }\n\n  // filter duplicates\n  nativeChecks = nativeChecks.filter((t, i) => nativeChecks.indexOf(t) === i)\n\n  const typeProp =\n    hasNullable === false && nativeChecks.length > 0 ? nativeChecks : null\n\n  if (!hasCustomValidators) {\n    // we got just native objects (ie: Array, Object)\n    // delegate to Vue native prop check\n    return toType<D>('oneOfType', {\n      type: typeProp as unknown as PropType<D>,\n    })\n  }\n\n  return toType<D>('oneOfType', {\n    type: typeProp as unknown as PropType<D>,\n    validator(value) {\n      const err: string[] = []\n      const valid = arr.some((type) => {\n        const res = validateType(type, value, true)\n        if (typeof res === 'string') {\n          err.push(res)\n        }\n        return res === true\n      })\n\n      if (!valid) {\n        warn(\n          `oneOfType - provided value does not match any of the ${\n            err.length\n          } passed-in validators:\\n${indent(err.join('\\n'))}`,\n        )\n      }\n\n      return valid\n    },\n  })\n}\n","import { Prop, VueProp, InferType } from '../types'\nimport { toType, validateType, warn, indent } from '../utils'\n\nexport default function arrayOf<T extends VueProp<any> | Prop<any>>(type: T) {\n  return toType<InferType<T>[]>('arrayOf', {\n    type: Array,\n    validator(values: any[]) {\n      let vResult: string | boolean = ''\n      const valid = values.every((value) => {\n        vResult = validateType(type, value, true)\n        return vResult === true\n      })\n      if (!valid) {\n        warn(`arrayOf - value validation error:\\n${indent(vResult as string)}`)\n      }\n      return valid\n    },\n  })\n}\n","import { toType } from '../utils'\nimport { Constructor } from '../types'\n\nexport default function instanceOf<C extends Constructor>(\n  instanceConstructor: C,\n) {\n  return toType<InstanceType<C>>('instanceOf', {\n    type: instanceConstructor,\n  })\n}\n","import { Prop, VueProp, InferType } from '../types'\nimport { toType, validateType, warn, indent } from '../utils'\n\nexport default function objectOf<T extends VueProp<any> | Prop<any>>(type: T) {\n  return toType<Record<string, InferType<T>>>('objectOf', {\n    type: Object,\n    validator(obj) {\n      let vResult: string | boolean = ''\n      const valid = Object.keys(obj).every((key) => {\n        vResult = validateType(type, obj[key], true)\n        return vResult === true\n      })\n\n      if (!valid) {\n        warn(`objectOf - value validation error:\\n${indent(vResult as string)}`)\n      }\n      return valid\n    },\n  })\n}\n","import { Prop, VueProp, VueTypeShape, VueTypeLooseShape } from '../types'\nimport { toType, validateType, warn, isPlainObject, indent } from '../utils'\n\nexport default function shape<T extends object>(obj: {\n  [K in keyof T]: Prop<T[K]> | VueProp<T[K]>\n}): VueTypeShape<T> {\n  const keys = Object.keys(obj)\n  const requiredKeys = keys.filter((key) => !!(obj as any)[key]?.required)\n\n  const type = toType('shape', {\n    type: Object,\n    validator(this: VueTypeShape<T> | VueTypeLooseShape<T>, value) {\n      if (!isPlainObject(value)) {\n        return false\n      }\n      const valueKeys = Object.keys(value)\n\n      // check for required keys (if any)\n      if (\n        requiredKeys.length > 0 &&\n        requiredKeys.some((req) => valueKeys.indexOf(req) === -1)\n      ) {\n        const missing = requiredKeys.filter(\n          (req) => valueKeys.indexOf(req) === -1,\n        )\n        if (missing.length === 1) {\n          warn(`shape - required property \"${missing[0]}\" is not defined.`)\n        } else {\n          warn(\n            `shape - required properties \"${missing.join(\n              '\", \"',\n            )}\" are not defined.`,\n          )\n        }\n\n        return false\n      }\n\n      return valueKeys.every((key) => {\n        if (keys.indexOf(key) === -1) {\n          if ((this as VueTypeLooseShape<T>)._vueTypes_isLoose === true)\n            return true\n          warn(\n            `shape - shape definition does not include a \"${key}\" property. Allowed keys: \"${keys.join(\n              '\", \"',\n            )}\".`,\n          )\n          return false\n        }\n        const type = (obj as any)[key]\n        const valid = validateType(type, value[key], true)\n        if (typeof valid === 'string') {\n          warn(`shape - \"${key}\" property validation error:\\n ${indent(valid)}`)\n        }\n        return valid === true\n      })\n    },\n  }) as VueTypeShape<T>\n\n  Object.defineProperty(type, '_vueTypes_isLoose', {\n    writable: true,\n    value: false,\n  })\n\n  Object.defineProperty(type, 'loose', {\n    get() {\n      this._vueTypes_isLoose = true\n      return this\n    },\n  })\n\n  return type\n}\n","import {\n  toType,\n  toValidableType,\n  validateType,\n  isArray,\n  isVueTypeDef,\n  has,\n  fromType,\n  warn,\n} from './utils'\n\nimport {\n  VueTypesDefaults,\n  ExtendProps,\n  VueTypeDef,\n  VueTypeValidableDef,\n  VueTypeShape,\n  VueTypeLooseShape,\n} from './types'\nimport { typeDefaults } from './sensibles'\nimport { PropOptions } from './types'\n\nimport {\n  any,\n  func,\n  bool,\n  string,\n  number,\n  array,\n  integer,\n  symbol,\n  object,\n  nullable,\n} from './validators/native'\nimport custom from './validators/custom'\nimport oneOf from './validators/oneof'\nimport oneOfType from './validators/oneoftype'\nimport arrayOf from './validators/arrayof'\nimport instanceOf from './validators/instanceof'\nimport objectOf from './validators/objectof'\nimport shape from './validators/shape'\nimport { config } from './config'\n\nconst BaseVueTypes = /*#__PURE__*/ (() =>\n  // eslint-disable-next-line @typescript-eslint/no-extraneous-class\n  class BaseVueTypes {\n    static defaults: Partial<VueTypesDefaults> = {}\n\n    static sensibleDefaults: Partial<VueTypesDefaults> | boolean\n\n    static config = config\n\n    static get any() {\n      return any()\n    }\n    static get func() {\n      return func().def(this.defaults.func)\n    }\n    static get bool() {\n      // prevent undefined to be explicitly set\n      if (this.defaults.bool === undefined) {\n        return bool()\n      }\n      return bool().def(this.defaults.bool)\n    }\n    static get string() {\n      return string().def(this.defaults.string)\n    }\n    static get number() {\n      return number().def(this.defaults.number)\n    }\n    static get array() {\n      return array().def(this.defaults.array)\n    }\n    static get object() {\n      return object().def(this.defaults.object)\n    }\n    static get integer() {\n      return integer().def(this.defaults.integer)\n    }\n    static get symbol() {\n      return symbol()\n    }\n\n    static get nullable() {\n      return nullable()\n    }\n\n    static readonly custom = custom\n    static readonly oneOf = oneOf\n    static readonly instanceOf = instanceOf\n    static readonly oneOfType = oneOfType\n    static readonly arrayOf = arrayOf\n    static readonly objectOf = objectOf\n    static readonly shape = shape\n\n    static extend<T = any>(props: ExtendProps | ExtendProps[]): T {\n      warn(\n        `VueTypes.extend is deprecated. Use the ES6+ method instead. See https://dwightjack.github.io/vue-types/advanced/extending-vue-types.html#extending-namespaced-validators-in-es6 for details.`,\n      )\n      if (isArray(props)) {\n        props.forEach((p) => this.extend(p))\n        return this as any\n      }\n\n      const { name, validate = false, getter = false, ...opts } = props\n\n      if (has(this, name as any)) {\n        throw new TypeError(`[VueTypes error]: Type \"${name}\" already defined`)\n      }\n\n      const { type } = opts\n      if (isVueTypeDef(type)) {\n        // we are using as base type a vue-type object\n\n        // detach the original type\n        // we are going to inherit the parent data.\n        delete opts.type\n\n        if (getter) {\n          return Object.defineProperty(this as unknown as T, name, {\n            get: () => fromType(name, type, opts as Omit<ExtendProps, 'type'>),\n          })\n        }\n        return Object.defineProperty(this as unknown as T, name, {\n          value(...args: unknown[]) {\n            const t = fromType(name, type, opts as Omit<ExtendProps, 'type'>)\n            if (t.validator) {\n              t.validator = t.validator.bind(t, ...args)\n            }\n            return t\n          },\n        })\n      }\n\n      let descriptor: PropertyDescriptor\n      if (getter) {\n        descriptor = {\n          get() {\n            const typeOptions = Object.assign({}, opts as PropOptions<T>)\n            if (validate) {\n              return toValidableType<T>(name, typeOptions)\n            }\n            return toType<T>(name, typeOptions)\n          },\n          enumerable: true,\n        }\n      } else {\n        descriptor = {\n          value(...args: T[]) {\n            const typeOptions = Object.assign({}, opts as PropOptions<T>)\n            let ret: VueTypeDef<T>\n            if (validate) {\n              ret = toValidableType<T>(name, typeOptions)\n            } else {\n              ret = toType<T>(name, typeOptions)\n            }\n\n            if (typeOptions.validator) {\n              ret.validator = typeOptions.validator.bind(ret, ...args)\n            }\n            return ret\n          },\n          enumerable: true,\n        }\n      }\n\n      return Object.defineProperty(this as unknown as T, name, descriptor)\n    }\n\n    static utils = {\n      validate<T, U>(value: T, type: U) {\n        return validateType<U, T>(type, value, true) === true\n      },\n      toType<T = unknown>(\n        name: string,\n        obj: PropOptions<T>,\n        validable = false,\n      ): VueTypeDef<T> | VueTypeValidableDef<T> {\n        return validable ? toValidableType<T>(name, obj) : toType<T>(name, obj)\n      },\n    }\n  })()\n\nfunction createTypes(defs: Partial<VueTypesDefaults> = typeDefaults()) {\n  return class extends BaseVueTypes {\n    static defaults: Partial<VueTypesDefaults> = { ...defs }\n\n    static get sensibleDefaults() {\n      return { ...this.defaults }\n    }\n\n    static set sensibleDefaults(v: boolean | Partial<VueTypesDefaults>) {\n      if (v === false) {\n        this.defaults = {}\n        return\n      }\n      if (v === true) {\n        this.defaults = { ...defs }\n        return\n      }\n      this.defaults = { ...v }\n    }\n  }\n}\n\nexport default class VueTypes /*#__PURE__*/ extends createTypes() {}\n\nexport {\n  any,\n  func,\n  bool,\n  string,\n  number,\n  array,\n  integer,\n  symbol,\n  object,\n  custom,\n  oneOf,\n  oneOfType,\n  arrayOf,\n  instanceOf,\n  objectOf,\n  shape,\n  nullable,\n  createTypes,\n  toType,\n  toValidableType,\n  validateType,\n  fromType,\n  config,\n}\n\nexport type VueTypesInterface = ReturnType<typeof createTypes>\nexport type { VueTypeDef, VueTypeValidableDef, VueTypeShape, VueTypeLooseShape }\n"],"names":["config","silent","logLevel","_excluded","ObjProto","Object","prototype","toString","hasOwn","hasOwnProperty","FN_MATCH_REGEXP","getType","fn","_fn$type","type","match","isPlainObject","_isPlainObject","warn","has","obj","prop","call","isInteger","Number","value","isFinite","Math","floor","isArray","Array","isFunction","isVueTypeDef","name","_vueTypes_name","isComplexType","some","k","bindTo","ctx","defineProperty","bind","validateType","typeToCheck","valid","expectedType","namePrefix","undefined","required","map","join","constructor","replace","getNativeType","msg","validator","oldWarn","warnLog","push","length","toType","defineProperties","writable","isRequired","get","this","def","Boolean","includes","concat","assign","toValidableType","JSON","stringify","fromType","source","props","descriptors","copy","getOwnPropertyNames","forEach","key","getOwnPropertyDescriptor","_fn$__original","rest","_objectWithoutPropertiesLoose","prevValidator","__original","indent","string","any","func","Function","bool","String","number","array","object","integer","res","symbol","nullable","custom","validatorFn","warnMsg","TypeError","oneOf","arr","v","base","indexOf","reduce","ret","constr","oneOfType","hasCustomValidators","hasNullable","nativeChecks","i","filter","t","typeProp","err","arrayOf","values","vResult","every","instanceOf","instanceConstructor","objectOf","keys","shape","requiredKeys","_obj$key","_this","valueKeys","req","missing","_vueTypes_isLoose","BaseVueTypes","_BaseVueTypes","extend","p","_props$validate","validate","_props$getter","getter","opts","descriptor","_t$validator","apply","slice","arguments","typeOptions","enumerable","_typeOptions$validato","_createClass","defaults","sensibleDefaults","utils","validable","createTypes","defs","_Class","_BaseVueTypes2","_inheritsLoose","_extends","set","VueTypes","_createTypes"],"mappings":"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"}