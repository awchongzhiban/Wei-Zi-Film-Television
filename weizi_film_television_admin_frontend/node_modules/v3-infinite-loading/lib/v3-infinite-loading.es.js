import { nextTick as h, openBlock as E, createElementBlock as w, pushScopeId as B, popScopeId as H, createElementVNode as s, defineComponent as C, ref as m, toRefs as R, watch as b, onMounted as N, onUnmounted as O, withDirectives as V, renderSlot as u, createVNode as M, vShow as T, toDisplayString as v, createCommentVNode as g } from "vue";
function D(e, o) {
  const n = e.getBoundingClientRect();
  if (!o)
    return n.top >= 0 && n.bottom <= window.innerHeight;
  const t = o.getBoundingClientRect();
  return n.top >= t.top && n.bottom <= t.bottom;
}
async function q(e) {
  return await h(), e.value instanceof HTMLElement ? e.value : e.value ? document.querySelector(e.value) : null;
}
function y(e) {
  let o = `0px 0px ${e.distance}px 0px`;
  e.top && (o = `${e.distance}px 0px 0px 0px`);
  const n = new IntersectionObserver(
    (t) => {
      t[0].isIntersecting && (e.firstload && e.emit(), e.firstload = !0);
    },
    { root: e.parentEl, rootMargin: o }
  );
  return n.observe(e.infiniteLoading.value), n;
}
const x = (e, o) => {
  const n = e.__vccOpts || e;
  for (const [t, c] of o)
    n[t] = c;
  return n;
}, P = {}, U = (e) => (B("data-v-d3e37633"), e = e(), H(), e), j = { class: "container" }, z = /* @__PURE__ */ U(() => /* @__PURE__ */ s("div", { class: "spinner" }, null, -1)), A = [
  z
];
function F(e, o) {
  return E(), w("div", j, A);
}
const G = /* @__PURE__ */ x(P, [["render", F], ["__scopeId", "data-v-d3e37633"]]), J = { class: "state-error" }, K = /* @__PURE__ */ C({
  __name: "InfiniteLoading",
  props: {
    top: { type: Boolean, default: !1 },
    target: {},
    distance: { default: 0 },
    identifier: {},
    firstload: { type: Boolean, default: !0 },
    slots: {}
  },
  emits: ["infinite"],
  setup(e, { emit: o }) {
    const n = e;
    let t = null, c = 0;
    const d = m(null), r = m(""), { top: p, firstload: I, distance: S } = n, { identifier: k, target: L } = R(n), i = {
      infiniteLoading: d,
      top: p,
      firstload: I,
      distance: S,
      parentEl: null,
      emit() {
        c = (i.parentEl || document.documentElement).scrollHeight, f.loading(), o("infinite", f);
      }
    }, f = {
      loading() {
        r.value = "loading";
      },
      async loaded() {
        r.value = "loaded";
        const l = i.parentEl || document.documentElement;
        await h(), p && (l.scrollTop = l.scrollHeight - c), D(d.value, i.parentEl) && i.emit();
      },
      complete() {
        r.value = "complete", t == null || t.disconnect();
      },
      error() {
        r.value = "error";
      }
    };
    return b(k, () => {
      t == null || t.disconnect(), t = y(i);
    }), N(async () => {
      i.parentEl = await q(L), t = y(i);
    }), O(() => {
      t == null || t.disconnect();
    }), (l, _) => (E(), w("div", {
      ref_key: "infiniteLoading",
      ref: d,
      style: { "min-height": "1px" }
    }, [
      V(s("div", null, [
        u(l.$slots, "spinner", {}, () => [
          M(G)
        ], !0)
      ], 512), [
        [T, r.value == "loading"]
      ]),
      r.value == "complete" ? u(l.$slots, "complete", { key: 0 }, () => {
        var a;
        return [
          s("span", null, v(((a = l.slots) == null ? void 0 : a.complete) || "No more results!"), 1)
        ];
      }, !0) : g("", !0),
      r.value == "error" ? u(l.$slots, "error", {
        key: 1,
        retry: i.emit
      }, () => {
        var a;
        return [
          s("span", J, [
            s("span", null, v(((a = l.slots) == null ? void 0 : a.error) || "Oops something went wrong!"), 1),
            s("button", {
              class: "retry",
              onClick: _[0] || (_[0] = //@ts-ignore
              (...$) => i.emit && i.emit(...$))
            }, "retry")
          ])
        ];
      }, !0) : g("", !0)
    ], 512));
  }
});
const W = /* @__PURE__ */ x(K, [["__scopeId", "data-v-a7077831"]]);
export {
  W as default
};
